[
    {
        "intent": "[CLS] remove last element for var_0 . [SEP]",
        "reference": "quant = quant [ : - 1 ]",
        "Output": "var_0 = var_0 [ : - 1 ]",
        "Var_Maps": [
            {
                "quant": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] get the var_2 element of the it ##era ##ble pattern _ it ##er , assign the result for var_3 and var_1 , respectively . [SEP]",
        "reference": "ch , escaped = next ( input_iter )",
        "Output": "ch , escaped = next ( input_iter )",
        "Var_Maps": [
            {
                "input_iter": "var_0",
                "escaped": "var_1",
                "next": "var_2",
                "ch": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception , [SEP]",
        "reference": "try : pass except Stop Iteration : pass",
        "Output": "try : pass except Stop Iteration : pass",
        "Var_Maps": [
            {
                "StopIteration": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is none . [SEP]",
        "reference": "ch = None",
        "Output": "ch = None",
        "Var_Maps": [
            {
                "ch": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 equals a string str_0 , [SEP]",
        "reference": "if ch = = ` ? ` : pass",
        "Output": "if ch = = ` ? ` : pass",
        "Var_Maps": [
            {
                "?": "var_1",
                "ch": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is none . [SEP]",
        "reference": "ch = None",
        "Output": "ch = None",
        "Var_Maps": [
            {
                "ch": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] convert first element of var_0 var_1 o a var_1 e ##ger , return the result and var_2 . [SEP]",
        "reference": "return int ( values [ 0 ] ) , ch",
        "Output": "return int ( values [ 0 ] ) , ch",
        "Var_Maps": [
            {
                "values": "var_0",
                "int": "var_1",
                "ch": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 2 arguments var_1 and var_2 . [SEP]",
        "reference": "def contains ( source , inst ) : pass",
        "Output": "def contains ( source , inst ) : pass",
        "Var_Maps": [
            {
                "contains": "var_0",
                "source": "var_1",
                "inst": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 is an var_2 an ##ce of var_2 class , [SEP]",
        "reference": "if isinstance ( source , inst ) : pass",
        "Output": "if isinstance ( source , inst ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "source": "var_1",
                "inst": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return boo ##lean true . [SEP]",
        "reference": "return True",
        "Output": "return ` False `",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] if var_2 is an instance of var_1 class , [SEP]",
        "reference": "if isinstance ( source , Non Capture ) : pass",
        "Output": "if isinstance ( source , Non Capture ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "NonCapture": "var_1",
                "source": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_1 in var_0 , [SEP]",
        "reference": "for elt in source : pass",
        "Output": "for elt in source : pass",
        "Var_Maps": [
            {
                "source": "var_0",
                "elt": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with 2 arguments : var_2 and var_1 , if it evaluate ##s to true , [SEP]",
        "reference": "if contains ( elt , inst ) : pass",
        "Output": "if contains ( elt , inst ) : pass",
        "Var_Maps": [
            {
                "contains": "var_0",
                "inst": "var_1",
                "elt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return boo ##lean true . [SEP]",
        "reference": "return True",
        "Output": "return ` False `",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] return boo ##lean false . [SEP]",
        "reference": "return False",
        "Output": "return ` False `",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def flatten_result ( source ) : pass",
        "Output": "def flatten_result ( source ) : pass",
        "Var_Maps": [
            {
                "flatten_result": "var_0",
                "source": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if source is None : pass",
        "Output": "if source is None : pass",
        "Var_Maps": [
            {
                "source": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 r var_0 e var_0 t var_0 u var_0 r var_0 n var_0 var_0 a var_0 var_0 l var_0 i var_0 s var_0 t var_0 var_0 c var_0 o var_0 n var_0 t var_0 a var_0 i var_0 n var_0 i var_0 n var_0 g var_0 var_0 a var_0 n var_0 var_0 e var_0 m var_0 p var_0 t var_0 y var_0 var_0 s var_0 t var_0 r var_0 i var_0 n var_0 g var_0 var_0 a var_0 n var_0 d var_0 var_0 a var_0 var_0 l var_0 i var_0 s var_0 t var_0 var_0 c var_0 o var_0 n var_0 t var_0 a var_0 i var_0 n var_0 i var_0 n var_0 g var_0 var_0 a var_0 n var_0 var_0 e var_0 m var_0 p var_0 t var_0 y var_0 var_0 l var_0 i var_0 s var_0 t var_0 . var_0 [SEP]",
        "reference": "return [ ` ` ] , [ [ ] ]",
        "Output": "yield ` `",
        "Var_Maps": [
            {
                "": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 is an instance of var_2 class , [SEP]",
        "reference": "if isinstance ( source , Group ) : pass",
        "Output": "if isinstance ( source , Group ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "source": "var_1",
                "Group": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if second element of var_0 is none , [SEP]",
        "reference": "if source [ 1 ] is None : pass",
        "Output": "if source [ 1 ] is None : pass",
        "Var_Maps": [
            {
                "source": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an empty list , [SEP]",
        "reference": "params = [ ]",
        "Output": "params = [ ]",
        "Var_Maps": [
            {
                "params": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] var_0 is a list with second element of var_1 as a element . [SEP]",
        "reference": "params = [ source [ 1 ] ]",
        "Output": "params = [ source [ 1 ] ]",
        "Var_Maps": [
            {
                "params": "var_0",
                "source": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return a list containing first element of var_0 and a list containing var_1 . [SEP]",
        "reference": "return [ source [ 0 ] ] , [ params ]",
        "Output": "return [ source [ 0 ] , params [ 0 ] ]",
        "Var_Maps": [
            {
                "source": "var_0",
                "params": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 v var_1 a var_1 r var_1 _ var_1 0 var_1 var_1 i var_1 s var_1 var_1 a var_1 var_1 l var_1 i var_1 s var_1 t var_1 var_1 c var_1 o var_1 n var_1 t var_1 a var_1 i var_1 n var_1 i var_1 n var_1 g var_1 var_1 a var_1 n var_1 var_1 e var_1 m var_1 p var_1 t var_1 y var_1 var_1 s var_1 t var_1 r var_1 i var_1 n var_1 g var_1 . var_1 [SEP]",
        "reference": "result = [ ` ` ]",
        "Output": "result = [ ` ` ]",
        "Var_Maps": [
            {
                "result": "var_0",
                "": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a list containing an empty list . [SEP]",
        "reference": "result_args = [ [ ] ]",
        "Output": "result_args = [ ]",
        "Var_Maps": [
            {
                "result_args": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 and var_0 are integer 0 . [SEP]",
        "reference": "pos = last = 0",
        "Output": "pos = last = 0",
        "Var_Maps": [
            {
                "last": "var_0",
                "pos": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_2 and var_3 in var_0 d it ##era ##ble var_1 , [SEP]",
        "reference": "for pos , elt in enumerate ( source ) : pass",
        "Output": "for pos , elt in enumerate ( source ) : pass",
        "Var_Maps": [
            {
                "enumerate": "var_0",
                "source": "var_1",
                "pos": "var_2",
                "elt": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 is an instance of var_3 . var_0 class , [SEP]",
        "reference": "if isinstance ( elt , six . string_types ) : pass",
        "Output": "if isinstance ( elt , six . string_types ) : pass",
        "Var_Maps": [
            {
                "string_types": "var_0",
                "isinstance": "var_1",
                "elt": "var_2",
                "six": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] skip this loop iteration . [SEP]",
        "reference": "continue",
        "Output": "continue",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] if var_2 is an instance of var_1 class , [SEP]",
        "reference": "if isinstance ( elt , Group ) : pass",
        "Output": "if isinstance ( elt , Group ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "Group": "var_1",
                "elt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] inc ##rem ##ent var_0 by fir ##s element of var_1 . [SEP]",
        "reference": "piece + = elt [ 0 ]",
        "Output": "piece + = elt [ 0 ]",
        "Var_Maps": [
            {
                "piece": "var_0",
                "elt": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute second element of var_1 for var_0 . [SEP]",
        "reference": "param = elt [ 1 ]",
        "Output": "param = elt [ 1 ]",
        "Var_Maps": [
            {
                "param": "var_0",
                "elt": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] var_0 is none . [SEP]",
        "reference": "param = None",
        "Output": "param = None",
        "Var_Maps": [
            {
                "param": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] inc ##rem ##ent var_1 by one , substitute the result for var_0 . [SEP]",
        "reference": "last = pos + 1",
        "Output": "last = pos + 1",
        "Var_Maps": [
            {
                "last": "var_0",
                "pos": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_3 var_3 n var_1 of var_3 nt ##eger ##s from 0 to var_2 gt ##h of var_0 , not var_3 nc ##lu ##ded , [SEP]",
        "reference": "for i in range ( len ( result ) ) : pass",
        "Output": "for i in range ( 0 , len ( result ) ) : pass",
        "Var_Maps": [
            {
                "result": "var_0",
                "range": "var_1",
                "len": "var_2",
                "i": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 nc ##rem ##ent var_2 - th element of var_0 by var_1 . [SEP]",
        "reference": "result [ i ] + = piece",
        "Output": "result [ i ] + = piece",
        "Var_Maps": [
            {
                "result": "var_0",
                "piece": "var_1",
                "i": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if param : pass",
        "Output": "if param : pass",
        "Var_Maps": [
            {
                "param": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 var_2 to var_3 - th element of var_0 . [SEP]",
        "reference": "result_args [ i ] . append ( param )",
        "Output": "result_args [ i ] . append ( param )",
        "Var_Maps": [
            {
                "result_args": "var_0",
                "append": "var_1",
                "param": "var_2",
                "i": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_3 is an instance of var_2 or var_1 classes , [SEP]",
        "reference": "if isinstance ( elt , ( Choice , Non Capture ) ) : pass",
        "Output": "if isinstance ( elt , ( Choice , Non Capture ) ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "NonCapture": "var_1",
                "Choice": "var_2",
                "elt": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 is an instance of var_1 class , [SEP]",
        "reference": "if isinstance ( elt , Non Capture ) : pass",
        "Output": "if isinstance ( elt , Non Capture ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "NonCapture": "var_1",
                "elt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an list with an element var_0 . [SEP]",
        "reference": "elt = [ elt ]",
        "Output": "elt = [ elt ]",
        "Var_Maps": [
            {
                "elt": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 and var_1 are empty lists . [SEP]",
        "reference": "inner_result , inner_args = [ ] , [ ]",
        "Output": "inner_result , inner_args = [ ]",
        "Var_Maps": [
            {
                "inner_result": "var_0",
                "inner_args": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_0 in var_1 , [SEP]",
        "reference": "for item in elt : pass",
        "Output": "for item in elt : pass",
        "Var_Maps": [
            {
                "item": "var_0",
                "elt": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_2 , assign the var_3 ul ##t to var_3 and var_1 , var_3 pe ##ctive ##ly . [SEP]",
        "reference": "res , args = flatten_result ( item )",
        "Output": "res , args = flatten_result ( item )",
        "Var_Maps": [
            {
                "flatten_result": "var_0",
                "args": "var_1",
                "item": "var_2",
                "res": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 list var_0 with var_2 . [SEP]",
        "reference": "inner_result . extend ( res )",
        "Output": "inner_result . extend ( res )",
        "Var_Maps": [
            {
                "inner_result": "var_0",
                "extend": "var_1",
                "res": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 list var_0 with var_2 . [SEP]",
        "reference": "inner_args . extend ( args )",
        "Output": "inner_args . extend ( args )",
        "Var_Maps": [
            {
                "inner_args": "var_0",
                "extend": "var_1",
                "args": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an empty list . [SEP]",
        "reference": "new_result = [ ]",
        "Output": "new_result = [ ]",
        "Var_Maps": [
            {
                "new_result": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an empty list . [SEP]",
        "reference": "new_args = [ ]",
        "Output": "new_args = [ ]",
        "Var_Maps": [
            {
                "new_args": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_4 elements of var_1 and var_0 into a list of tu ##ples , for every var_2 and var_3 in the var_1 , [SEP]",
        "reference": "for item , args in zip ( result , result_args ) : pass",
        "Output": "for item , args in var_5 ( zip ( result , result_args ) ) : pass",
        "Var_Maps": [
            {
                "result_args": "var_0",
                "result": "var_1",
                "item": "var_2",
                "args": "var_3",
                "zip": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] var_4 elements of var_0 and var_1 into a list of tu ##ples , for every var_2 and var_3 in the result , [SEP]",
        "reference": "for i_item , i_args in zip ( inner_result , inner_args ) : pass",
        "Output": "for i_item , i_args in zip ( inner_result , inner_args ) : pass",
        "Var_Maps": [
            {
                "inner_result": "var_0",
                "inner_args": "var_1",
                "i_item": "var_2",
                "i_args": "var_3",
                "zip": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] sum var_3 and var_2 together , var_1 the result to var_0 . [SEP]",
        "reference": "new_result . append ( item + i_item )",
        "Output": "new_result . append ( item + i_item )",
        "Var_Maps": [
            {
                "new_result": "var_0",
                "append": "var_1",
                "i_item": "var_2",
                "item": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 var_2 to var_3 , var_1 var_0 with the result . [SEP]",
        "reference": "new_args . append ( args [ : ] + i_args )",
        "Output": "args . new_args ( i_args . append ( ) )",
        "Var_Maps": [
            {
                "new_args": "var_0",
                "append": "var_1",
                "i_args": "var_2",
                "args": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_1 . [SEP]",
        "reference": "result = new_result",
        "Output": "result = new_result",
        "Var_Maps": [
            {
                "new_result": "var_0",
                "result": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "result_args = new_args",
        "Output": "result_args = new_args",
        "Var_Maps": [
            {
                "result_args": "var_0",
                "new_args": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 is greater than or equal to var_0 , [SEP]",
        "reference": "if pos > = last : pass",
        "Output": "if pos > = last : pass",
        "Var_Maps": [
            {
                "last": "var_0",
                "pos": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_3 var_3 n var_1 of var_3 nt ##eger ##s from 0 to var_2 gt ##h of var_0 , not var_3 nc ##lu ##ded , [SEP]",
        "reference": "for i in range ( len ( result ) ) : pass",
        "Output": "for i in range ( 0 , len ( result ) ) : pass",
        "Var_Maps": [
            {
                "result": "var_0",
                "range": "var_1",
                "len": "var_2",
                "i": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 nc ##rem ##ent var_2 - th element of var_0 by var_1 . [SEP]",
        "reference": "result [ i ] + = piece",
        "Output": "result [ i ] + = piece",
        "Var_Maps": [
            {
                "result": "var_0",
                "piece": "var_1",
                "i": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_1 and var_0 . [SEP]",
        "reference": "return result , result_args",
        "Output": "return result , result_args",
        "Var_Maps": [
            {
                "result_args": "var_0",
                "result": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_2 and var_1 into default name space . [SEP]",
        "reference": "from django . utils . functional import curry , Promise",
        "Output": "from django . utils . functional import curry , Promise",
        "Var_Maps": [
            {
                "django.utils.functional": "var_0",
                "Promise": "var_1",
                "curry": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . utils import six",
        "Output": "from django . utils import six",
        "Var_Maps": [
            {
                "django.utils": "var_0",
                "six": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] derive the class var_0 from var_1 base class . [SEP]",
        "reference": "class Escape Data ( object ) : pass",
        "Output": "class Escape Data ( object ) : pass",
        "Var_Maps": [
            {
                "EscapeData": "var_0",
                "object": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] do nothing . [SEP]",
        "reference": "pass",
        "Output": "pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] derive the class var_0 from var_2 and var_1 base classes . [SEP]",
        "reference": "class Escape Bytes ( bytes , Escape Data ) : pass",
        "Output": "class Escape Bytes ( bytes , Escape Data ) : pass",
        "Var_Maps": [
            {
                "EscapeBytes": "var_0",
                "EscapeData": "var_1",
                "bytes": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] do nothing . [SEP]",
        "reference": "pass",
        "Output": "pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] derive the class var_0 from var_3 . var_2 and var_1 base classes . [SEP]",
        "reference": "class Escape Text ( six . text_type , Escape Data ) : pass",
        "Output": "class Escape Text ( six . text_type , Escape Data ) : pass",
        "Var_Maps": [
            {
                "EscapeText": "var_0",
                "EscapeData": "var_1",
                "text_type": "var_2",
                "six": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] do nothing . [SEP]",
        "reference": "pass",
        "Output": "pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] if var_0 . var_1 is true , [SEP]",
        "reference": "if six . PY3 : pass",
        "Output": "if six . PY3 : pass",
        "Var_Maps": [
            {
                "six": "var_0",
                "PY3": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "Escape String = Escape Text",
        "Output": "Escape String = Escape Text",
        "Var_Maps": [
            {
                "EscapeString": "var_0",
                "EscapeText": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "Escape String = Escape Bytes",
        "Output": "Escape String = Escape Bytes",
        "Var_Maps": [
            {
                "EscapeString": "var_0",
                "EscapeBytes": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "Escape Unicode = Escape Text",
        "Output": "Escape Unicode = Escape Text",
        "Var_Maps": [
            {
                "EscapeUnicode": "var_0",
                "EscapeText": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] derive the class var_0 from var_1 base class . [SEP]",
        "reference": "class Safe Data ( object ) : pass",
        "Output": "class Safe Data ( object ) : pass",
        "Var_Maps": [
            {
                "SafeData": "var_0",
                "object": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def __html__ ( self ) : pass",
        "Output": "def __html__ ( self ) : pass",
        "Var_Maps": [
            {
                "__html__": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return self",
        "Output": "return self",
        "Var_Maps": [
            {
                "self": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] derive the class var_0 from var_2 and var_1 base classes . [SEP]",
        "reference": "class Safe Bytes ( bytes , Safe Data ) : pass",
        "Output": "class Safe Bytes ( bytes , Safe Data ) : pass",
        "Var_Maps": [
            {
                "SafeBytes": "var_0",
                "SafeData": "var_1",
                "bytes": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments var_1 and var_2 . [SEP]",
        "reference": "def __add__ ( self , rhs ) : pass",
        "Output": "def __add__ ( self , rhs ) : pass",
        "Var_Maps": [
            {
                "__add__": "var_0",
                "self": "var_1",
                "rhs": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call var_5 he var_1 me var_5 ho ##d wi var_5 h an ar ##gum ##en var_5 s var_4 from var_5 he base class of var_5 he class var_0 , sub ##s var_5 i var_5 u var_5 e var_5 he res ##ul var_5 for var_5 . [SEP]",
        "reference": "t = super ( Safe Bytes , self ) . __add__ ( rhs )",
        "Output": "t = super ( Safe Bytes , self ) . rhs ( )",
        "Var_Maps": [
            {
                "SafeBytes": "var_0",
                "__add__": "var_1",
                "super": "var_2",
                "self": "var_3",
                "rhs": "var_4",
                "t": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 is an instance of var_1 , [SEP]",
        "reference": "if isinstance ( rhs , Safe Text ) : pass",
        "Output": "if isinstance ( rhs , Safe Text ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "SafeText": "var_1",
                "rhs": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] re var_1 ur ##n an ins var_1 an ##ce of var_0 , cr ##ea var_1 ed wi var_1 h an ar ##gum ##en var_1 var_1 . [SEP]",
        "reference": "return Safe Text ( t )",
        "Output": "return t ( Safe Text )",
        "Var_Maps": [
            {
                "SafeText": "var_0",
                "t": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] otherwise if var_2 is an instance of var_1 , [SEP]",
        "reference": "if True : pass elif isinstance ( rhs , Safe Bytes ) : pass",
        "Output": "if ` True ` : pass elif isinstance ( rhs , Safe Bytes ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "SafeBytes": "var_1",
                "rhs": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] re var_1 ur ##n an ins var_1 an ##ce of var_0 , cr ##ea var_1 ed wi var_1 h an ar ##gum ##en var_1 var_1 . [SEP]",
        "reference": "return Safe Bytes ( t )",
        "Output": "return t ( Safe Bytes )",
        "Var_Maps": [
            {
                "SafeBytes": "var_0",
                "t": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] re var_0 ur ##n var_0 . [SEP]",
        "reference": "return t",
        "Output": "return t",
        "Var_Maps": [
            {
                "t": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 3 arguments var_2 , un ##pack ##ed list var_3 and un ##pack ##ed dictionary var_1 . [SEP]",
        "reference": "def _proxy_method ( self , * args , * * kwargs ) : pass",
        "Output": "def _proxy_method ( self , * args , * * kwargs ) : pass",
        "Var_Maps": [
            {
                "_proxy_method": "var_0",
                "kwargs": "var_1",
                "self": "var_2",
                "args": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] remove var_1 dictionary element under the str_0 key , substitute it for var_0 . [SEP]",
        "reference": "method = kwargs . pop ( ` method ` )",
        "Output": "var_0 = kwargs . pop ( ` method ` )",
        "Var_Maps": [
            {
                "method": "var_2",
                "kwargs": "var_1",
                "pop": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with 3 arguments : var_3 , un ##pack ##ed list var_4 and un ##pack ##ed dictionary var_1 , substitute the result for var_2 . [SEP]",
        "reference": "data = method ( self , * args , * * kwargs )",
        "Output": "data = method ( self , * args , * * kwargs )",
        "Var_Maps": [
            {
                "method": "var_0",
                "kwargs": "var_1",
                "data": "var_2",
                "self": "var_3",
                "args": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 is an instance of var_1 , [SEP]",
        "reference": "if isinstance ( data , bytes ) : pass",
        "Output": "if isinstance ( data , bytes ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "bytes": "var_1",
                "data": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return an instance of var_0 , created with an argument var_1 . [SEP]",
        "reference": "return Safe Bytes ( data )",
        "Output": "return Safe Bytes ( data )",
        "Var_Maps": [
            {
                "SafeBytes": "var_0",
                "data": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] return an instance of var_0 , created with an argument var_1 . [SEP]",
        "reference": "return Safe Text ( data )",
        "Output": "return Safe Text ( data )",
        "Var_Maps": [
            {
                "SafeText": "var_0",
                "data": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_4 with 2 arguments : var_0 and var_2 set to var_5 . var_1 , substitute the result for var_1 . [SEP]",
        "reference": "decode = curry ( _proxy_method , method = bytes . decode )",
        "Output": "decode = curry ( _proxy_method , decode = bytes . decode )",
        "Var_Maps": [
            {
                "_proxy_method": "var_0",
                "decode": "var_3",
                "method": "var_2",
                "curry": "var_4",
                "bytes": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] derive the class var_1 from var_3 . var_0 and var_2 base classes . [SEP]",
        "reference": "class Safe Text ( six . text_type , Safe Data ) : pass",
        "Output": "class Safe Text ( six . text_type , Safe Data ) : pass",
        "Var_Maps": [
            {
                "text_type": "var_0",
                "SafeText": "var_1",
                "SafeData": "var_2",
                "six": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments var_1 and var_2 . [SEP]",
        "reference": "def __add__ ( self , rhs ) : pass",
        "Output": "def __add__ ( self , rhs ) : pass",
        "Var_Maps": [
            {
                "__add__": "var_0",
                "self": "var_1",
                "rhs": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call var_5 he var_1 me var_5 ho ##d wi var_5 h an ar ##gum ##en var_5 s var_4 from var_5 he base class of var_5 he class var_0 , sub ##s var_5 i var_5 u var_5 e var_5 he res ##ul var_5 for var_5 . [SEP]",
        "reference": "t = super ( Safe Text , self ) . __add__ ( rhs )",
        "Output": "t = super ( Safe Text , self ) . rhs ( )",
        "Var_Maps": [
            {
                "SafeText": "var_0",
                "__add__": "var_1",
                "super": "var_2",
                "self": "var_3",
                "rhs": "var_4",
                "t": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 is an instance of var_1 . [SEP]",
        "reference": "if isinstance ( rhs , Safe Data ) : pass",
        "Output": "if isinstance ( rhs , Safe Data ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "SafeData": "var_1",
                "rhs": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] re var_1 ur ##n an ins var_1 an ##ce of var_0 , cr ##ea var_1 ed wi var_1 h an ar ##gum ##en var_1 var_1 . [SEP]",
        "reference": "return Safe Text ( t )",
        "Output": "return t ( Safe Text )",
        "Var_Maps": [
            {
                "SafeText": "var_0",
                "t": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] re var_0 ur ##n var_0 . [SEP]",
        "reference": "return t",
        "Output": "return t",
        "Var_Maps": [
            {
                "t": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 3 arguments var_2 , un ##pack ##ed list var_3 and un ##pack ##ed dictionary var_1 . [SEP]",
        "reference": "def _proxy_method ( self , * args , * * kwargs ) : pass",
        "Output": "def _proxy_method ( self , * args , * * kwargs ) : pass",
        "Var_Maps": [
            {
                "_proxy_method": "var_0",
                "kwargs": "var_1",
                "self": "var_2",
                "args": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] remove var_1 dictionary element under the str_0 key , substitute it for var_0 . [SEP]",
        "reference": "method = kwargs . pop ( ` method ` )",
        "Output": "var_0 = kwargs . pop ( ` method ` )",
        "Var_Maps": [
            {
                "method": "var_2",
                "kwargs": "var_1",
                "pop": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with 3 arguments : var_3 , un ##pack ##ed list var_4 and un ##pack ##ed dictionary var_1 , substitute the result for var_2 . [SEP]",
        "reference": "data = method ( self , * args , * * kwargs )",
        "Output": "data = method ( self , * args , * * kwargs )",
        "Var_Maps": [
            {
                "method": "var_0",
                "kwargs": "var_1",
                "data": "var_2",
                "self": "var_3",
                "args": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 is an instance of var_1 . [SEP]",
        "reference": "if isinstance ( data , bytes ) : pass",
        "Output": "if isinstance ( data , bytes ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "bytes": "var_1",
                "data": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return an instance of var_0 , created with an argument var_1 . [SEP]",
        "reference": "return Safe Bytes ( data )",
        "Output": "return Safe Bytes ( data )",
        "Var_Maps": [
            {
                "SafeBytes": "var_0",
                "data": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] return an instance of var_0 , created with an argument var_1 . [SEP]",
        "reference": "return Safe Text ( data )",
        "Output": "return Safe Text ( data )",
        "Var_Maps": [
            {
                "SafeText": "var_0",
                "data": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_5 with 2 arguments : var_0 and var_3 set to var_6 . var_1 . var_2 , substitute the result for var_2 . [SEP]",
        "reference": "encode = curry ( _proxy_method , method = six . text_type . encode )",
        "Output": "encode = curry ( _proxy_method , method = six . text_type . encode )",
        "Var_Maps": [
            {
                "_proxy_method": "var_0",
                "text_type": "var_1",
                "encode": "var_4",
                "method": "var_3",
                "curry": "var_5",
                "six": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 . var_1 is true , [SEP]",
        "reference": "if six . PY3 : pass",
        "Output": "if six . PY3 : pass",
        "Var_Maps": [
            {
                "six": "var_0",
                "PY3": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "Safe String = Safe Text",
        "Output": "Safe String = Safe Text",
        "Var_Maps": [
            {
                "SafeString": "var_0",
                "SafeText": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "Safe String = Safe Bytes",
        "Output": "Safe String = Safe Bytes",
        "Var_Maps": [
            {
                "SafeString": "var_0",
                "SafeBytes": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "Safe Unicode = Safe Text",
        "Output": "Safe Unicode = Safe Text",
        "Var_Maps": [
            {
                "SafeUnicode": "var_0",
                "SafeText": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def mark_safe ( s ) : pass",
        "Output": "def mark_safe ( s ) : pass",
        "Var_Maps": [
            {
                "mark_safe": "var_0",
                "s": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 i var_2 an in var_2 tan ##ce of var_1 . [SEP]",
        "reference": "if isinstance ( s , Safe Data ) : pass",
        "Output": "if isinstance ( s , Safe Data ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "SafeData": "var_1",
                "s": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return s",
        "Output": "return s",
        "Var_Maps": [
            {
                "s": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_5 i var_5 an in var_5 tan ##ce of var_4 or var_3 and var_5 . var_0 i var_5 true , [SEP]",
        "reference": "if isinstance ( s , bytes ) or isinstance ( s , Promise ) and s . _delegate_bytes : pass",
        "Output": "if isinstance ( s , ( bytes , Promise ) ) and s . isinstance : pass",
        "Var_Maps": [
            {
                "_delegate_bytes": "var_0",
                "isinstance": "var_2",
                "Promise": "var_3",
                "bytes": "var_4",
                "s": "var_7"
            }
        ]
    },
    {
        "intent": "[CLS] return an in var_1 tan ##ce of var_0 , created with an argument var_1 . [SEP]",
        "reference": "return Safe Bytes ( s )",
        "Output": "return Safe Bytes ( s )",
        "Var_Maps": [
            {
                "SafeBytes": "var_0",
                "s": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_4 i var_4 an in var_4 tan ##ce of var_3 . var_1 or var_2 , [SEP]",
        "reference": "if isinstance ( s , ( six . text_type , Promise ) ) : pass",
        "Output": "if isinstance ( s , ( six . text_type , Promise ) ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "text_type": "var_1",
                "Promise": "var_2",
                "six": "var_3",
                "s": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] return an in var_1 tan ##ce of var_0 , created with an argument var_1 . [SEP]",
        "reference": "return Safe Text ( s )",
        "Output": "return Safe Text ( s )",
        "Var_Maps": [
            {
                "SafeText": "var_0",
                "s": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return an in var_2 tan ##ce of safe ##text , created with an argument var_2 converted into a var_1 ing . [SEP]",
        "reference": "return Safe String ( str ( s ) )",
        "Output": "return str ( s )",
        "Var_Maps": [
            {
                "SafeString": "var_0",
                "str": "var_1",
                "s": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def mark_for_escaping ( s ) : pass",
        "Output": "def mark_for_escaping ( s ) : pass",
        "Var_Maps": [
            {
                "mark_for_escaping": "var_0",
                "s": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_3 i var_3 an in var_3 tan ##ce of var_2 or var_1 , [SEP]",
        "reference": "if isinstance ( s , ( Safe Data , Escape Data ) ) : pass",
        "Output": "if isinstance ( s , ( Safe Data , Escape Data ) ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "EscapeData": "var_1",
                "SafeData": "var_2",
                "s": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return s",
        "Output": "return s",
        "Var_Maps": [
            {
                "s": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_5 i var_5 an in var_5 tan ##ce of var_4 or var_3 and var_5 . var_0 i var_5 true , [SEP]",
        "reference": "if isinstance ( s , bytes ) or isinstance ( s , Promise ) and s . _delegate_bytes : pass",
        "Output": "if isinstance ( s , ( bytes , Promise ) ) and s . isinstance : pass",
        "Var_Maps": [
            {
                "_delegate_bytes": "var_0",
                "isinstance": "var_2",
                "Promise": "var_3",
                "bytes": "var_4",
                "s": "var_7"
            }
        ]
    },
    {
        "intent": "[CLS] return an in var_1 tan ##ce of var_0 , created with an argument var_1 . [SEP]",
        "reference": "return Escape Bytes ( s )",
        "Output": "return Escape Bytes ( s )",
        "Var_Maps": [
            {
                "EscapeBytes": "var_0",
                "s": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_4 i var_4 an in var_4 tan ##ce of var_3 . var_1 or var_2 , [SEP]",
        "reference": "if isinstance ( s , ( six . text_type , Promise ) ) : pass",
        "Output": "if isinstance ( s , ( six . text_type , Promise ) ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "text_type": "var_1",
                "Promise": "var_2",
                "six": "var_3",
                "s": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] return an in var_1 tan ##ce of var_0 , created with an argument var_1 . [SEP]",
        "reference": "return Escape Text ( s )",
        "Output": "return Escape Text ( s )",
        "Var_Maps": [
            {
                "EscapeText": "var_0",
                "s": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return an in var_2 tan ##ce of var_0 , created with an argument , re ##u var_2 lt of the call to the function var_1 with an argument var_2 . [SEP]",
        "reference": "return Escape Bytes ( bytes ( s ) )",
        "Output": "return Escape Bytes ( bytes ( s ) )",
        "Var_Maps": [
            {
                "EscapeBytes": "var_0",
                "bytes": "var_1",
                "s": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] import module opera . [SEP]",
        "reference": "import operator",
        "Output": "import operator",
        "Var_Maps": [
            {
                "operator": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_0 . [SEP]",
        "reference": "import sys",
        "Output": "import sys",
        "Var_Maps": [
            {
                "sys": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_0 . [SEP]",
        "reference": "import types",
        "Output": "import types",
        "Var_Maps": [
            {
                "types": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 is a string str_0 . [SEP]",
        "reference": "__author__ = ` Benjamin Peterson < benjamin @ python . org > `",
        "Output": "__author__ = ` Benjamin Peterson < benjamin @ python . org > `",
        "Var_Maps": [
            {
                "Benjamin Peterson <benjamin@python.org>": "var_0",
                "__author__": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "__version__ = ` 1 . 6 . 1 `",
        "Output": "__version__ = ` 1 . 6 . 1 `",
        "Var_Maps": [
            {
                "1.6.1": "var_1",
                "__version__": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if first element of var_2 . var_0 equals integer 2 , var_1 is boo ##lean true , otherwise it is boo ##lean false . [SEP]",
        "reference": "PY2 = sys . version_info [ 0 ] = = 2",
        "Output": "PY2 = sys . version_info [ 2 ] = = 2",
        "Var_Maps": [
            {
                "version_info": "var_0",
                "PY2": "var_1",
                "sys": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if first element of var_2 . var_0 equals integer 3 , var_1 is boo ##lean true , otherwise it is boo ##lean false . [SEP]",
        "reference": "PY3 = sys . version_info [ 0 ] = = 3",
        "Output": "PY3 = sys . version_info [ 3 ] = = 3",
        "Var_Maps": [
            {
                "version_info": "var_0",
                "PY3": "var_1",
                "sys": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if PY3 : pass",
        "Output": "if PY3 : pass",
        "Var_Maps": [
            {
                "PY3": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "string_types = str",
        "Output": "string_types = str",
        "Var_Maps": [
            {
                "string_types": "var_0",
                "str": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "integer_types = int",
        "Output": "integer_types = int",
        "Var_Maps": [
            {
                "integer_types": "var_0",
                "int": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "class_types = type",
        "Output": "class_types = type",
        "Var_Maps": [
            {
                "class_types": "var_0",
                "type": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "text_type = str",
        "Output": "text_type = str",
        "Var_Maps": [
            {
                "text_type": "var_0",
                "str": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "binary_type = bytes",
        "Output": "binary_type = bytes",
        "Var_Maps": [
            {
                "binary_type": "var_0",
                "bytes": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_2 . var_1 for var_0 . [SEP]",
        "reference": "MAXSIZE = sys . maxsize",
        "Output": "MAXSIZE = sys . maxsize",
        "Var_Maps": [
            {
                "MAXSIZE": "var_0",
                "maxsize": "var_1",
                "sys": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "string_types = basestring",
        "Output": "string_types = basestring",
        "Var_Maps": [
            {
                "string_types": "var_0",
                "basestring": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a tu ##ple with 2 elements var_2 and var_1 . [SEP]",
        "reference": "integer_types = int , long",
        "Output": "integer_types = int , long",
        "Var_Maps": [
            {
                "integer_types": "var_0",
                "long": "var_1",
                "int": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a tu ##ple with 2 elements : var_3 and var_2 . var_1 . [SEP]",
        "reference": "class_types = type , types . Class Type",
        "Output": "class_types = type , types . Class Type",
        "Var_Maps": [
            {
                "class_types": "var_0",
                "ClassType": "var_1",
                "types": "var_2",
                "type": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "text_type = unicode",
        "Output": "text_type = unicode",
        "Var_Maps": [
            {
                "text_type": "var_0",
                "unicode": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "binary_type = str",
        "Output": "binary_type = str",
        "Var_Maps": [
            {
                "binary_type": "var_0",
                "str": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_3 . var_1 starts with string str_0 , [SEP]",
        "reference": "if sys . platform . startswith ( ` java ` ) : pass",
        "Output": "if sys . platform . startswith ( ` java ` ) : pass",
        "Var_Maps": [
            {
                "java": "var_2",
                "startswith": "var_0",
                "platform": "var_1",
                "sys": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] bit ##wise shift var_1 e ##ger 1 to the left by 31 spaces , substitute var_1 e ##ger 1 from the result , convert the result to a var_1 e ##ger , substitute it for var_0 . [SEP]",
        "reference": "MAXSIZE = int ( ( 1 < < 31 ) - 1 )",
        "Output": "MAXSIZE = int ( )",
        "Var_Maps": [
            {
                "MAXSIZE": "var_0",
                "int": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] derive class var_1 from the var_0 base class . [SEP]",
        "reference": "class X ( object ) : pass",
        "Output": "class X ( object ) : pass",
        "Var_Maps": [
            {
                "object": "var_0",
                "X": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def __len__ ( self ) : pass",
        "Output": "def __len__ ( self ) : pass",
        "Var_Maps": [
            {
                "__len__": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] bit ##wise shift integer 1 to the left by 31 spaces , return the result . [SEP]",
        "reference": "return 1 < < 31",
        "Output": "",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] try [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] instant ##iate class var_1 , get its var_0 gt ##h . [SEP]",
        "reference": "len ( X ( ) )",
        "Output": "len ( X ( ) )",
        "Var_Maps": [
            {
                "len": "var_0",
                "X": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Overflow Error : pass",
        "Output": "try : pass except Overflow Error : pass",
        "Var_Maps": [
            {
                "OverflowError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] bit ##wise shift var_1 e ##ger 1 to the left by 31 spaces , substitute var_1 e ##ger 1 from the result , convert the result to a var_1 e ##ger , substitute it for var_0 . [SEP]",
        "reference": "MAXSIZE = int ( ( 1 < < 31 ) - 1 )",
        "Output": "MAXSIZE = int ( )",
        "Var_Maps": [
            {
                "MAXSIZE": "var_0",
                "int": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] bit ##wise shift var_1 e ##ger 1 to the left by 63 spaces , substitute var_1 e ##ger 1 from the result , convert the result to a var_1 e ##ger , substitute it for var_0 . [SEP]",
        "reference": "MAXSIZE = int ( ( 1 < < 63 ) - 1 )",
        "Output": "MAXSIZE = int ( )",
        "Var_Maps": [
            {
                "MAXSIZE": "var_0",
                "int": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] del ##ete var_0 . [SEP]",
        "reference": "del X",
        "Output": "del X",
        "Var_Maps": [
            {
                "X": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the var_1 ti ##on var_0 with 2 arguments : var_1 and var_2 . [SEP]",
        "reference": "def _add_doc ( func , doc ) : pass",
        "Output": "def _add_doc ( func , doc ) : pass",
        "Var_Maps": [
            {
                "_add_doc": "var_0",
                "func": "var_1",
                "doc": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_2 for var_1 . var_0 . [SEP]",
        "reference": "func . __doc__ = doc",
        "Output": "func . __doc__ = doc",
        "Var_Maps": [
            {
                "__doc__": "var_0",
                "func": "var_1",
                "doc": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def _import_module ( name ) : pass",
        "Output": "def _import_module ( name ) : pass",
        "Var_Maps": [
            {
                "_import_module": "var_0",
                "name": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_1 . [SEP]",
        "reference": "__import__ ( name )",
        "Output": "__import__ ( name )",
        "Var_Maps": [
            {
                "__import__": "var_0",
                "name": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return value under the var_1 key of the var_2 . var_0 dictionary . [SEP]",
        "reference": "return sys . modules [ name ]",
        "Output": "return sys . modules [ name ]",
        "Var_Maps": [
            {
                "modules": "var_0",
                "name": "var_1",
                "sys": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] derive class var_0 from the var_1 base class . [SEP]",
        "reference": "class _Lazy Descr ( object ) : pass",
        "Output": "class _Lazy Descr ( object ) : pass",
        "Var_Maps": [
            {
                "_LazyDescr": "var_0",
                "object": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments : var_1 and var_2 . [SEP]",
        "reference": "def __init__ ( self , name ) : pass",
        "Output": "def __init__ ( self , name ) : pass",
        "Var_Maps": [
            {
                "__init__": "var_0",
                "self": "var_1",
                "name": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . var_1 . [SEP]",
        "reference": "self . name = name",
        "Output": "self . name = name",
        "Var_Maps": [
            {
                "self": "var_0",
                "name": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 3 arguments : var_1 , var_2 and var_3 . [SEP]",
        "reference": "def __get__ ( self , obj , tp ) : pass",
        "Output": "def __get__ ( self , obj , tp ) : pass",
        "Var_Maps": [
            {
                "__get__": "var_0",
                "self": "var_1",
                "obj": "var_2",
                "tp": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 , substitute the var_1 for var_1 . [SEP]",
        "reference": "result = self . _resolve ( )",
        "Output": "result = self . _resolve ( )",
        "Var_Maps": [
            {
                "_resolve": "var_0",
                "result": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Import Error : pass",
        "Output": "try : pass except Import Error : pass",
        "Var_Maps": [
            {
                "ImportError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] raise an var_1 with an argument string str_0 , format ##ed with var_2 . var_3 . [SEP]",
        "reference": "raise Attribute Error ( ` % s could not be imported ` % self . name )",
        "Output": "raise Attribute Error ( ` % s could not be imported ` % self . name )",
        "Var_Maps": [
            {
                "%s could not be imported ": "var_0",
                "AttributeError": "var_1",
                "self": "var_2",
                "name": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] set var_2 . var_3 attribute of the var_4 var_4 ec ##t to var_1 . [SEP]",
        "reference": "setattr ( obj , self . name , result )",
        "Output": "setattr ( obj , self . name , result )",
        "Var_Maps": [
            {
                "setattr": "var_0",
                "result": "var_1",
                "self": "var_2",
                "name": "var_3",
                "obj": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] del ##ete var_2 . var_3 attribute from the var_4 . var_0 var_4 ec ##t . [SEP]",
        "reference": "delattr ( obj . __class__ , self . name )",
        "Output": "delattr ( obj . __class__ , self . name )",
        "Var_Maps": [
            {
                "__class__": "var_0",
                "delattr": "var_1",
                "self": "var_2",
                "name": "var_3",
                "obj": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return result",
        "Output": "return result",
        "Var_Maps": [
            {
                "result": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] derive class var_0 from the var_1 base class . [SEP]",
        "reference": "class Moved Module ( _Lazy Descr ) : pass",
        "Output": "class Moved Module ( _Lazy Descr ) : pass",
        "Var_Maps": [
            {
                "MovedModule": "var_0",
                "_LazyDescr": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 4 arguments : var_1 , var_2 , var_3 and var_4 set to none . [SEP]",
        "reference": "def __init__ ( self , name , old , new = None ) : pass",
        "Output": "def __init__ ( self , name , old , new = None ) : pass",
        "Var_Maps": [
            {
                "__init__": "var_0",
                "self": "var_1",
                "name": "var_2",
                "old": "var_3",
                "new": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] call the var_1 method with an argument var_4 from the base class of the var_0 class . [SEP]",
        "reference": "super ( Moved Module , self ) . __init__ ( name )",
        "Output": "super ( Moved Module , self ) . __init__ ( name )",
        "Var_Maps": [
            {
                "MovedModule": "var_0",
                "__init__": "var_1",
                "super": "var_2",
                "self": "var_3",
                "name": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if PY3 : pass",
        "Output": "if PY3 : pass",
        "Var_Maps": [
            {
                "PY3": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if new is None : pass",
        "Output": "if new is None : pass",
        "Var_Maps": [
            {
                "new": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_1 . [SEP]",
        "reference": "new = name",
        "Output": "new = name",
        "Var_Maps": [
            {
                "name": "var_0",
                "new": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_2 for var_0 . var_1 . [SEP]",
        "reference": "self . mod = new",
        "Output": "self . mod = new",
        "Var_Maps": [
            {
                "self": "var_0",
                "mod": "var_1",
                "new": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] substitute var_2 for var_0 . var_1 . [SEP]",
        "reference": "self . mod = old",
        "Output": "self . mod = old",
        "Var_Maps": [
            {
                "self": "var_0",
                "mod": "var_1",
                "old": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def _resolve ( self ) : pass",
        "Output": "def _resolve ( self ) : pass",
        "Var_Maps": [
            {
                "_resolve": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_1 . var_2 , return the result . [SEP]",
        "reference": "return _import_module ( self . mod )",
        "Output": "return _import_module ( self . mod )",
        "Var_Maps": [
            {
                "_import_module": "var_0",
                "self": "var_1",
                "mod": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments : var_1 and var_2 set to none . [SEP]",
        "reference": "def __getattr__ ( self , attr ) : pass",
        "Output": "def __getattr__ ( self , attr = None ) : pass",
        "Var_Maps": [
            {
                "__getattr__": "var_0",
                "self": "var_1",
                "attr": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_4 equals any of the strings str_0 , str_1 or str_2 and var_5 . var_6 is not contained in var _ 7 . var_3 , [SEP]",
        "reference": "if attr in ( ` __file__ ` , ` __name__ ` , ` __path__ ` ) and self . mod not in sys . modules : pass",
        "Output": "if attr = = ( ` __path__ ` , ` __file__ ` , ` modules ` ) : pass",
        "Var_Maps": [
            {
                "__file__": "var_0",
                "__name__": "var_1",
                "__path__": "var_2",
                "modules": "var_3",
                "attr": "var_4",
                "self": "var_5",
                "mod": "var_6",
                "sys": "var_7"
            }
        ]
    },
    {
        "intent": "[CLS] raise an var_0 with an argument var_1 . [SEP]",
        "reference": "raise Attribute Error ( attr )",
        "Output": "raise Attribute Error ( attr )",
        "Var_Maps": [
            {
                "AttributeError": "var_0",
                "attr": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 , substitute the result for var_1 . [SEP]",
        "reference": "_module = self . _resolve ( )",
        "Output": "_module = self . _resolve ( )",
        "Var_Maps": [
            {
                "_resolve": "var_0",
                "_module": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Import Error : pass",
        "Output": "try : pass except Import Error : pass",
        "Var_Maps": [
            {
                "ImportError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] raise an var_0 with an argument var_1 . [SEP]",
        "reference": "raise Attribute Error ( attr )",
        "Output": "raise Attribute Error ( attr )",
        "Var_Maps": [
            {
                "AttributeError": "var_0",
                "attr": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] get var_3 var_3 ib ##ute from the var_1 object , substitute it for var_2 . [SEP]",
        "reference": "value = getattr ( _module , attr )",
        "Output": "value = getattr ( _module , attr )",
        "Var_Maps": [
            {
                "getattr": "var_0",
                "_module": "var_1",
                "value": "var_2",
                "attr": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] set var_3 var_3 ib ##ute of the var_2 object to var_1 . [SEP]",
        "reference": "setattr ( self , attr , value )",
        "Output": "setattr ( self , attr , value )",
        "Var_Maps": [
            {
                "setattr": "var_0",
                "value": "var_1",
                "self": "var_2",
                "attr": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return value",
        "Output": "return value",
        "Var_Maps": [
            {
                "value": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] derive class var_0 from the var_2 . var_1 base class . [SEP]",
        "reference": "class _Lazy Module ( types . Module Type ) : pass",
        "Output": "class _Lazy Module ( types . Module Type ) : pass",
        "Var_Maps": [
            {
                "_LazyModule": "var_0",
                "ModuleType": "var_1",
                "types": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments : var_1 and var_2 . [SEP]",
        "reference": "def __init__ ( self , name ) : pass",
        "Output": "def __init__ ( self , name ) : pass",
        "Var_Maps": [
            {
                "__init__": "var_0",
                "self": "var_1",
                "name": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 with an argument var_4 form the base class of the class var_0 . [SEP]",
        "reference": "super ( _Lazy Module , self ) . __init__ ( name )",
        "Output": "super ( _Lazy Module , self ) . __init__ ( name )",
        "Var_Maps": [
            {
                "_LazyModule": "var_0",
                "__init__": "var_1",
                "super": "var_2",
                "self": "var_3",
                "name": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_3 . var_0 . var_1 for var_3 . var_1 . [SEP]",
        "reference": "self . __doc__ = self . __class__ . __doc__",
        "Output": "self . __doc__ = self . __class__ . __doc__",
        "Var_Maps": [
            {
                "__class__": "var_0",
                "__doc__": "var_2",
                "self": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def __dir__ ( self ) : pass",
        "Output": "def __dir__ ( self ) : pass",
        "Var_Maps": [
            {
                "__dir__": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 is a list with 2 elements : strings str_0 and str_1 . [SEP]",
        "reference": "attrs = [ ` __doc__ ` , ` __name__ ` ]",
        "Output": "attrs = [ ` __name__ ` , ` __doc__ ` ]",
        "Var_Maps": [
            {
                "__doc__": "var_1",
                "__name__": "var_0",
                "attrs": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] app ##end var_2 . var_3 to var_1 for every var_2 in var_5 . var_0 . [SEP]",
        "reference": "attrs + = [ attr . name for attr in self . _moved_attributes ]",
        "Output": "attrs + = self . _moved_attributes",
        "Var_Maps": [
            {
                "_moved_attributes": "var_0",
                "attrs": "var_1",
                "attr": "var_4",
                "name": "var_3",
                "self": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return attrs",
        "Output": "return attrs",
        "Var_Maps": [
            {
                "attrs": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an empty list . [SEP]",
        "reference": "_moved_attributes = [ ]",
        "Output": "_moved_attributes = [ ]",
        "Var_Maps": [
            {
                "_moved_attributes": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] derive class var_0 from the var_1 base class . [SEP]",
        "reference": "class Moved Attribute ( _Lazy Descr ) : pass",
        "Output": "class Moved Attribute ( _Lazy Descr ) : pass",
        "Var_Maps": [
            {
                "MovedAttribute": "var_0",
                "_LazyDescr": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 6 arguments : var_5 , var_6 , var_3 , var_4 , var_1 set to none , var_2 set to none . [SEP]",
        "reference": "def __init__ ( self , name , old_mod , new_mod , old_attr = None , new_attr = None ) : pass",
        "Output": "def __init__ ( self , name , old_mod , new_mod , old_attr = None , new_attr = None ) : pass",
        "Var_Maps": [
            {
                "__init__": "var_0",
                "old_attr": "var_1",
                "new_attr": "var_2",
                "old_mod": "var_3",
                "new_mod": "var_4",
                "self": "var_5",
                "name": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 with an argument var_4 form the base class of the class var_0 . [SEP]",
        "reference": "super ( Moved Attribute , self ) . __init__ ( name )",
        "Output": "super ( Moved Attribute , self ) . __init__ ( name )",
        "Var_Maps": [
            {
                "MovedAttribute": "var_0",
                "__init__": "var_1",
                "super": "var_2",
                "self": "var_3",
                "name": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if PY3 : pass",
        "Output": "if PY3 : pass",
        "Var_Maps": [
            {
                "PY3": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if new_mod is None : pass",
        "Output": "if new_mod is None : pass",
        "Var_Maps": [
            {
                "new_mod": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "new_mod = name",
        "Output": "new_mod = name",
        "Var_Maps": [
            {
                "new_mod": "var_0",
                "name": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_1 . var_2 . [SEP]",
        "reference": "self . mod = new_mod",
        "Output": "self . mod = new_mod",
        "Var_Maps": [
            {
                "new_mod": "var_0",
                "self": "var_1",
                "mod": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if new_attr is None : pass",
        "Output": "if new_attr is None : pass",
        "Var_Maps": [
            {
                "new_attr": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if old_attr is None : pass",
        "Output": "if old_attr is None : pass",
        "Var_Maps": [
            {
                "old_attr": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "new_attr = name",
        "Output": "new_attr = name",
        "Var_Maps": [
            {
                "new_attr": "var_0",
                "name": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "new_attr = old_attr",
        "Output": "new_attr = old_attr",
        "Var_Maps": [
            {
                "new_attr": "var_0",
                "old_attr": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_1 . var_2 . [SEP]",
        "reference": "self . attr = new_attr",
        "Output": "self . attr = new_attr",
        "Var_Maps": [
            {
                "new_attr": "var_0",
                "self": "var_1",
                "attr": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_1 . var_2 . [SEP]",
        "reference": "self . mod = old_mod",
        "Output": "self . mod = old_mod",
        "Var_Maps": [
            {
                "old_mod": "var_0",
                "self": "var_1",
                "mod": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if old_attr is None : pass",
        "Output": "if old_attr is None : pass",
        "Var_Maps": [
            {
                "old_attr": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "old_attr = name",
        "Output": "old_attr = name",
        "Var_Maps": [
            {
                "old_attr": "var_0",
                "name": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_1 . var_2 . [SEP]",
        "reference": "self . attr = old_attr",
        "Output": "self . attr = old_attr",
        "Var_Maps": [
            {
                "old_attr": "var_0",
                "self": "var_1",
                "attr": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def _resolve ( self ) : pass",
        "Output": "def _resolve ( self ) : pass",
        "Var_Maps": [
            {
                "_resolve": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_2 . var_3 , substitute the result for var_1 . [SEP]",
        "reference": "module = _import_module ( self . mod )",
        "Output": "module = _import_module ( self . mod )",
        "Var_Maps": [
            {
                "_import_module": "var_0",
                "module": "var_1",
                "self": "var_2",
                "mod": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] get ##t var_2 . var_3 from the var_1 object , return it . [SEP]",
        "reference": "return getattr ( module , self . attr )",
        "Output": "return getattr ( module , self . attr )",
        "Var_Maps": [
            {
                "getattr": "var_0",
                "module": "var_1",
                "self": "var_2",
                "attr": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] derive class var_0 from the var_1 base class . [SEP]",
        "reference": "class _Moved Items ( _Lazy Module ) : pass",
        "Output": "class _Moved Items ( _Lazy Module ) : pass",
        "Var_Maps": [
            {
                "_MovedItems": "var_0",
                "_LazyModule": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] with different 3 string arguments , the others are results of the call to the function moved ##mo ##du ##le called with 3 string arguments . for every var_1 in var_0 , [SEP]",
        "reference": "for attr in _moved_attributes : pass",
        "Output": "for attr in _moved_attributes : pass",
        "Var_Maps": [
            {
                "_moved_attributes": "var_0",
                "attr": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] set var_2 . var_3 var_2 ib ##ute of the var_0 t object to var_2 . [SEP]",
        "reference": "setattr ( _Moved Items , attr . name , attr )",
        "Output": "setattr ( _Moved Items , attr . name , attr )",
        "Var_Maps": [
            {
                "_MovedItems": "var_0",
                "setattr": "var_1",
                "attr": "var_4",
                "name": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 is an instance of var_0 . [SEP]",
        "reference": "if isinstance ( attr , Moved Module ) : pass",
        "Output": "if isinstance ( attr , Moved Module ) : pass",
        "Var_Maps": [
            {
                "MovedModule": "var_0",
                "isinstance": "var_1",
                "attr": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] con ##cate ##nate var_0 , string str_0 and var_3 . var_4 together , use it as an key to get the value from the var_6 . var_1 dictionary , [SEP]",
        "reference": "sys . modules [ __name__ + ` . moves . ` + attr . name ] = attr",
        "Output": "sys . modules [ ` attr ` ] = sys . modules [ __name__ + ` . moves . ` ]",
        "Var_Maps": [
            {
                ".moves": "str_0",
                "__name__": "var_0",
                "modules": "var_1",
                ".moves.": "var_2",
                "attr": "var_5",
                "name": "var_4",
                "sys": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for the obtained value . del ##ete var_0 . [SEP]",
        "reference": "del attr",
        "Output": "del var_1",
        "Var_Maps": [
            {
                "attr": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_2 . var_0 . [SEP]",
        "reference": "_Moved Items . _moved_attributes = _moved_attributes",
        "Output": "_Moved Items . _moved_attributes = _moved_attributes",
        "Var_Maps": [
            {
                "_moved_attributes": "var_1",
                "_MovedItems": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] app ##end string str_0 to var_1 , use it as an argument to instant ##iate var_0 class , assign it to var_6 , [SEP]",
        "reference": "moves = sys . modules [ __name__ + ` . moves ` ] = _Moved Items ( __name__ + ` . moves ` )",
        "Output": "moves = _Moved Items ( ` __name__ ` + var_1 )",
        "Var_Maps": [
            {
                ".moves": "var_5",
                "_MovedItems": "var_0",
                "__name__": "var_2",
                "modules": "var_3",
                "moves": "var_6",
                "sys": "var_7"
            }
        ]
    },
    {
        "intent": "[CLS] and to value under the str_0 app ##ended to _ _ name _ _ key of the sy ##s . modules dictionary . derive class var_0 from the var_1 base class . [SEP]",
        "reference": "class Module_six_moves_urllib_parse ( _Lazy Module ) : pass",
        "Output": "class Module_six_moves_urllib_parse ( _Lazy Module ) : pass",
        "Var_Maps": [
            {
                ".moves": "str_0",
                "Module_six_moves_urllib_parse": "var_0",
                "_LazyModule": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_1 in var_0 , [SEP]",
        "reference": "for attr in _urllib_parse_moved_attributes : pass",
        "Output": "for attr in _urllib_parse_moved_attributes : pass",
        "Var_Maps": [
            {
                "_urllib_parse_moved_attributes": "var_0",
                "attr": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] set var_2 . var_3 var_2 ib ##ute of the var_0 object to var_2 . [SEP]",
        "reference": "setattr ( Module_six_moves_urllib_parse , attr . name , attr )",
        "Output": "setattr ( Module_six_moves_urllib_parse , attr . name , attr )",
        "Var_Maps": [
            {
                "Module_six_moves_urllib_parse": "var_0",
                "setattr": "var_1",
                "attr": "var_4",
                "name": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] del ##ete var_0 . [SEP]",
        "reference": "del attr",
        "Output": "del attr",
        "Var_Maps": [
            {
                "attr": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_1 . var_2 . [SEP]",
        "reference": "Module_six_moves_urllib_parse . _moved_attributes = ( _urllib_parse_moved_attributes )",
        "Output": "Module_six_moves_urllib_parse . _moved_attributes = _urllib_parse_moved_attributes",
        "Var_Maps": [
            {
                "_urllib_parse_moved_attributes": "var_0",
                "Module_six_moves_urllib_parse": "var_1",
                "_moved_attributes": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method module _ six _ moves _ ur ##lli ##b _ request with an argument : string str_0 app ##ended to var_4 , [SEP]",
        "reference": "sys . modules [ __name__ + ` . moves . urllib_parse ` ] = sys . modules [ __name__ + ` . moves . urllib . parse ` ] = Module_six_moves_urllib_parse ( __name__ + ` . moves . urllib_parse ` )",
        "Output": "__name__ . var_1 ( ` Module_six_moves_urllib_parse ` % . moves . urllib_parse ( var_5 ) )",
        "Var_Maps": [
            {
                ".moves.urllib_parse": "var_3",
                "Module_six_moves_urllib_parse": "var_0",
                ".moves.urllib.parse": "var_2",
                "__name__": "var_6",
                "modules": "var_8",
                "sys": "var_10"
            }
        ]
    },
    {
        "intent": "[CLS] assign the result to the value under the string str_0 app ##ended to _ _ name _ _ key of the sy ##s . modules dictionary , and to the value under the string str_1 app ##ended to _ _ name _ _ key of the sy ##s . modules dictionary . derive class var_0 from the var_1 base class . [SEP]",
        "reference": "class Module_six_moves_urllib_error ( _Lazy Module ) : pass",
        "Output": "class Module_six_moves_urllib_error ( _Lazy Module ) : pass",
        "Var_Maps": [
            {
                ".moves.urllib_parse": "str_0",
                ".moves.urllib.parse": "str_1",
                "Module_six_moves_urllib_error": "var_0",
                "_LazyModule": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a list with 3 elements : result of the call to the function var_2 with 3 arguments : [SEP]",
        "reference": "_urllib_error_moved_attributes = [ Moved Attribute ( ` URLError ` , ` urllib2 ` , ` urllib . error ` ) , Moved Attribute ( ` HTTPError ` , ` urllib2 ` , ` urllib . error ` ) , Moved Attribute ( ` Content Too Short Error ` , ` urllib ` , ` urllib . error ` ) ]",
        "Output": "_urllib_error_moved_attributes = [ var_2 ( Content Too Short Error , var_3 = ` Moved Attribute ` ) ]",
        "Var_Maps": [
            {
                "_urllib_error_moved_attributes": "var_0",
                "ContentTooShortError": "var_1",
                "MovedAttribute": "var_4",
                "urllib.error": "var_7",
                "HTTPError": "var_8",
                "URLError": "var_9",
                "urllib2": "var_11",
                "urllib": "var_12"
            }
        ]
    },
    {
        "intent": "[CLS] strings str_0 , str_1 , str_2 , result of the call to the function moved ##att ##ri ##bu ##te with 3 arguments : strings str_3 , str_1 , str_2 and result of the call to the function moved ##att ##ri ##bu ##te with 3 arguments : strings str_4 , str_5 , str_2 . for every var_1 in var_0 , [SEP]",
        "reference": "for attr in _urllib_error_moved_attributes : pass",
        "Output": "for attr in _urllib_error_moved_attributes : pass",
        "Var_Maps": [
            {
                "URLError": "str_0",
                "urllib2": "str_1",
                "urllib.error": "str_2",
                "HTTPError": "str_3",
                "ContentTooShortError": "str_4",
                "urllib": "str_5",
                "_urllib_error_moved_attributes": "var_0",
                "attr": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] set var_2 . var_3 var_2 ib ##ute of the var_0 object to var_2 . [SEP]",
        "reference": "setattr ( Module_six_moves_urllib_error , attr . name , attr )",
        "Output": "setattr ( Module_six_moves_urllib_error , attr . name , attr )",
        "Var_Maps": [
            {
                "Module_six_moves_urllib_error": "var_0",
                "setattr": "var_1",
                "attr": "var_4",
                "name": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] del ##ete var_0 . [SEP]",
        "reference": "del attr",
        "Output": "del attr",
        "Var_Maps": [
            {
                "attr": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_1 . var_2 . [SEP]",
        "reference": "Module_six_moves_urllib_error . _moved_attributes = ( _urllib_error_moved_attributes )",
        "Output": "Module_six_moves_urllib_error . _moved_attributes = _urllib_error_moved_attributes",
        "Var_Maps": [
            {
                "_urllib_error_moved_attributes": "var_0",
                "Module_six_moves_urllib_error": "var_1",
                "_moved_attributes": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method module _ six _ moves _ ur ##lli ##b _ request with an argument : string str_0 app ##ended to var_4 , [SEP]",
        "reference": "sys . modules [ __name__ + ` . moves . urllib_error ` ] = sys . modules [ __name__ + ` . moves . urllib . error ` ] = Module_six_moves_urllib_error ( __name__ + ` . moves . urllib . error ` )",
        "Output": "__name__ . . moves . urllib_error ( ` Module_six_moves_urllib_error ` % . moves . urllib . error ( var_5 ) )",
        "Var_Maps": [
            {
                ".moves.urllib.error": "var_3",
                "Module_six_moves_urllib_error": "var_0",
                ".moves.urllib_error": "var_1",
                "__name__": "var_6",
                "modules": "var_8",
                "sys": "var_10"
            }
        ]
    },
    {
        "intent": "[CLS] assign the result to the value under the string str_0 app ##ended to _ _ name _ _ key of the sy ##s . modules dictionary , and to the value under the string str_1 app ##ended to _ _ name _ _ key of the sy ##s . modules dictionary . derive class var_0 from the var_1 base class . [SEP]",
        "reference": "class Module_six_moves_urllib_request ( _Lazy Module ) : pass",
        "Output": "class Module_six_moves_urllib_request ( _Lazy Module ) : pass",
        "Var_Maps": [
            {
                ".moves.urllib_error": "str_0",
                ".moves.urllib.error": "str_1",
                "Module_six_moves_urllib_request": "var_0",
                "_LazyModule": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_1 in var_0 , [SEP]",
        "reference": "for attr in _urllib_request_moved_attributes : pass",
        "Output": "for attr in _urllib_request_moved_attributes : pass",
        "Var_Maps": [
            {
                "_urllib_request_moved_attributes": "var_0",
                "attr": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] set var_2 . var_3 var_2 ib ##ute of the var_0 object to var_2 . [SEP]",
        "reference": "setattr ( Module_six_moves_urllib_request , attr . name , attr )",
        "Output": "setattr ( Module_six_moves_urllib_request , attr . name , attr )",
        "Var_Maps": [
            {
                "Module_six_moves_urllib_request": "var_0",
                "setattr": "var_1",
                "attr": "var_4",
                "name": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] del ##ete var_0 . [SEP]",
        "reference": "del attr",
        "Output": "del attr",
        "Var_Maps": [
            {
                "attr": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_1 . var_2 . [SEP]",
        "reference": "Module_six_moves_urllib_request . _moved_attributes = ( _urllib_request_moved_attributes )",
        "Output": "Module_six_moves_urllib_request . _moved_attributes = _urllib_request_moved_attributes",
        "Var_Maps": [
            {
                "_urllib_request_moved_attributes": "var_0",
                "Module_six_moves_urllib_request": "var_1",
                "_moved_attributes": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 with an argument : string str_0 app ##ended to var_4 , [SEP]",
        "reference": "sys . modules [ __name__ + ` . moves . urllib_request ` ] = sys . modules [ __name__ + ` . moves . urllib . request ` ] = Module_six_moves_urllib_request ( __name__ + ` . moves . urllib . request ` )",
        "Output": ". moves . urllib . request = Module_six_moves_urllib_request ( var_4 . var_2 ( ` . moves . urllib . request ` + var_4 ) )",
        "Var_Maps": [
            {
                ".moves.urllib.request": "var_3",
                "Module_six_moves_urllib_request": "var_0",
                ".moves.urllib_request": "var_1",
                "__name__": "var_6",
                "modules": "var_8",
                "sys": "var_10"
            }
        ]
    },
    {
        "intent": "[CLS] assign the result to the value under the string str_0 app ##ended to _ _ name _ _ key of the sy ##s . modules dictionary , and to the value under the string str_1 app ##ended to _ _ name _ _ key of the sy ##s . modules dictionary . derive class var_0 from the var_1 base class . [SEP]",
        "reference": "class Module_six_moves_urllib_response ( _Lazy Module ) : pass",
        "Output": "class Module_six_moves_urllib_response ( _Lazy Module ) : pass",
        "Var_Maps": [
            {
                ".moves.urllib_request": "str_0",
                ".moves.urllib.request": "str_1",
                "Module_six_moves_urllib_response": "var_0",
                "_LazyModule": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a list with 4 elements : result of the function var_5 , called with 3 arguments : [SEP]",
        "reference": "_urllib_response_moved_attributes = [ Moved Attribute ( ` addbase ` , ` urllib ` , ` urllib . response ` ) , Moved Attribute ( ` addclosehook ` , ` urllib ` , ` urllib . response ` ) , Moved Attribute ( ` addinfo ` , ` urllib ` , ` urllib . response ` ) , Moved Attribute ( ` addinfourl ` , ` urllib ` , ` urllib . response ` ) ]",
        "Output": "_urllib_response_moved_attributes = [ var_5 ( var_2 , var_3 = ` urllib . response ` ) , var_6 ( var_1 ) ]",
        "Var_Maps": [
            {
                "_urllib_response_moved_attributes": "var_0",
                "urllib.response": "var_4",
                "MovedAttribute": "var_8",
                "addclosehook": "var_9",
                "addinfourl": "var_10",
                "addbase": "var_11",
                "addinfo": "var_12",
                "urllib": "var_16"
            }
        ]
    },
    {
        "intent": "[CLS] strings str_0 , str_1 and str_2 , result of the function moved ##att ##ri ##bu ##te , called with 3 arguments : strings str_3 , str_1 , str_2 , result of the function moved ##att ##ri ##bu ##te , called with 3 arguments : strings str_4 , str_1 , str_2 and result of the function moved ##att ##ri ##bu ##te , called with 3 arguments : strings str_5 , str_1 , str_2 . for every var_1 in var_0 , [SEP]",
        "reference": "for attr in _urllib_response_moved_attributes : pass",
        "Output": "for attr in _urllib_response_moved_attributes : pass",
        "Var_Maps": [
            {
                "addbase": "str_0",
                "urllib": "str_1",
                "urllib.response": "str_2",
                "addclosehook": "str_3",
                "addinfo": "str_4",
                "addinfourl": "str_5",
                "_urllib_response_moved_attributes": "var_0",
                "attr": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] set var_2 . var_3 var_2 ib ##ute of var_0 object to var_2 . [SEP]",
        "reference": "setattr ( Module_six_moves_urllib_response , attr . name , attr )",
        "Output": "setattr ( Module_six_moves_urllib_response , attr . name , attr )",
        "Var_Maps": [
            {
                "Module_six_moves_urllib_response": "var_0",
                "setattr": "var_1",
                "attr": "var_4",
                "name": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] del ##ete var_0 . [SEP]",
        "reference": "del attr",
        "Output": "del attr",
        "Var_Maps": [
            {
                "attr": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_1 . var_2 . [SEP]",
        "reference": "Module_six_moves_urllib_response . _moved_attributes = ( _urllib_response_moved_attributes )",
        "Output": "Module_six_moves_urllib_response . _moved_attributes = _urllib_response_moved_attributes",
        "Var_Maps": [
            {
                "_urllib_response_moved_attributes": "var_0",
                "Module_six_moves_urllib_response": "var_1",
                "_moved_attributes": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] instant ##iate class var_0 with an argument , string str_0 app ##ended to var_4 , [SEP]",
        "reference": "sys . modules [ __name__ + ` . moves . urllib_response ` ] = sys . modules [ __name__ + ` . moves . urllib . response ` ] = Module_six_moves_urllib_response ( __name__ + ` . moves . urllib . response ` )",
        "Output": "var_2 = Module_six_moves_urllib_response ( var_4 , ` var_2 ` % var_5 ( . moves . urllib . response ) )",
        "Var_Maps": [
            {
                ".moves.urllib.response": "var_3",
                "Module_six_moves_urllib_response": "var_0",
                ".moves.urllib_response": "var_1",
                "__name__": "var_6",
                "modules": "var_8",
                "sys": "var_10"
            }
        ]
    },
    {
        "intent": "[CLS] assign it to value under the string str_0 app ##ended to _ _ name _ _ key of the sy ##s . modules dictionary , and to value under the string str_1 app ##ended to _ _ name _ _ key of the sy ##s . modules dictionary . derive class var_0 from the var_1 base class . [SEP]",
        "reference": "class Module_six_moves_urllib_robotparser ( _Lazy Module ) : pass",
        "Output": "class Module_six_moves_urllib_robotparser ( _Lazy Module ) : pass",
        "Var_Maps": [
            {
                ".moves.urllib_response": "str_0",
                ".moves.urllib.response": "str_1",
                "Module_six_moves_urllib_robotparser": "var_0",
                "_LazyModule": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a list containing an instance of var_3 class , created with 3 argument : strings , [SEP]",
        "reference": "_urllib_robotparser_moved_attributes = [ Moved Attribute ( ` Robot File Parser ` , ` robotparser ` , ` urllib . robotparser ` ) ]",
        "Output": "_urllib_robotparser_moved_attributes = [ ` Robot File Parser ` ]",
        "Var_Maps": [
            {
                "_urllib_robotparser_moved_attributes": "var_0",
                "urllib.robotparser": "var_1",
                "RobotFileParser": "var_2",
                "MovedAttribute": "var_3",
                "robotparser": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] str_0 , str_1 , str_2 . for every var_1 in var_0 , [SEP]",
        "reference": "for attr in _urllib_robotparser_moved_attributes : pass",
        "Output": "for attr in _urllib_robotparser_moved_attributes : pass",
        "Var_Maps": [
            {
                "RobotFileParser": "str_0",
                "robotparser": "str_1",
                "urllib.robotparser": "str_2",
                "_urllib_robotparser_moved_attributes": "var_0",
                "attr": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] set var_2 . var_3 var_2 ib ##ute of var_0 object to var_2 . [SEP]",
        "reference": "setattr ( Module_six_moves_urllib_robotparser , attr . name , attr )",
        "Output": "setattr ( Module_six_moves_urllib_robotparser , attr . name , attr )",
        "Var_Maps": [
            {
                "Module_six_moves_urllib_robotparser": "var_0",
                "setattr": "var_1",
                "attr": "var_4",
                "name": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] del ##ete var_0 . [SEP]",
        "reference": "del attr",
        "Output": "del attr",
        "Var_Maps": [
            {
                "attr": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_1 . var_2 . [SEP]",
        "reference": "Module_six_moves_urllib_robotparser . _moved_attributes = ( _urllib_robotparser_moved_attributes )",
        "Output": "Module_six_moves_urllib_robotparser . _moved_attributes = _urllib_robotparser_moved_attributes",
        "Var_Maps": [
            {
                "_urllib_robotparser_moved_attributes": "var_0",
                "Module_six_moves_urllib_robotparser": "var_1",
                "_moved_attributes": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] instant ##iate class var_0 with an argument , string str_0 app ##ended to var_4 , [SEP]",
        "reference": "sys . modules [ __name__ + ` . moves . urllib_robotparser ` ] = sys . modules [ __name__ + ` . moves . urllib . robotparser ` ] = Module_six_moves_urllib_robotparser ( __name__ + ` . moves . urllib . robotparser ` )",
        "Output": "var_2 = Module_six_moves_urllib_robotparser ( var_4 , ` var_2 ` % var_5 ( . moves . urllib . robotparser ) )",
        "Var_Maps": [
            {
                ".moves.urllib.robotparser": "var_3",
                "Module_six_moves_urllib_robotparser": "var_0",
                ".moves.urllib_robotparser": "var_1",
                "__name__": "var_6",
                "modules": "var_8",
                "sys": "var_10"
            }
        ]
    },
    {
        "intent": "[CLS] assign it to value under the string str_0 app ##ended to _ _ name _ _ key of the sy ##s . modules dictionary , and to value under the string str_1 app ##ended to _ _ name _ _ key of the sy ##s . modules dictionary . derive class var_0 from the var_2 . var_1 base class . [SEP]",
        "reference": "class Module_six_moves_urllib ( types . Module Type ) : pass",
        "Output": "class Module_six_moves_urllib ( types . Module Type ) : pass",
        "Var_Maps": [
            {
                ".moves.urllib_robotparser": "str_0",
                ".moves.urllib.robotparser": "str_1",
                "Module_six_moves_urllib": "var_0",
                "ModuleType": "var_1",
                "types": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] app ##end string str_0 to var_1 , use it as an key to get the value from the var_4 . var_2 dictionary , substitute it for var_3 . [SEP]",
        "reference": "parse = sys . modules [ __name__ + ` . moves . urllib_parse ` ]",
        "Output": "parse = sys . modules [ ` . moves . urllib_parse ` ]",
        "Var_Maps": [
            {
                ".moves.urllib_parse": "var_0",
                "__name__": "var_1",
                "modules": "var_2",
                "parse": "var_3",
                "sys": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] app ##end string str_0 to var_1 , use it as an key to get the value from the var_4 . var_2 dictionary , substitute it for var_3 . [SEP]",
        "reference": "error = sys . modules [ __name__ + ` . moves . urllib_error ` ]",
        "Output": "error = sys . modules [ ` . moves . urllib_error ` ]",
        "Var_Maps": [
            {
                ".moves.urllib_error": "var_0",
                "__name__": "var_1",
                "modules": "var_2",
                "error": "var_3",
                "sys": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] app ##end string str_0 to var_1 , use it as an key to get the value from the var_4 . var_3 dictionary , substitute it for var_2 . [SEP]",
        "reference": "request = sys . modules [ __name__ + ` . moves . urllib_request ` ]",
        "Output": "request = sys . modules [ ` . moves . urllib_request ` ]",
        "Var_Maps": [
            {
                ".moves.urllib_request": "var_0",
                "__name__": "var_1",
                "request": "var_2",
                "modules": "var_3",
                "sys": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] app ##end string str_0 to var_2 , use it as an key to get the value from the var_4 . var_3 dictionary , substitute it for var_1 . [SEP]",
        "reference": "response = sys . modules [ __name__ + ` . moves . urllib_response ` ]",
        "Output": "response = sys . modules [ ` . moves . urllib_response ` ]",
        "Var_Maps": [
            {
                ".moves.urllib_response": "var_0",
                "response": "var_1",
                "__name__": "var_2",
                "modules": "var_3",
                "sys": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] app ##end string str_0 to var_2 , use it as an key to get the value from the var_4 . var_3 dictionary , substitute it for var_1 . [SEP]",
        "reference": "robotparser = sys . modules [ __name__ + ` . moves . urllib_robotparser ` ]",
        "Output": "robotparser = sys . modules [ ` . moves . urllib_robotparser ` ]",
        "Var_Maps": [
            {
                ".moves.urllib_robotparser": "var_0",
                "robotparser": "var_1",
                "__name__": "var_2",
                "modules": "var_3",
                "sys": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def __dir__ ( self ) : pass",
        "Output": "def __dir__ ( self ) : pass",
        "Var_Maps": [
            {
                "__dir__": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return a list with 5 elements : strings str_0 , str_1 , str_2 , str_3 and str_4 . [SEP]",
        "reference": "return [ ` parse ` , ` error ` , ` request ` , ` response ` , ` robotparser ` ]",
        "Output": "return [ ` parse ` , ` response ` , ` robotparser ` , ` request ` ]",
        "Var_Maps": [
            {
                "parse": "var_3",
                "error": "var_4",
                "request": "var_2",
                "response": "var_1",
                "robotparser": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] instant ##iate class var_0 with an argument , string str_0 app ##ended to var_3 , [SEP]",
        "reference": "sys . modules [ __name__ + ` . moves . urllib ` ] = Module_six_moves_urllib ( __name__ + ` . moves . urllib ` )",
        "Output": "Module_six_moves_urllib ( __name__ , ` . moves . urllib ` % modules ( __name__ ) )",
        "Var_Maps": [
            {
                ".moves.urllib": "var_2",
                "Module_six_moves_urllib": "var_0",
                "__name__": "var_4",
                "modules": "var_5",
                "sys": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] substitute it for value under the string str_0 app ##ended to _ _ name _ _ key of the sy ##s . modules dictionary . define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def add_move ( move ) : pass",
        "Output": "def add_move ( move ) : pass",
        "Var_Maps": [
            {
                ".moves.urllib": "str_0",
                "add_move": "var_0",
                "move": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] set var_2 . var_3 attribute of the var_0 to var_2 . [SEP]",
        "reference": "setattr ( _Moved Items , move . name , move )",
        "Output": "setattr ( _Moved Items , var_5 . name , move )",
        "Var_Maps": [
            {
                "_MovedItems": "var_0",
                "setattr": "var_1",
                "move": "var_4",
                "name": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def remove_move ( name ) : pass",
        "Output": "def remove_move ( name ) : pass",
        "Var_Maps": [
            {
                "remove_move": "var_0",
                "name": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] del ##ete var_2 attribute of the var_0 object . [SEP]",
        "reference": "delattr ( _Moved Items , name )",
        "Output": "delattr ( _Moved Items , name )",
        "Var_Maps": [
            {
                "_MovedItems": "var_0",
                "delattr": "var_1",
                "name": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Attribute Error : pass",
        "Output": "try : pass except Attribute Error : pass",
        "Var_Maps": [
            {
                "AttributeError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] del ##ete entry under the var_2 key of the var_1 . var_0 dictionary . [SEP]",
        "reference": "del moves . __dict__ [ name ]",
        "Output": "del moves . __dict__ [ name ]",
        "Var_Maps": [
            {
                "__dict__": "var_0",
                "moves": "var_1",
                "name": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if name ##er ##ror exception is caught , [SEP]",
        "reference": "try : pass except Key Error : pass",
        "Output": "try : pass except var_1 : pass",
        "Var_Maps": [
            {
                "KeyError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] raise an var_1 with an argument string str_0 , format ##ed with a tu ##ple with an element var_2 . [SEP]",
        "reference": "raise Attribute Error ( ` no such move , % r ` % ( name , ) )",
        "Output": "raise Attribute Error ( ` no such move , % r ` % ( name , ) )",
        "Var_Maps": [
            {
                "no such move, %r": "var_0",
                "AttributeError": "var_1",
                "name": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if PY3 : pass",
        "Output": "if PY3 : pass",
        "Var_Maps": [
            {
                "PY3": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "_meth_func = ` __func__ `",
        "Output": "_meth_func = ` __func__ `",
        "Var_Maps": [
            {
                "__func__": "var_1",
                "_meth_func": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "_meth_self = ` __self__ `",
        "Output": "_meth_self = ` __self__ `",
        "Var_Maps": [
            {
                "__self__": "var_1",
                "_meth_self": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "_func_closure = ` __closure__ `",
        "Output": "_func_closure = ` __closure__ `",
        "Var_Maps": [
            {
                "__closure__": "var_1",
                "_func_closure": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "_func_code = ` __code__ `",
        "Output": "_func_code = ` __code__ `",
        "Var_Maps": [
            {
                "__code__": "var_1",
                "_func_code": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "_func_defaults = ` __defaults__ `",
        "Output": "_func_defaults = ` __defaults__ `",
        "Var_Maps": [
            {
                "__defaults__": "var_1",
                "_func_defaults": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "_func_globals = ` __globals__ `",
        "Output": "_func_globals = ` __globals__ `",
        "Var_Maps": [
            {
                "__globals__": "var_1",
                "_func_globals": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "_iterkeys = ` keys `",
        "Output": "_iterkeys = ` keys `",
        "Var_Maps": [
            {
                "keys": "var_1",
                "_iterkeys": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "_itervalues = ` values `",
        "Output": "_itervalues = ` values `",
        "Var_Maps": [
            {
                "values": "var_1",
                "_itervalues": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "_iteritems = ` items `",
        "Output": "_iteritems = ` items `",
        "Var_Maps": [
            {
                "items": "var_1",
                "_iteritems": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "_iterlists = ` lists `",
        "Output": "_iterlists = ` lists `",
        "Var_Maps": [
            {
                "lists": "var_1",
                "_iterlists": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "_meth_func = ` im_func `",
        "Output": "_meth_func = ` im_func `",
        "Var_Maps": [
            {
                "im_func": "var_1",
                "_meth_func": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "_meth_self = ` im_self `",
        "Output": "_meth_self = ` im_self `",
        "Var_Maps": [
            {
                "im_self": "var_1",
                "_meth_self": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "_func_closure = ` func_closure `",
        "Output": "_func_closure = ` func_closure `",
        "Var_Maps": [
            {
                "func_closure": "var_1",
                "_func_closure": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "_func_code = ` func_code `",
        "Output": "_func_code = ` func_code `",
        "Var_Maps": [
            {
                "func_code": "var_1",
                "_func_code": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "_func_defaults = ` func_defaults `",
        "Output": "_func_defaults = ` func_defaults `",
        "Var_Maps": [
            {
                "func_defaults": "var_1",
                "_func_defaults": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "_func_globals = ` func_globals `",
        "Output": "_func_globals = ` func_globals `",
        "Var_Maps": [
            {
                "func_globals": "var_1",
                "_func_globals": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "_iterkeys = ` iterkeys `",
        "Output": "_iterkeys = ` iterkeys `",
        "Var_Maps": [
            {
                "iterkeys": "var_1",
                "_iterkeys": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] _ it ##er ##key ##s is a string str_0 . [SEP]",
        "reference": "_itervalues = ` itervalues `",
        "Output": "_itervalues = ` itervalues `",
        "Var_Maps": [
            {
                "iterkeys": "str_0",
                "_itervalues": "var_0",
                "itervalues": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "_iteritems = ` iteritems `",
        "Output": "_iteritems = ` iteritems `",
        "Var_Maps": [
            {
                "iteritems": "var_1",
                "_iteritems": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "_iterlists = ` iterlists `",
        "Output": "_iterlists = ` iterlists `",
        "Var_Maps": [
            {
                "iterlists": "var_1",
                "_iterlists": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "advance_iterator = next",
        "Output": "advance_iterator = next",
        "Var_Maps": [
            {
                "advance_iterator": "var_0",
                "next": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Name Error : pass",
        "Output": "try : pass except Name Error : pass",
        "Var_Maps": [
            {
                "NameError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 w var_1 h an argument var_1 . [SEP]",
        "reference": "def advance_iterator ( it ) : pass",
        "Output": "def advance_iterator ( it ) : pass",
        "Var_Maps": [
            {
                "advance_iterator": "var_0",
                "it": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 element of the var_1 era ##ble var_1 . [SEP]",
        "reference": "return it . next ( )",
        "Output": "return next [ it ]",
        "Var_Maps": [
            {
                "next": "var_0",
                "it": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute k ##lass . _ _ di ##ct _ _ for var_1 . [SEP]",
        "reference": "next = advance_iterator",
        "Output": "next = # # lass . advance_iterator",
        "Var_Maps": [
            {
                "advance_iterator": "var_0",
                "next": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_0 . [SEP]",
        "reference": "callable = callable",
        "Output": "var_2 . callable = callable",
        "Var_Maps": [
            {
                "callable": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Name Error : pass",
        "Output": "try : pass except Name Error : pass",
        "Var_Maps": [
            {
                "NameError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def callable ( obj ) : pass",
        "Output": "def callable ( obj ) : pass",
        "Var_Maps": [
            {
                "callable": "var_0",
                "obj": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if str_0 is contained in var_3 . var_1 for var_6 var_3 in var_2 field of the var _ 7 class , return boo ##lean true , otherwise return false . [SEP]",
        "reference": "return any ( ` __call__ ` in klass . __dict__ for klass in type ( obj ) . __mro__ )",
        "Output": "return ` __call__ ` in klass ( obj ) . __dict__",
        "Var_Maps": [
            {
                "__call__": "var_0",
                "__dict__": "var_1",
                "__mro__": "var_2",
                "klass": "var_4",
                "type": "var_5",
                "any": "var_6",
                "obj": "var_7"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if PY3 : pass",
        "Output": "if PY3 : pass",
        "Var_Maps": [
            {
                "PY3": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def get_unbound_function ( unbound ) : pass",
        "Output": "def get_unbound_function ( unbound ) : pass",
        "Var_Maps": [
            {
                "get_unbound_function": "var_0",
                "unbound": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return unbound",
        "Output": "return unbound",
        "Var_Maps": [
            {
                "unbound": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute it ##era ##tor for var_0 . [SEP]",
        "reference": "create_bound_method = types . Method Type",
        "Output": "create_bound_method = create_bound_method",
        "Var_Maps": [
            {
                "create_bound_method": "var_0",
                "MethodType": "var_1",
                "types": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "Iterator = object",
        "Output": "Iterator = object",
        "Var_Maps": [
            {
                "Iterator": "var_0",
                "object": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def get_unbound_function ( unbound ) : pass",
        "Output": "def get_unbound_function ( unbound ) : pass",
        "Var_Maps": [
            {
                "get_unbound_function": "var_0",
                "unbound": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . var_1 . [SEP]",
        "reference": "return unbound . im_func",
        "Output": "return unbound . im_func",
        "Var_Maps": [
            {
                "unbound": "var_0",
                "im_func": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the var_1 ti ##on create _ bound _ var_1 ti ##on with 2 arguments : var_1 and var_2 . [SEP]",
        "reference": "def create_bound_method ( func , obj ) : pass",
        "Output": "def create_bound_method ( func , obj ) : pass",
        "Var_Maps": [
            {
                "create_bound_method": "var_0",
                "func": "var_1",
                "obj": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 with 3 arguments : var_3 , var_4 and var_4 . var_1 , return the result . [SEP]",
        "reference": "return types . Method Type ( func , obj , obj . __class__ )",
        "Output": "return types . Method Type ( func , var_6 , obj . __class__ )",
        "Var_Maps": [
            {
                "MethodType": "var_0",
                "__class__": "var_1",
                "types": "var_2",
                "func": "var_3",
                "obj": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] derive the class var_0 from the base class var_1 . [SEP]",
        "reference": "class Iterator ( object ) : pass",
        "Output": "class Iterator ( object ) : pass",
        "Var_Maps": [
            {
                "Iterator": "var_0",
                "object": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def next ( self ) : pass",
        "Output": "def next ( self ) : pass",
        "Var_Maps": [
            {
                "next": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 with an argument var_2 , on the result call the method var_0 with an argument var_2 , return the result . [SEP]",
        "reference": "return type ( self ) . __next__ ( self )",
        "Output": "return type ( self ) . __next__ ( self )",
        "Var_Maps": [
            {
                "__next__": "var_0",
                "type": "var_1",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_0 . [SEP]",
        "reference": "callable = callable",
        "Output": "var_2 . callable = callable",
        "Var_Maps": [
            {
                "callable": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_2 with 2 arguments : var_1 and string str_0 \" var_0 str_0 \" . [SEP]",
        "reference": "_add_doc ( get_unbound_function , ` Get the function out of a possibly unbound function ` )",
        "Output": "_add_doc ( get_unbound_function , ` Get the function out of a possibly unbound function ` , _add_doc [ ` var_4 ` ] )",
        "Var_Maps": [
            {
                "": "str_0",
                "Get the function out of a possibly unbound function": "var_0",
                "get_unbound_function": "var_1",
                "_add_doc": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_3 . var_1 with an argument var_2 , substitute the result for var_0 . [SEP]",
        "reference": "get_method_function = operator . attrgetter ( _meth_func )",
        "Output": "get_method_function = operator . attrgetter ( _meth_func )",
        "Var_Maps": [
            {
                "get_method_function": "var_0",
                "attrgetter": "var_1",
                "_meth_func": "var_2",
                "operator": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_3 . var_1 with an argument var_2 , substitute the result for var_0 . [SEP]",
        "reference": "get_method_self = operator . attrgetter ( _meth_self )",
        "Output": "get_method_self = operator . attrgetter ( _meth_self )",
        "Var_Maps": [
            {
                "get_method_self": "var_0",
                "attrgetter": "var_1",
                "_meth_self": "var_2",
                "operator": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_3 . var_2 with an argument var_1 , substitute the result for get _ method _ closure . [SEP]",
        "reference": "get_function_closure = operator . attrgetter ( _func_closure )",
        "Output": "get_function_closure = operator . attrgetter ( _func_closure )",
        "Var_Maps": [
            {
                "get_function_closure": "var_0",
                "_func_closure": "var_1",
                "attrgetter": "var_2",
                "operator": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_3 . var_1 with an argument var_2 , substitute the result for get _ method _ code . [SEP]",
        "reference": "get_function_code = operator . attrgetter ( _func_code )",
        "Output": "get_function_code = operator . attrgetter ( _func_code )",
        "Var_Maps": [
            {
                "get_function_code": "var_0",
                "attrgetter": "var_1",
                "_func_code": "var_2",
                "operator": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_3 . var_2 with an argument var_1 , substitute the result for get _ method _ default ##s . [SEP]",
        "reference": "get_function_defaults = operator . attrgetter ( _func_defaults )",
        "Output": "get_function_defaults = operator . attrgetter ( _func_defaults )",
        "Var_Maps": [
            {
                "get_function_defaults": "var_0",
                "_func_defaults": "var_1",
                "attrgetter": "var_2",
                "operator": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_3 . var_2 with an argument var_1 , substitute the result for get _ method _ global ##s . [SEP]",
        "reference": "get_function_globals = operator . attrgetter ( _func_globals )",
        "Output": "get_function_globals = operator . attrgetter ( _func_globals )",
        "Var_Maps": [
            {
                "get_function_globals": "var_0",
                "_func_globals": "var_1",
                "attrgetter": "var_2",
                "operator": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 e ##fine the function var_0 with 2 arguments : var_2 an var_2 un ##pack ##e var_2 var_2 ict ##ion ##ary var_1 . [SEP]",
        "reference": "def iterkeys ( d , * * kw ) : pass",
        "Output": "def iterkeys ( d , * * kw ) : pass",
        "Var_Maps": [
            {
                "iterkeys": "var_0",
                "kw": "var_1",
                "d": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] get var_0 attribute of the class var_4 , call the result with an argument un ##pack ##e var_4 var_4 ict ##ion ##ary var_3 , convert the result to a var_2 able , [SEP]",
        "reference": "return iter ( getattr ( d , _iterkeys ) ( * * kw ) )",
        "Output": "getattr = iter ( var_5 ( d , _iterkeys ) , kw , * * kw )",
        "Var_Maps": [
            {
                "_iterkeys": "var_0",
                "getattr": "var_1",
                "iter": "var_2",
                "kw": "var_3",
                "d": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] return it . var_2 e ##fine the function var_0 with 2 arguments : var_2 an var_2 un ##pack ##e var_2 var_2 ict ##ion ##ary var_1 . [SEP]",
        "reference": "def itervalues ( d , * * kw ) : pass",
        "Output": "def itervalues ( d , * * kw ) : pass",
        "Var_Maps": [
            {
                "itervalues": "var_0",
                "kw": "var_1",
                "d": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] get var_0 attribute of the class var_4 , call the result with an argument un ##pack ##e var_4 var_4 ict ##ion ##ary var_3 , convert the result to a var_2 able , [SEP]",
        "reference": "return iter ( getattr ( d , _itervalues ) ( * * kw ) )",
        "Output": "getattr = iter ( var_5 ( d , _itervalues ) , kw , * * kw )",
        "Var_Maps": [
            {
                "_itervalues": "var_0",
                "getattr": "var_1",
                "iter": "var_2",
                "kw": "var_3",
                "d": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] return it . var_2 e ##fine the function var_0 with 2 arguments : var_2 an var_2 un ##pack ##e var_2 var_2 ict ##ion ##ary var_1 . [SEP]",
        "reference": "def iteritems ( d , * * kw ) : pass",
        "Output": "def iteritems ( d , * * kw ) : pass",
        "Var_Maps": [
            {
                "iteritems": "var_0",
                "kw": "var_1",
                "d": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] get var_0 attribute of the class var_4 , call the result with an argument un ##pack ##e var_4 var_4 ict ##ion ##ary var_3 , convert the result to a var_2 able , [SEP]",
        "reference": "return iter ( getattr ( d , _iteritems ) ( * * kw ) )",
        "Output": "getattr = iter ( var_5 ( d , _iteritems ) , kw , * * kw )",
        "Var_Maps": [
            {
                "_iteritems": "var_0",
                "getattr": "var_1",
                "iter": "var_2",
                "kw": "var_3",
                "d": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] return it . var_2 e ##fine the function var_0 with 2 arguments : var_2 an var_2 un ##pack ##e var_2 var_2 ict ##ion ##ary var_1 . [SEP]",
        "reference": "def iterlists ( d , * * kw ) : pass",
        "Output": "def iterlists ( d , * * kw ) : pass",
        "Var_Maps": [
            {
                "iterlists": "var_0",
                "kw": "var_1",
                "d": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] get var_0 attribute of the class var_4 , call the result with an argument un ##pack ##e var_4 var_4 ict ##ion ##ary var_3 , convert the result to a var_2 able , [SEP]",
        "reference": "return iter ( getattr ( d , _iterlists ) ( * * kw ) )",
        "Output": "getattr = iter ( var_5 ( d , _iterlists ) , kw , * * kw )",
        "Var_Maps": [
            {
                "_iterlists": "var_0",
                "getattr": "var_1",
                "iter": "var_2",
                "kw": "var_3",
                "d": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] return it . if var_0 is true , [SEP]",
        "reference": "if PY3 : pass",
        "Output": "if PY3 : pass",
        "Var_Maps": [
            {
                "PY3": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def b ( s ) : pass",
        "Output": "def b ( s ) : pass",
        "Var_Maps": [
            {
                "b": "var_0",
                "s": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method e . var_1 with an argument var_2 tri ##ng var_2 tr _ 0 . [SEP]",
        "reference": "return s . encode ( ` latin - 1 ` )",
        "Output": "latin - 1 . encode ( ` s ` )",
        "Var_Maps": [
            {
                "latin-1": "var_0",
                "encode": "var_1",
                "s": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the f var_0 nc ##tion var_0 with an ar ##g var_0 men ##t var_1 . [SEP]",
        "reference": "def u ( s ) : pass",
        "Output": "def u ( s ) : pass",
        "Var_Maps": [
            {
                "u": "var_0",
                "s": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return s",
        "Output": "return s",
        "Var_Maps": [
            {
                "s": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "unichr = chr",
        "Output": "unichr = chr",
        "Var_Maps": [
            {
                "unichr": "var_0",
                "chr": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if second element of var_1 . var_0 is smaller than or equal to integer 1 , [SEP]",
        "reference": "if sys . version_info [ 1 ] < = 1 : pass",
        "Output": "if sys . version_info [ 1 ] < = 1 : pass",
        "Var_Maps": [
            {
                "version_info": "var_0",
                "sys": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] def var_1 ne the fun ##ct var_1 on var_0 w var_1 th an argument var_1 . [SEP]",
        "reference": "def int2byte ( i ) : pass",
        "Output": "def int2byte ( i ) : pass",
        "Var_Maps": [
            {
                "int2byte": "var_0",
                "i": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the fun ##ct var_1 on var_0 w var_1 th an argument tu ##ple w var_1 th an element var_1 , return the result . [SEP]",
        "reference": "return bytes ( ( i , ) )",
        "Output": "return bytes ( ( i , ) )",
        "Var_Maps": [
            {
                "bytes": "var_0",
                "i": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 with 3 arguments : string str_0 , integer 1 and string str_1 , substitute the result for var_1 . [SEP]",
        "reference": "int2byte = operator . methodcaller ( ` to_bytes ` , 1 , ` big ` )",
        "Output": "int2byte = operator . methodcaller ( ` to_bytes ` , 1 , ` big ` )",
        "Var_Maps": [
            {
                "to_bytes": "var_3",
                "big": "var_4",
                "methodcaller": "var_0",
                "int2byte": "var_1",
                "operator": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call te method var_2 . var_0 with an argument integer 0 , substitute the result for var_1 . [SEP]",
        "reference": "byte2int = operator . itemgetter ( 0 )",
        "Output": "byte2int = operator . itemgetter ( 0 )",
        "Var_Maps": [
            {
                "itemgetter": "var_0",
                "byte2int": "var_1",
                "operator": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 . var_2 for var_0 . [SEP]",
        "reference": "indexbytes = operator . getitem",
        "Output": "indexbytes = operator . getitem",
        "Var_Maps": [
            {
                "indexbytes": "var_0",
                "operator": "var_1",
                "getitem": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "iterbytes = iter",
        "Output": "iterbytes = iter",
        "Var_Maps": [
            {
                "iterbytes": "var_0",
                "iter": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] import var_0 . [SEP]",
        "reference": "import io",
        "Output": "import io",
        "Var_Maps": [
            {
                "io": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_2 . var_0 for var_0 . [SEP]",
        "reference": "String IO = io . String IO",
        "Output": "String IO = io . String IO",
        "Var_Maps": [
            {
                "StringIO": "var_1",
                "io": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_2 . var_0 for var_0 . [SEP]",
        "reference": "Bytes IO = io . Bytes IO",
        "Output": "Bytes IO = io . Bytes IO",
        "Var_Maps": [
            {
                "BytesIO": "var_1",
                "io": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def b ( s ) : pass",
        "Output": "def b ( s ) : pass",
        "Var_Maps": [
            {
                "b": "var_0",
                "s": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return s",
        "Output": "return s",
        "Var_Maps": [
            {
                "s": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the f var_0 nc ##tion var_0 with an ar ##g var_0 men ##t var_1 . [SEP]",
        "reference": "def u ( s ) : pass",
        "Output": "def u ( s ) : pass",
        "Var_Maps": [
            {
                "u": "var_0",
                "s": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 every occurrence of raw var_5 tri ##ng var_5 tr _ 0 var_3 ' , u var_5 e the re var_5 ul ##t and var_5 tri ##ng var_5 tr _ 1 , [SEP]",
        "reference": "return unicode ( s . replace ( ` \\ \\ \\ \\ ` , ` \\ \\ \\ \\ \\ \\ \\ \\ ` ) , ` unicode_escape ` )",
        "Output": "unicode = var_6 . replace ( ` \\ \\ ` )",
        "Var_Maps": [
            {
                "\\\\' in s with a raw string ": "str_0",
                "unicode_escape": "var_0",
                "unicode": "var_1",
                "replace": "var_2",
                "\\\\\\\\": "var_3",
                "\\\\": "var_4",
                "s": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] as arguments for the call to the unicode function , return the result . substitute var_0 for var_0 . [SEP]",
        "reference": "unichr = unichr",
        "Output": "unichr = unichr",
        "Var_Maps": [
            {
                "unichr": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "int2byte = chr",
        "Output": "int2byte = chr",
        "Var_Maps": [
            {
                "int2byte": "var_0",
                "chr": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def byte2int ( bs ) : pass",
        "Output": "def byte2int ( bs ) : pass",
        "Var_Maps": [
            {
                "byte2int": "var_0",
                "bs": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] get the integer representation of the first element of var_1 , return it . [SEP]",
        "reference": "return ord ( bs [ 0 ] )",
        "Output": "return var_2 ( bs )",
        "Var_Maps": [
            {
                "ord": "var_0",
                "bs": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] def var_2 ne the fun ##ct var_2 on var_0 w var_2 th 2 arguments var_1 and var_2 . [SEP]",
        "reference": "def indexbytes ( buf , i ) : pass",
        "Output": "def indexbytes ( buf , i ) : pass",
        "Var_Maps": [
            {
                "indexbytes": "var_0",
                "buf": "var_1",
                "i": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] get the var_2 nt ##eger represent ##at var_2 on of the var_2 - th element of var_1 , return var_2 t . [SEP]",
        "reference": "return ord ( buf [ i ] )",
        "Output": "return buf [ var_3 ] . ord ( var_3 )",
        "Var_Maps": [
            {
                "ord": "var_0",
                "buf": "var_1",
                "i": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def iterbytes ( buf ) : pass",
        "Output": "def iterbytes ( buf ) : pass",
        "Var_Maps": [
            {
                "iterbytes": "var_0",
                "buf": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] convert var_0 to its integer representation , return all of the results for every var_0 in var_3 . [SEP]",
        "reference": "return ( ord ( byte ) for byte in buf )",
        "Output": "return [ ord ( ord ) for ord in buf ]",
        "Var_Maps": [
            {
                "byte": "var_1",
                "ord": "var_2",
                "buf": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] import var_0 . [SEP]",
        "reference": "import String IO",
        "Output": "import String IO",
        "Var_Maps": [
            {
                "StringIO": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] assign var_0 . var_0 to var_0 and var_3 . [SEP]",
        "reference": "String IO = Bytes IO = String IO . String IO",
        "Output": "String IO , Bytes IO = String IO . String IO",
        "Var_Maps": [
            {
                "StringIO": "var_2",
                "BytesIO": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 with 2 arguments : var_2 and string str_0 \" var_0 str_0 \" . [SEP]",
        "reference": "_add_doc ( b , ` Byte literal ` )",
        "Output": "_add_doc ( b , ` var_3 ` )",
        "Var_Maps": [
            {
                "": "str_0",
                "Byte literal": "var_0",
                "_add_doc": "var_1",
                "b": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the f var_2 nc ##tion var_1 with 2 ar ##g var_2 men ##ts : var_2 and string str_0 \" var_0 str_0 \" . [SEP]",
        "reference": "_add_doc ( u , ` Text literal ` )",
        "Output": "_add_doc ( u , ` var_3 ` , ` Text literal ` )",
        "Var_Maps": [
            {
                "": "str_0",
                "Text literal": "var_0",
                "_add_doc": "var_1",
                "u": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if PY3 : pass",
        "Output": "if PY3 : pass",
        "Var_Maps": [
            {
                "PY3": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] get str_0 attribute from the var_3 . var_0 object , substitute it for var_2 . [SEP]",
        "reference": "exec_ = getattr ( moves . builtins , ` exec ` )",
        "Output": "exec_ = getattr ( moves . builtins , ` getattr ` )",
        "Var_Maps": [
            {
                "exec": "var_4",
                "builtins": "var_0",
                "getattr": "var_1",
                "exec_": "var_2",
                "moves": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 3 arguments : var_2 , var_1 and var_3 set to none . [SEP]",
        "reference": "def reraise ( tp , value , tb = None ) : pass",
        "Output": "def reraise ( tp , value , tb = None ) : pass",
        "Var_Maps": [
            {
                "reraise": "var_0",
                "value": "var_1",
                "tp": "var_2",
                "tb": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 . var_0 is not var_2 , [SEP]",
        "reference": "if value . __traceback__ is not tb : pass",
        "Output": "if value . __traceback__ is not tb : pass",
        "Var_Maps": [
            {
                "__traceback__": "var_0",
                "value": "var_1",
                "tb": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] raise an var_1 . var_0 exception with an argument var_2 . [SEP]",
        "reference": "raise value . with_traceback ( tb )",
        "Output": "raise value . with_traceback ( tb )",
        "Var_Maps": [
            {
                "with_traceback": "var_0",
                "value": "var_1",
                "tb": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] raise an exception var_0 . [SEP]",
        "reference": "raise value",
        "Output": "raise value ( )",
        "Var_Maps": [
            {
                "value": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] define the function ex ##ec with 3 arguments : var_1 , var_0 set to none and var_2 set to none . [SEP]",
        "reference": "def exec_ ( _code_ , _globs_ = None , _locs_ = None ) : pass",
        "Output": "def _globs_ ( _code_ , _globs_ = None , _locs_ = None ) : pass",
        "Var_Maps": [
            {
                "_globs_": "var_0",
                "_code_": "var_1",
                "_locs_": "var_2",
                "exec_": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if _globs_ is None : pass",
        "Output": "if _globs_ is None : pass",
        "Var_Maps": [
            {
                "_globs_": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 with an argument 1 , substitute the result for var_1 . [SEP]",
        "reference": "frame = sys . _getframe ( 1 )",
        "Output": "frame = sys . _getframe ( 1 )",
        "Var_Maps": [
            {
                "_getframe": "var_0",
                "frame": "var_1",
                "sys": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_2 . var_0 for var_1 . [SEP]",
        "reference": "_globs_ = frame . f_globals",
        "Output": "_globs_ = frame . f_globals",
        "Var_Maps": [
            {
                "f_globals": "var_0",
                "_globs_": "var_1",
                "frame": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if _locs_ is None : pass",
        "Output": "if _locs_ is None : pass",
        "Var_Maps": [
            {
                "_locs_": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute if var_1 is none for var_1 . [SEP]",
        "reference": "_locs_ = frame . f_locals",
        "Output": "frame = var_3 if frame is None else f_locals",
        "Var_Maps": [
            {
                "f_locals": "var_0",
                "_locs_": "var_1",
                "frame": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] del ##ete var_0 . [SEP]",
        "reference": "del frame",
        "Output": "del frame",
        "Var_Maps": [
            {
                "frame": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] otherwise if var_0 is none , [SEP]",
        "reference": "if True : pass elif _locs_ is None : pass",
        "Output": "if ` True ` : pass elif _locs_ is None : pass",
        "Var_Maps": [
            {
                "_locs_": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 with an argument var_1 . [SEP]",
        "reference": "_locs_ = _globs_",
        "Output": "var_2 = _globs_ ( _locs_ )",
        "Var_Maps": [
            {
                "_globs_": "var_0",
                "_locs_": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 ut ##e code statement str_0 \" var_0 str_0 \" . [SEP]",
        "reference": "exec ( ` exec _code_ in _globs_ , _locs_ ` )",
        "Output": "var_3 . exec ( ` var_2 ` )",
        "Var_Maps": [
            {
                "": "str_0",
                "exec _code_ in _globs_, _locs_": "var_0",
                "exec": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 with an argument string str_0 \" def re ##rai ##se ( t ##p , value , tb = none ) : raise t ##p , value , tb str_0 \" . [SEP]",
        "reference": "exec_ ( ` def reraise ( tp , value , tb = None ) : raise tp , value , tb ` )",
        "Output": "raise exec_ ( ` def reraise ( tp , value , tb = None ) : raise tp , value , tb ` ) from None",
        "Var_Maps": [
            {
                "": "str_0",
                "def reraise(tp, value, tb=None):    raise tp, value, tb": "str_1",
                "def reraise(tp, value, tb=None):     raise tp, value, tb ": "var_0",
                "exec_": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] get attribute str_0 from the var_3 . var_0 object , if it exists substitute it for var_2 , if not var_2 is none . [SEP]",
        "reference": "print_ = getattr ( moves . builtins , ` print ` , None )",
        "Output": "print_ = getattr ( moves . builtins , ` getattr ` , None )",
        "Var_Maps": [
            {
                "print": "var_4",
                "builtins": "var_0",
                "getattr": "var_1",
                "print_": "var_2",
                "moves": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if print_ is None : pass",
        "Output": "if print_ is None : pass",
        "Var_Maps": [
            {
                "print_": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 2 arguments : un ##pack ##ed list var_2 and un ##pack ##ed dictionary var_1 . [SEP]",
        "reference": "def print_ ( * args , * * kwargs ) : pass",
        "Output": "def print_ ( * args , * * kwargs ) : pass",
        "Var_Maps": [
            {
                "print_": "var_0",
                "kwargs": "var_1",
                "args": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] remove ##r str_0 key from the var_0 dictionary , if it exists substitute it for var_5 , if not substitute var_4 . var_1 for var_5 . [SEP]",
        "reference": "fp = kwargs . pop ( ` file ` , sys . stdout )",
        "Output": "fp = kwargs . pop ( ` file ` , sys . stdout )",
        "Var_Maps": [
            {
                "file": "var_2",
                "kwargs": "var_0",
                "stdout": "var_1",
                "pop": "var_3",
                "sys": "var_4",
                "fp": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if fp is None : pass",
        "Output": "if fp is None : pass",
        "Var_Maps": [
            {
                "fp": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] return nothing . [SEP]",
        "reference": "return",
        "Output": "return",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def write ( data ) : pass",
        "Output": "def write ( data ) : pass",
        "Var_Maps": [
            {
                "write": "var_0",
                "data": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 is not an instance of var_1 , [SEP]",
        "reference": "if not isinstance ( data , basestring ) : pass",
        "Output": "if not isinstance ( data , basestring ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "basestring": "var_1",
                "data": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] convert var_0 to var_2 ing , substitute it for var_0 . [SEP]",
        "reference": "data = str ( data )",
        "Output": "data = str ( data )",
        "Var_Maps": [
            {
                "data": "var_1",
                "str": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_6 is an instance of var_4 and var_5 is an instance of var_3 and var_6 . var_2 is not none , [SEP]",
        "reference": "if isinstance ( fp , file ) and isinstance ( data , unicode ) and fp . encoding is not None : pass",
        "Output": "if isinstance ( var_8 , file ) and fp . encoding is not None : pass",
        "Var_Maps": [
            {
                "isinstance": "var_1",
                "encoding": "var_2",
                "unicode": "var_3",
                "file": "var_4",
                "data": "var_5",
                "fp": "var_7"
            }
        ]
    },
    {
        "intent": "[CLS] get str_0 attribute from var_3 object , substitute it for var_1 if it exists , if not var_1 is none . [SEP]",
        "reference": "errors = getattr ( fp , ` errors ` , None )",
        "Output": "var_1 = getattr ( fp , ` errors ` , None )",
        "Var_Maps": [
            {
                "errors": "var_2",
                "getattr": "var_0",
                "fp": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if errors is None : pass",
        "Output": "if errors is None : pass",
        "Var_Maps": [
            {
                "errors": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "errors = ` strict `",
        "Output": "errors = ` strict `",
        "Var_Maps": [
            {
                "strict": "var_1",
                "errors": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_3 . var_1 with 2 arguments : var_5 . var_0 and var_2 , substitute the result for var_3 . [SEP]",
        "reference": "data = data . encode ( fp . encoding , errors )",
        "Output": "data = data . encode ( fp . encoding , data )",
        "Var_Maps": [
            {
                "encoding": "var_0",
                "encode": "var_1",
                "errors": "var_2",
                "data": "var_4",
                "fp": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 var_1 to var_2 . [SEP]",
        "reference": "fp . write ( data )",
        "Output": "fp . write ( data )",
        "Var_Maps": [
            {
                "write": "var_0",
                "data": "var_1",
                "fp": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is boo ##lean false . [SEP]",
        "reference": "want_unicode = False",
        "Output": "want_unicode = ` False `",
        "Var_Maps": [
            {
                "want_unicode": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] remove str_0 key from the var_0 dictionary , if it exists substitute it for var_1 , if not var_1 is none . [SEP]",
        "reference": "sep = kwargs . pop ( ` sep ` , None )",
        "Output": "var_1 = kwargs . sep ( ` pop ` , None )",
        "Var_Maps": [
            {
                "sep": "var_3",
                "kwargs": "var_0",
                "pop": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is not none , [SEP]",
        "reference": "if sep is not None : pass",
        "Output": "if sep is not None : pass",
        "Var_Maps": [
            {
                "sep": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 is an instance of var_1 , [SEP]",
        "reference": "if isinstance ( sep , unicode ) : pass",
        "Output": "if isinstance ( sep , unicode ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "unicode": "var_1",
                "sep": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is boo ##lean true . [SEP]",
        "reference": "want_unicode = True",
        "Output": "want_unicode = ` True `",
        "Var_Maps": [
            {
                "want_unicode": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] otherwise if var_1 is not an instance of var_2 ing type , [SEP]",
        "reference": "if True : pass elif not isinstance ( sep , str ) : pass",
        "Output": "if ` True ` : pass elif not isinstance ( sep , str ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "sep": "var_1",
                "str": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] raise an var_1 exception with an argument string str_0 . [SEP]",
        "reference": "raise Type Error ( ` sep must be None or a string ` )",
        "Output": "raise Type Error ( ` sep must be None or a string ` )",
        "Var_Maps": [
            {
                "sep must be None or a string": "var_0",
                "TypeError": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] remove str_0 key from the var_0 dictionary , if it exists substitute it for var_1 , if not var_1 is none . [SEP]",
        "reference": "end = kwargs . pop ( ` end ` , None )",
        "Output": "var_1 = kwargs . end ( ` pop ` , None )",
        "Var_Maps": [
            {
                "end": "var_3",
                "kwargs": "var_0",
                "pop": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is not none , [SEP]",
        "reference": "if end is not None : pass",
        "Output": "if end is not None : pass",
        "Var_Maps": [
            {
                "end": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 is an instance of var_1 , [SEP]",
        "reference": "if isinstance ( end , unicode ) : pass",
        "Output": "if isinstance ( end , unicode ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "unicode": "var_1",
                "end": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is boo ##lean true . [SEP]",
        "reference": "want_unicode = True",
        "Output": "want_unicode = ` True `",
        "Var_Maps": [
            {
                "want_unicode": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] otherwise if var_1 is not an instance of var_2 ing type , [SEP]",
        "reference": "if True : pass elif not isinstance ( end , str ) : pass",
        "Output": "if ` True ` : pass elif not isinstance ( end , str ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "end": "var_1",
                "str": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] raise an var_1 exception with an argument string str_0 . [SEP]",
        "reference": "raise Type Error ( ` end must be None or a string ` )",
        "Output": "raise Type Error ( ` end must be None or a string ` )",
        "Var_Maps": [
            {
                "end must be None or a string": "var_0",
                "TypeError": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if kwargs : pass",
        "Output": "if kwargs : pass",
        "Var_Maps": [
            {
                "kwargs": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] raise an var_1 exception with an argument string str_0 . [SEP]",
        "reference": "raise Type Error ( ` invalid keyword arguments to print ( ) ` )",
        "Output": "raise Type Error ( ` invalid keyword arguments to print ( ) ` )",
        "Var_Maps": [
            {
                "invalid keyword arguments to print()": "var_0",
                "TypeError": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is false , [SEP]",
        "reference": "if not want_unicode : pass",
        "Output": "if not want_unicode : pass",
        "Var_Maps": [
            {
                "want_unicode": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_1 in var_0 , [SEP]",
        "reference": "for arg in args : pass",
        "Output": "for arg in args : pass",
        "Var_Maps": [
            {
                "args": "var_0",
                "arg": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 is an instance of var_1 , [SEP]",
        "reference": "if isinstance ( arg , unicode ) : pass",
        "Output": "if isinstance ( arg , unicode ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "unicode": "var_1",
                "arg": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is boo ##lean true . [SEP]",
        "reference": "want_unicode = True",
        "Output": "want_unicode = ` True `",
        "Var_Maps": [
            {
                "want_unicode": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] break from the loop execution . [SEP]",
        "reference": "break",
        "Output": "break",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if want_unicode : pass",
        "Output": "if want_unicode : pass",
        "Var_Maps": [
            {
                "want_unicode": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] convert var_0 character to var_1 and substitute the result for var_0 . [SEP]",
        "reference": "newline = unicode ( ` \\ n ` )",
        "Output": "= unicode ( )",
        "Var_Maps": [
            {
                "newline": "var_0",
                "unicode": "var_1",
                "\n": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] convert var_2 white var_1 var_2 character var_2 to var_2 var_0 var_2 and var_2 substitute var_2 the var_2 result var_2 for var_2 var_1 . [SEP]",
        "reference": "space = unicode ( ` ` )",
        "Output": "space = var_3 . unicode ( )",
        "Var_Maps": [
            {
                "unicode": "var_0",
                "space": "var_1",
                " ": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] substitute var_0 character for var_0 . [SEP]",
        "reference": "newline = ` \\ n `",
        "Output": "=",
        "Var_Maps": [
            {
                "newline": "var_0",
                "\n": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 string var_1 str_0 var_1 for var_1 var_0 . [SEP]",
        "reference": "space = ` `",
        "Output": "space = ` var_2 `",
        "Var_Maps": [
            {
                " ": "var_1",
                "space": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if sep is None : pass",
        "Output": "if sep is None : pass",
        "Var_Maps": [
            {
                "sep": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_1 . [SEP]",
        "reference": "sep = space",
        "Output": "sep = space",
        "Var_Maps": [
            {
                "space": "var_0",
                "sep": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none [SEP]",
        "reference": "if end is None : pass",
        "Output": "if end is None : pass",
        "Var_Maps": [
            {
                "end": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute space for var_1 . [SEP]",
        "reference": "end = newline",
        "Output": "end = newline",
        "Var_Maps": [
            {
                "newline": "var_0",
                "end": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_3 and var_2 var_3 n var_0 d var_3 ter ##able var_1 , [SEP]",
        "reference": "for i , arg in enumerate ( args ) : pass",
        "Output": "for i , arg in enumerate ( args ) : pass",
        "Var_Maps": [
            {
                "enumerate": "var_0",
                "args": "var_1",
                "arg": "var_2",
                "i": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 f var_0 var_0 s true , [SEP]",
        "reference": "if i : pass",
        "Output": "if i : pass",
        "Var_Maps": [
            {
                "i": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_1 . [SEP]",
        "reference": "write ( sep )",
        "Output": "write ( sep )",
        "Var_Maps": [
            {
                "write": "var_0",
                "sep": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an var_1 um ##ent var_1 . [SEP]",
        "reference": "write ( arg )",
        "Output": "arg = write ( )",
        "Var_Maps": [
            {
                "write": "var_0",
                "arg": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_1 . [SEP]",
        "reference": "write ( end )",
        "Output": "write ( end )",
        "Var_Maps": [
            {
                "write": "var_0",
                "end": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 with 2 arguments : var_2 and string str_0 \" var_0 str_0 \" . [SEP]",
        "reference": "_add_doc ( reraise , ` Reraise an exception . ` )",
        "Output": "_add_doc ( reraise , ` var_3 ` )",
        "Var_Maps": [
            {
                "": "str_0",
                "Reraise an exception.": "var_0",
                "_add_doc": "var_1",
                "reraise": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 2 arguments var_2 and un ##pack ##ed list var_1 . [SEP]",
        "reference": "def with_metaclass ( meta , * bases ) : pass",
        "Output": "def with_metaclass ( meta , * bases ) : pass",
        "Var_Maps": [
            {
                "with_metaclass": "var_0",
                "bases": "var_1",
                "meta": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] derive the class var_0 form the var_1 base class . [SEP]",
        "reference": "class metaclass ( meta ) : pass",
        "Output": "class metaclass ( meta ) : pass",
        "Var_Maps": [
            {
                "metaclass": "var_0",
                "meta": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_2 . var_0 for var_0 . [SEP]",
        "reference": "__call__ = type . __call__",
        "Output": "__call__ = type . __call__",
        "Var_Maps": [
            {
                "__call__": "var_1",
                "type": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_2 . var_0 for var_0 . [SEP]",
        "reference": "__init__ = type . __init__",
        "Output": "__init__ = type . __init__",
        "Var_Maps": [
            {
                "__init__": "var_1",
                "type": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_4 e ##fine the met ##ho var_4 var_1 with 4 arguments : var_3 , var_2 , var_0 an var_4 var_4 . [SEP]",
        "reference": "def __new__ ( cls , name , this_bases , d ) : pass",
        "Output": "def __new__ ( cls , name , this_bases , d ) : pass",
        "Var_Maps": [
            {
                "this_bases": "var_0",
                "__new__": "var_1",
                "name": "var_2",
                "cls": "var_3",
                "d": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if this_bases is None : pass",
        "Output": "if this_bases is None : pass",
        "Var_Maps": [
            {
                "this_bases": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the met ##ho var_4 var_1 . var_0 with 4 arguments : var_3 , var_2 , empty tu ##ple an var_4 var_4 , return the result . [SEP]",
        "reference": "return type . __new__ ( cls , name , ( ) , d )",
        "Output": "return type . __new__ ( cls , name , ( ) , d )",
        "Var_Maps": [
            {
                "__new__": "var_0",
                "type": "var_1",
                "name": "var_2",
                "cls": "var_3",
                "d": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 with 3 arguments : var_2 , base an var_3 var_3 . [SEP]",
        "reference": "return meta ( name , bases , d )",
        "Output": "meta ( name , bases , d )",
        "Var_Maps": [
            {
                "bases": "var_0",
                "meta": "var_1",
                "name": "var_2",
                "d": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] return an instance of var_1 class , created with 3 arguments : string str_0 , none and an empty dictionary . [SEP]",
        "reference": "return metaclass ( ` temporary_class ` , None , { } )",
        "Output": "return metaclass ( ` temporary_class ` , None )",
        "Var_Maps": [
            {
                "temporary_class": "var_0",
                "metaclass": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def add_metaclass ( metaclass ) : pass",
        "Output": "def add_metaclass ( metaclass ) : pass",
        "Var_Maps": [
            {
                "add_metaclass": "var_0",
                "metaclass": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def wrapper ( cls ) : pass",
        "Output": "def wrapper ( cls ) : pass",
        "Var_Maps": [
            {
                "wrapper": "var_0",
                "cls": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_3 . var_1 . var_2 substitute the result for var_0 . [SEP]",
        "reference": "orig_vars = cls . __dict__ . copy ( )",
        "Output": "orig_vars = cls . __dict__ . copy ( )",
        "Var_Maps": [
            {
                "orig_vars": "var_0",
                "__dict__": "var_1",
                "copy": "var_2",
                "cls": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] remove str_0 key from the var_0 dictionary . [SEP]",
        "reference": "orig_vars . pop ( ` __dict__ ` , None )",
        "Output": "orig_vars . var_3 ( ` __dict__ ` , ` False ` )",
        "Var_Maps": [
            {
                "__dict__": "var_1",
                "orig_vars": "var_0",
                "pop": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] remove str_0 key from the var_1 dictionary . [SEP]",
        "reference": "orig_vars . pop ( ` __weakref__ ` , None )",
        "Output": "orig_vars . pop ( ` __weakref__ ` , None )",
        "Var_Maps": [
            {
                "__weakref__": "var_0",
                "orig_vars": "var_1",
                "pop": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_3 the value under the str_0 key of the var_0 dictionary , substitute it for var_2 . [SEP]",
        "reference": "slots = orig_vars . get ( ` __slots__ ` )",
        "Output": "slots = orig_vars . get ( ` __slots__ ` )",
        "Var_Maps": [
            {
                "__slots__": "var_1",
                "orig_vars": "var_0",
                "slots": "var_2",
                "get": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is not none , [SEP]",
        "reference": "if slots is not None : pass",
        "Output": "if slots is not None : pass",
        "Var_Maps": [
            {
                "slots": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 is an instance of var_2 , [SEP]",
        "reference": "if isinstance ( slots , str ) : pass",
        "Output": "if isinstance ( slots , str ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "slots": "var_1",
                "str": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a list with an element , var_0 . [SEP]",
        "reference": "slots = [ slots ]",
        "Output": "slots = [ slots ]",
        "Var_Maps": [
            {
                "slots": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_0 in var_1 , [SEP]",
        "reference": "for slots_var in slots : pass",
        "Output": "for slots_var in slots : pass",
        "Var_Maps": [
            {
                "slots_var": "var_0",
                "slots": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] remove var_1 key from the var_0 dictionary . [SEP]",
        "reference": "orig_vars . pop ( slots_var )",
        "Output": "orig_vars . pop ( slots_var )",
        "Var_Maps": [
            {
                "orig_vars": "var_0",
                "slots_var": "var_1",
                "pop": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return an instance of var_0 class , created with 3 arguments : var_4 . var_3 , var_4 . var_1 and var_2 . [SEP]",
        "reference": "return metaclass ( cls . __name__ , cls . __bases__ , orig_vars )",
        "Output": "return metaclass ( cls . __name__ , cls . __bases__ , orig_vars )",
        "Var_Maps": [
            {
                "metaclass": "var_0",
                "__bases__": "var_1",
                "orig_vars": "var_2",
                "__name__": "var_3",
                "cls": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return wrapper",
        "Output": "return wrapper",
        "Var_Maps": [
            {
                "wrapper": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if PY3 : pass",
        "Output": "if PY3 : pass",
        "Var_Maps": [
            {
                "PY3": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a st ##rn ##ig str_0 . [SEP]",
        "reference": "_assert Count Equal = ` assert Count Equal `",
        "Output": "_assert Count Equal = ` assert Count Equal `",
        "Var_Maps": [
            {
                "assertCountEqual": "var_1",
                "_assertCountEqual": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a st ##rn ##ig str_0 . [SEP]",
        "reference": "_assert Raises Regex = ` assert Raises Regex `",
        "Output": "_assert Raises Regex = ` assert Raises Regex `",
        "Var_Maps": [
            {
                "assertRaisesRegex": "var_1",
                "_assertRaisesRegex": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a st ##rn ##ig str_0 . [SEP]",
        "reference": "_assert Regex = ` assert Regex `",
        "Output": "_assert Regex = ` assert Regex `",
        "Var_Maps": [
            {
                "assertRegex": "var_1",
                "_assertRegex": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_0 . [SEP]",
        "reference": "memoryview = memoryview",
        "Output": "var_2 . memoryview = memoryview",
        "Var_Maps": [
            {
                "memoryview": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a tu ##ple with 3 elements : var_3 , var_2 and var_1 . [SEP]",
        "reference": "buffer_types = bytes , bytearray , memoryview",
        "Output": "buffer_types = bytes , bytearray , memoryview",
        "Var_Maps": [
            {
                "buffer_types": "var_0",
                "memoryview": "var_1",
                "bytearray": "var_2",
                "bytes": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] var_0 is a st ##rn ##ig str_0 . [SEP]",
        "reference": "_assert Count Equal = ` assert Items Equal `",
        "Output": "_assert Count Equal = ` assert Items Equal `",
        "Var_Maps": [
            {
                "assertItemsEqual": "var_1",
                "_assertCountEqual": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a st ##rn ##ig str_0 . [SEP]",
        "reference": "_assert Raises Regex = ` assert Raises Regexp `",
        "Output": "_assert Raises Regex = ` assert Raises Regexp `",
        "Var_Maps": [
            {
                "assertRaisesRegexp": "var_1",
                "_assertRaisesRegex": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 is a st ##rn ##ig str_0 . [SEP]",
        "reference": "_assert Regex = ` assert Regexp Matches `",
        "Output": "_assert Regex = ` assert Regexp Matches `",
        "Var_Maps": [
            {
                "assertRegexpMatches": "var_0",
                "_assertRegex": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_3 . var_1 starts with a string str_0 , [SEP]",
        "reference": "if sys . platform . startswith ( ` java ` ) : pass",
        "Output": "if sys . platform . startswith ( ` java ` ) : pass",
        "Var_Maps": [
            {
                "java": "var_2",
                "startswith": "var_0",
                "platform": "var_1",
                "sys": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_0 . [SEP]",
        "reference": "memoryview = memoryview",
        "Output": "var_2 . memoryview = memoryview",
        "Var_Maps": [
            {
                "memoryview": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "memoryview = buffer",
        "Output": "memoryview = buffer",
        "Var_Maps": [
            {
                "memoryview": "var_0",
                "buffer": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a tu ##ple with 2 elements var_2 and var_1 . [SEP]",
        "reference": "buffer_types = bytearray , memoryview",
        "Output": "buffer_types = bytearray , memoryview",
        "Var_Maps": [
            {
                "buffer_types": "var_0",
                "memoryview": "var_1",
                "bytearray": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 3 arguments : var_2 , un ##pack ##ed list var_3 and un ##pack ##ed dictionary var_1 . [SEP]",
        "reference": "def assert Count Equal ( self , * args , * * kwargs ) : pass",
        "Output": "def assert Count Equal ( self , * args , * * kwargs ) : pass",
        "Var_Maps": [
            {
                "assertCountEqual": "var_0",
                "kwargs": "var_1",
                "self": "var_2",
                "args": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] get var_0 attribute of the var_3 object , call the result with 2 arguments : un ##pack ##ed list var_4 , [SEP]",
        "reference": "return getattr ( self , _assert Count Equal ) ( * args , * * kwargs )",
        "Output": "return getattr ( self , _assert Count Equal ) ( * args , * * kwargs )",
        "Var_Maps": [
            {
                "_assertCountEqual": "var_0",
                "getattr": "var_1",
                "kwargs": "var_2",
                "self": "var_3",
                "args": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] and un ##pack ##ed dictionary var_1 , return the result . define the function var_0 with 3 arguments : var_2 , un ##pack ##ed list var_3 and un ##pack ##ed dictionary var_1 . [SEP]",
        "reference": "def assert Raises Regex ( self , * args , * * kwargs ) : pass",
        "Output": "def assert Raises Regex ( self , * args , * * kwargs ) : pass",
        "Var_Maps": [
            {
                "assertRaisesRegex": "var_0",
                "kwargs": "var_1",
                "self": "var_2",
                "args": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] get var_0 attribute of the var_3 object , call the result with 2 arguments : un ##pack ##ed list var_4 , [SEP]",
        "reference": "return getattr ( self , _assert Raises Regex ) ( * args , * * kwargs )",
        "Output": "return getattr ( self , _assert Raises Regex ) ( * args , * * kwargs )",
        "Var_Maps": [
            {
                "_assertRaisesRegex": "var_0",
                "getattr": "var_1",
                "kwargs": "var_2",
                "self": "var_3",
                "args": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] and un ##pack ##ed dictionary var_1 , return the result . define the function var_0 with 3 arguments : var_2 , un ##pack ##ed list var_3 and un ##pack ##ed dictionary var_1 . [SEP]",
        "reference": "def assert Regex ( self , * args , * * kwargs ) : pass",
        "Output": "def assert Regex ( self , * args , * * kwargs ) : pass",
        "Var_Maps": [
            {
                "assertRegex": "var_0",
                "kwargs": "var_1",
                "self": "var_2",
                "args": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] get var_0 attribute of the var_3 object , call the result with 2 arguments : un ##pack ##ed list var_4 , [SEP]",
        "reference": "return getattr ( self , _assert Regex ) ( * args , * * kwargs )",
        "Output": "return getattr ( self , _assert Regex ) ( * args , * * kwargs )",
        "Var_Maps": [
            {
                "_assertRegex": "var_0",
                "getattr": "var_1",
                "kwargs": "var_2",
                "self": "var_3",
                "args": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] and un ##pack ##ed dictionary kw ##ar ##gs , return the result . call the function var_2 with 2 arguments : strings str_0 and str_1 , [SEP]",
        "reference": "add_move ( Moved Module ( ` _dummy_thread ` , ` dummy_thread ` ) )",
        "Output": "return add_move ( ` _dummy_thread ` % ( dummy_thread , var_5 ) )",
        "Var_Maps": [
            {
                "_dummy_thread": "var_0",
                "dummy_thread": "var_1",
                "MovedModule": "var_2",
                "add_move": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] use the result as an argument for the call to the var_1 function . call the function var_0 with 2 arguments : strings str_0 and str_1 , [SEP]",
        "reference": "add_move ( Moved Module ( ` _thread ` , ` thread ` ) )",
        "Output": "add_move ( ` thread ` % ( _thread [ ` var_4 ` ] , ) )",
        "Var_Maps": [
            {
                "_thread": "var_2",
                "thread": "var_3",
                "MovedModule": "var_0",
                "add_move": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_0 . [SEP]",
        "reference": "import contextlib",
        "Output": "import contextlib",
        "Var_Maps": [
            {
                "contextlib": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] import var_0 . [SEP]",
        "reference": "import threading",
        "Output": "import threading",
        "Var_Maps": [
            {
                "threading": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] except var_0 . [SEP]",
        "reference": "try : pass except Import Error : pass",
        "Output": "var_1 = Import Error",
        "Var_Maps": [
            {
                "ImportError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] import var_0 as var_1 . [SEP]",
        "reference": "import dummy_threading as threading",
        "Output": "import dummy_threading as threading",
        "Var_Maps": [
            {
                "dummy_threading": "var_0",
                "threading": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] derive the class var_0 from the var_1 base class . [SEP]",
        "reference": "class RWLock ( object ) : pass",
        "Output": "class RWLock ( object ) : pass",
        "Var_Maps": [
            {
                "RWLock": "var_0",
                "object": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def __init__ ( self ) : pass",
        "Output": "def __init__ ( self ) : pass",
        "Var_Maps": [
            {
                "__init__": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_2 , substitute the result for var_3 . var_1 . [SEP]",
        "reference": "self . mutex = threading . RLock ( )",
        "Output": "self . mutex = threading . RLock ( )",
        "Var_Maps": [
            {
                "threading": "var_0",
                "mutex": "var_1",
                "RLock": "var_2",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_1 with an argument integer 0 , substitute the result for var_3 . var_2 . [SEP]",
        "reference": "self . can_read = threading . Semaphore ( 0 )",
        "Output": "self . can_read = threading . Semaphore ( 0 )",
        "Var_Maps": [
            {
                "threading": "var_0",
                "Semaphore": "var_1",
                "can_read": "var_2",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_2 with an argument integer 0 , substitute the result for var_3 . var_0 . [SEP]",
        "reference": "self . can_write = threading . Semaphore ( 0 )",
        "Output": "self . can_write = threading . Semaphore ( 0 )",
        "Var_Maps": [
            {
                "can_write": "var_0",
                "threading": "var_1",
                "Semaphore": "var_2",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 . var_0 is an integer 0 . [SEP]",
        "reference": "self . active_readers = 0",
        "Output": "self . active_readers = 0",
        "Var_Maps": [
            {
                "active_readers": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 . var_0 is an integer 0 . [SEP]",
        "reference": "self . active_writers = 0",
        "Output": "self . active_writers = 0",
        "Var_Maps": [
            {
                "active_writers": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 . var_0 is an integer 0 . [SEP]",
        "reference": "self . waiting_readers = 0",
        "Output": "self . waiting_readers = 0",
        "Var_Maps": [
            {
                "waiting_readers": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 . var_0 is an integer 0 . [SEP]",
        "reference": "self . waiting_writers = 0",
        "Output": "self . waiting_writers = 0",
        "Var_Maps": [
            {
                "waiting_writers": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def reader_enters ( self ) : pass",
        "Output": "def reader_enters ( self ) : pass",
        "Var_Maps": [
            {
                "reader_enters": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] with var_1 . var_0 perform , [SEP]",
        "reference": "with self . mutex : pass",
        "Output": "with self . mutex : pass",
        "Var_Maps": [
            {
                "mutex": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 . var_1 and var_2 . var_0 both equal to integer 0 , [SEP]",
        "reference": "if self . active_writers = = 0 and self . waiting_writers = = 0 : pass",
        "Output": "if self . active_writers = = 0 : pass",
        "Var_Maps": [
            {
                "waiting_writers": "var_0",
                "active_writers": "var_1",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] inc ##rem ##ent var_1 . var_0 by 1 . [SEP]",
        "reference": "self . active_readers + = 1",
        "Output": "self . active_readers + = 1",
        "Var_Maps": [
            {
                "active_readers": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 . var_1 . [SEP]",
        "reference": "self . can_read . release ( )",
        "Output": "self . can_read . release ( )",
        "Var_Maps": [
            {
                "can_read": "var_0",
                "release": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] inc ##rem ##ent var_1 . var_0 by 1 . [SEP]",
        "reference": "self . waiting_readers + = 1",
        "Output": "self . waiting_readers + = 1",
        "Var_Maps": [
            {
                "waiting_readers": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 . var_1 . [SEP]",
        "reference": "self . can_read . acquire ( )",
        "Output": "self . can_read . acquire ( )",
        "Var_Maps": [
            {
                "can_read": "var_0",
                "acquire": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def reader_leaves ( self ) : pass",
        "Output": "def reader_leaves ( self ) : pass",
        "Var_Maps": [
            {
                "reader_leaves": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] with var_1 . var_0 perform , [SEP]",
        "reference": "with self . mutex : pass",
        "Output": "with self . mutex : pass",
        "Var_Maps": [
            {
                "mutex": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] dec ##rem ##ent var_1 . var_0 by integer 1 , [SEP]",
        "reference": "self . active_readers - = 1",
        "Output": "self . active_readers - = 1",
        "Var_Maps": [
            {
                "active_readers": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 . var_1 equals integer 0 and var_2 . var_0 is not equal to integer 0 , [SEP]",
        "reference": "if self . active_readers = = 0 and self . waiting_writers ! = 0 : pass",
        "Output": "if self . active_readers = = 0 and self . waiting_writers ! = 0 : pass",
        "Var_Maps": [
            {
                "waiting_writers": "var_0",
                "active_readers": "var_1",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] inc ##rem ##ent var_1 . var_0 by 1 . [SEP]",
        "reference": "self . active_writers + = 1",
        "Output": "self . active_writers + = 1",
        "Var_Maps": [
            {
                "active_writers": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] dec ##rem ##ent var_1 . var_0 by integer 1 , [SEP]",
        "reference": "self . waiting_writers - = 1",
        "Output": "self . waiting_writers - = 1",
        "Var_Maps": [
            {
                "waiting_writers": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 . var_1 . [SEP]",
        "reference": "self . can_write . release ( )",
        "Output": "self . can_write . release ( )",
        "Var_Maps": [
            {
                "can_write": "var_0",
                "release": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 . var_0 decor ##ator , [SEP]",
        "reference": "@ contextlib . contextmanager def dummy ( ) : pass",
        "Output": "@ contextlib . contextmanager def dummy ( ) : pass",
        "Var_Maps": [
            {
                "contextmanager": "var_0",
                "contextlib": "var_1",
                "dummy": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def reader ( self ) : pass",
        "Output": "def reader ( self ) : pass",
        "Var_Maps": [
            {
                "reader": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_0 . [SEP]",
        "reference": "self . reader_enters ( )",
        "Output": "self . reader_enters ( )",
        "Var_Maps": [
            {
                "reader_enters": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] yield nothing . [SEP]",
        "reference": "yield",
        "Output": "yield",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] finally perform , [SEP]",
        "reference": "try : pass finally : pass",
        "Output": "try : pass finally : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_0 . [SEP]",
        "reference": "self . reader_leaves ( )",
        "Output": "self . reader_leaves ( )",
        "Var_Maps": [
            {
                "reader_leaves": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def writer_enters ( self ) : pass",
        "Output": "def writer_enters ( self ) : pass",
        "Var_Maps": [
            {
                "writer_enters": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] with var_1 . var_0 perform , [SEP]",
        "reference": "with self . mutex : pass",
        "Output": "with self . mutex : pass",
        "Var_Maps": [
            {
                "mutex": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_3 . var_1 equals integer 0 and var_3 . var_0 equals integer 0 and var_3 . var_2 equals integer 0 , [SEP]",
        "reference": "if self . active_writers = = 0 and self . waiting_writers = = 0 and self . active_readers = = 0 : pass",
        "Output": "if self . active_writers = = 0 and self . waiting_writers = = 0 : pass",
        "Var_Maps": [
            {
                "waiting_writers": "var_0",
                "active_writers": "var_1",
                "active_readers": "var_2",
                "self": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] inc ##rem ##ent var_1 . var_0 by integer 1 , [SEP]",
        "reference": "self . active_writers + = 1",
        "Output": "self . active_writers + = 1",
        "Var_Maps": [
            {
                "active_writers": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 . var_1 . [SEP]",
        "reference": "self . can_write . release ( )",
        "Output": "self . can_write . release ( )",
        "Var_Maps": [
            {
                "can_write": "var_0",
                "release": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] inc ##rem ##ent var_1 . var_0 by integer 1 , [SEP]",
        "reference": "self . waiting_writers + = 1",
        "Output": "self . waiting_writers + = 1",
        "Var_Maps": [
            {
                "waiting_writers": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 . var_1 . [SEP]",
        "reference": "self . can_write . acquire ( )",
        "Output": "self . can_write . acquire ( )",
        "Var_Maps": [
            {
                "can_write": "var_0",
                "acquire": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def writer_leaves ( self ) : pass",
        "Output": "def writer_leaves ( self ) : pass",
        "Var_Maps": [
            {
                "writer_leaves": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] with var_1 . var_0 perform , [SEP]",
        "reference": "with self . mutex : pass",
        "Output": "with self . mutex : pass",
        "Var_Maps": [
            {
                "mutex": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] dec ##rem ##ent var_1 . var_0 by integer 1 , [SEP]",
        "reference": "self . active_writers - = 1",
        "Output": "self . active_writers - = 1",
        "Var_Maps": [
            {
                "active_writers": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 . var_0 is not equal to integer 0 , [SEP]",
        "reference": "if self . waiting_writers ! = 0 : pass",
        "Output": "if self . waiting_writers ! = 0 : pass",
        "Var_Maps": [
            {
                "waiting_writers": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] inc ##rem ##ent var_1 . var_0 by integer 1 , [SEP]",
        "reference": "self . active_writers + = 1",
        "Output": "self . active_writers + = 1",
        "Var_Maps": [
            {
                "active_writers": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] dec ##rem ##ent var_1 . var_0 by integer 1 , [SEP]",
        "reference": "self . waiting_writers - = 1",
        "Output": "self . waiting_writers - = 1",
        "Var_Maps": [
            {
                "waiting_writers": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 . var_1 . [SEP]",
        "reference": "self . can_write . release ( )",
        "Output": "self . can_write . release ( )",
        "Var_Maps": [
            {
                "can_write": "var_0",
                "release": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] otherwise if var_1 . var_0 is not equal to integer 0 , [SEP]",
        "reference": "if True : pass elif self . waiting_readers ! = 0 : pass",
        "Output": "if ` True ` : pass elif self . waiting_readers ! = 0 : pass",
        "Var_Maps": [
            {
                "waiting_readers": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] sub ##s var_2 i var_2 u var_2 e var_1 . var_0 for var_2 . [SEP]",
        "reference": "t = self . waiting_readers",
        "Output": "t = self . waiting_readers",
        "Var_Maps": [
            {
                "waiting_readers": "var_0",
                "self": "var_1",
                "t": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 . var_0 is integer 0 . [SEP]",
        "reference": "self . waiting_readers = 0",
        "Output": "self . waiting_readers = 0",
        "Var_Maps": [
            {
                "waiting_readers": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] inc ##rem ##en var_2 var_1 . var_0 by var_2 . [SEP]",
        "reference": "self . active_readers + = t",
        "Output": "self . active_readers + = t",
        "Var_Maps": [
            {
                "active_readers": "var_0",
                "self": "var_1",
                "t": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] while var_0 is gr ##ea var_0 er var_0 han in var_0 e ##ger 0 , [SEP]",
        "reference": "while t > 0 : pass",
        "Output": "while t = = 0 : pass",
        "Var_Maps": [
            {
                "t": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 . var_1 . [SEP]",
        "reference": "self . can_read . release ( )",
        "Output": "self . can_read . release ( )",
        "Var_Maps": [
            {
                "can_read": "var_0",
                "release": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] dec ##rem ##en var_0 var_0 by in var_0 e ##ger 1 , [SEP]",
        "reference": "t - = 1",
        "Output": "var_1 - = 1",
        "Var_Maps": [
            {
                "t": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 . var_0 decor ##ator , [SEP]",
        "reference": "@ contextlib . contextmanager def dummy ( ) : pass",
        "Output": "@ contextlib . contextmanager def dummy ( ) : pass",
        "Var_Maps": [
            {
                "contextmanager": "var_0",
                "contextlib": "var_1",
                "dummy": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def writer ( self ) : pass",
        "Output": "def writer ( self ) : pass",
        "Var_Maps": [
            {
                "writer": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_0 . [SEP]",
        "reference": "self . writer_enters ( )",
        "Output": "self . writer_enters ( )",
        "Var_Maps": [
            {
                "writer_enters": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] yield nothing . [SEP]",
        "reference": "yield",
        "Output": "yield",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] finally perform , [SEP]",
        "reference": "try : pass finally : pass",
        "Output": "try : pass finally : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_0 . [SEP]",
        "reference": "self . writer_leaves ( )",
        "Output": "self . writer_leaves ( )",
        "Var_Maps": [
            {
                "writer_leaves": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . utils import six",
        "Output": "from django . utils import six",
        "Var_Maps": [
            {
                "django.utils": "var_0",
                "six": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a tu ##ple with 8 elements : strings str_0 , str_1 , str_2 , str_3 , str_4 , str_5 , str_6 and st ##r _ 7 . [SEP]",
        "reference": "color_names = ( ` black ` , ` red ` , ` green ` , ` yellow ` , ` blue ` , ` magenta ` , ` cyan ` , ` white ` )",
        "Output": "color_names = ` magenta ` , ` yellow ` , ` black ` , ` green ` , ` white ` , ` blue ` , ` cyan `",
        "Var_Maps": [
            {
                "black": "var_3",
                "red": "var_8",
                "green": "var_4",
                "yellow": "var_2",
                "blue": "var_6",
                "magenta": "var_1",
                "cyan": "var_7",
                "white": "var_5",
                "color_names": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 is a var_3 iona ##ry created with elements : var_5 app ##ended to a string str_0 for value under the key var_5 of var_0 var_3 iona ##ry , [SEP]",
        "reference": "foreground = dict ( ( color_names [ x ] , ` 3 % s ` % x ) for x in range ( 8 ) )",
        "Output": "foreground = dict ( ` range ` % ( var_6 , color_names [ x ] ) for var_6 in color_names [ range ] )",
        "Var_Maps": [
            {
                "3": "str_0",
                "color_names": "var_0",
                "foreground": "var_1",
                "range": "var_2",
                "dict": "var_3",
                "3%s": "var_4",
                "x": "var_7"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_5 in sequence of integers from 0 to 7 . var_1 is a var_3 iona ##ry created with elements : var_5 app ##ended to a string str_0 for value under the key var_5 of var_0 var_3 iona ##ry , [SEP]",
        "reference": "background = dict ( ( color_names [ x ] , ` 4 % s ` % x ) for x in range ( 8 ) )",
        "Output": "background = dict ( ` range ` % x for var_8 in dict ( color_names [ x ] ) )",
        "Var_Maps": [
            {
                "4": "str_0",
                "color_names": "var_0",
                "background": "var_1",
                "range": "var_2",
                "dict": "var_3",
                "4%s": "var_4",
                "x": "var_7"
            }
        ]
    },
    {
        "intent": "[CLS] for every x in sequence of integers from var_1 to 7 . var _ var_1 is a string st ##r _ var_1 . [SEP]",
        "reference": "RESET = ` 0 `",
        "Output": "var_2 = ` RESET `",
        "Var_Maps": [
            {
                "0": "var_1",
                "RESET": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var _ var_6 is an dictionary with var _ var_1 0 elements : str_0 for st ##r _ var_6 , str_2 for str_3 , st ##r _ var _ var _ 9 for st ##r _ var _ var_1 0 , str_6 for st ##r _ var _ 9 , [SEP]",
        "reference": "opt_dict = { ` bold ` : ` 1 ` , ` underscore ` : ` 4 ` , ` blink ` : ` 5 ` , ` reverse ` : ` 7 ` , ` conceal ` : ` 8 ` }",
        "Output": "underscore = { ` blink ` : bold , ` bold ` : opt_dict0 , ` 7 ` : opt_dict , ` reverse ` : bold , ` opt_dict0 ` : 7 , ` conceal ` : bold , ` blink ` : ` 7 ` }",
        "Var_Maps": [
            {
                "1": "var_6",
                "bold": "var_5",
                "4": "var_7",
                "underscore": "var_0",
                "5": "var_8",
                "blink": "var_4",
                "7": "var_9",
                "reverse": "var_2",
                "opt_dict": "var_1",
                "conceal": "var_3",
                "8": "var_10"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an empty list . [SEP]",
        "reference": "code_list = [ ]",
        "Output": "code_list = [ ]",
        "Var_Maps": [
            {
                "code_list": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] format string str_0 with var_1 , return the result . [SEP]",
        "reference": "return ` \\ x1b [ % sm ` % RESET",
        "Output": "return ` \u001b [ % sm ` % RESET",
        "Var_Maps": [
            {
                "\\x1b[%sm": "str_0",
                "\u001b[%sm": "var_0",
                "RESET": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_4 ar _ 2 . var_4 ar _ 0 with an argument var_4 ar _ 1 , for e var_4 er ##y var_4 ar _ 3 and var_4 in the result , [SEP]",
        "reference": "for k , v in six . iteritems ( kwargs ) : pass",
        "Output": "for k , v in six . iteritems ( kwargs ) : pass",
        "Var_Maps": [
            {
                "iteritems": "var_0",
                "kwargs": "var_1",
                "six": "var_2",
                "k": "var_3",
                "v": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 equals a string str_0 , [SEP]",
        "reference": "if k = = ` fg ` : pass",
        "Output": "if k = = ` fg ` : pass",
        "Var_Maps": [
            {
                "fg": "var_0",
                "k": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_3 ar _ 2 var_3 al ##ue under the key var_3 of var_3 ar _ 0 dictionary to var_3 ar _ 1 . [SEP]",
        "reference": "code_list . append ( foreground [ v ] )",
        "Output": "code_list . append ( foreground [ v ] )",
        "Var_Maps": [
            {
                "foreground": "var_0",
                "code_list": "var_1",
                "append": "var_2",
                "v": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] otherwise if var_1 equals a string str_0 , [SEP]",
        "reference": "if True : pass elif k = = ` bg ` : pass",
        "Output": "if ` True ` : pass elif k = = ` bg ` : pass",
        "Var_Maps": [
            {
                "bg": "var_0",
                "k": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_3 ar _ 2 var_3 al ##ue under the key var_3 of var_3 ar _ 0 dictionary to var_3 ar _ 1 . [SEP]",
        "reference": "code_list . append ( background [ v ] )",
        "Output": "code_list . append ( background [ v ] )",
        "Var_Maps": [
            {
                "background": "var_0",
                "code_list": "var_1",
                "append": "var_2",
                "v": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] f var_1 r every var_1 in var_0 , [SEP]",
        "reference": "for o in opts : pass",
        "Output": "if o : pass",
        "Var_Maps": [
            {
                "opts": "var_0",
                "o": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 is c var_1 nt ##aine ##d in var_0 , [SEP]",
        "reference": "if o in opt_dict : pass",
        "Output": "if o in opt_dict : pass",
        "Var_Maps": [
            {
                "opt_dict": "var_0",
                "o": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 value under the 0 key var_3 f the var_1 di ##ct ##i var_3 na ##ry t var_3 var_0 . [SEP]",
        "reference": "code_list . append ( opt_dict [ o ] )",
        "Output": "opt_dict . append ( code_list )",
        "Var_Maps": [
            {
                "code_list": "var_0",
                "opt_dict": "var_1",
                "append": "var_2",
                "o": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if string str_0 is not contained in var_1 , [SEP]",
        "reference": "if ` noreset ` not in opts : pass",
        "Output": "if ` noreset ` not in opts : pass",
        "Var_Maps": [
            {
                "noreset": "var_0",
                "opts": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return the string . define the function var_0 with 2 arguments : var_2 set to an empty tu ##ple and un ##pack ##ed dictionary var_1 . [SEP]",
        "reference": "def make_style ( opts = ( ) , * * kwargs ) : pass",
        "Output": "def make_style ( opts , kwargs = ( ) , * * kwargs ) : pass",
        "Var_Maps": [
            {
                "make_style": "var_0",
                "kwargs": "var_1",
                "opts": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return lambda function with var_2 as argument and return value being result of the function var_0 , called with 3 arguments : var_2 , [SEP]",
        "reference": "return lambda text : colorize ( text , opts , * * kwargs )",
        "Output": "return lambda text : colorize ( text )",
        "Var_Maps": [
            {
                "colorize": "var_0",
                "kwargs": "var_1",
                "text": "var_3",
                "opts": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] opt ##s and un ##pack ##ed dictionary kw ##ar ##gs . var_0 is a string str_0 . [SEP]",
        "reference": "NOCOLOR_PALETTE = ` nocolor `",
        "Output": "NOCOLOR_PALETTE = ` nocolor `",
        "Var_Maps": [
            {
                "nocolor": "var_1",
                "NOCOLOR_PALETTE": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "DARK_PALETTE = ` dark `",
        "Output": "DARK_PALETTE = ` dark `",
        "Var_Maps": [
            {
                "dark": "var_1",
                "DARK_PALETTE": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "LIGHT_PALETTE = ` light `",
        "Output": "LIGHT_PALETTE = ` light `",
        "Var_Maps": [
            {
                "light": "var_1",
                "LIGHT_PALETTE": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] a dictionary with 18 pairs of dictionary value and string keys for var_1 , and a dictionary with 18 pairs of dictionary value and string keys for light _ palette . substitute var_1 for var_0 . [SEP]",
        "reference": "DEFAULT_PALETTE = DARK_PALETTE",
        "Output": "DEFAULT_PALETTE = DARK_PALETTE",
        "Var_Maps": [
            {
                "DEFAULT_PALETTE": "var_0",
                "DARK_PALETTE": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def parse_color_setting ( config_string ) : pass",
        "Output": "def parse_color_setting ( config_string ) : pass",
        "Var_Maps": [
            {
                "parse_color_setting": "var_0",
                "config_string": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is false , [SEP]",
        "reference": "if not config_string : pass",
        "Output": "if not config_string : pass",
        "Var_Maps": [
            {
                "config_string": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] return value under the var_0 key of the var_1 dictionary . [SEP]",
        "reference": "return PALETTES [ DEFAULT_PALETTE ]",
        "Output": "return PALETTES [ DEFAULT_PALETTE ]",
        "Var_Maps": [
            {
                "DEFAULT_PALETTE": "var_0",
                "PALETTES": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] convert var_0 to var_2 case and var_3 it by str_0 character , substitute the result for var_1 . [SEP]",
        "reference": "parts = config_string . lower ( ) . split ( ` ; ` )",
        "Output": "parts = config_string . lower ( ) . split ( ` ; ` )",
        "Var_Maps": [
            {
                ";": "var_4",
                "config_string": "var_0",
                "parts": "var_1",
                "lower": "var_2",
                "split": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] get value under the con ##fi ##g _ string key of the var_1 dictionary , call the var_3 method on the result and substitute it for var_2 . [SEP]",
        "reference": "palette = PALETTES [ NOCOLOR_PALETTE ] . copy ( )",
        "Output": "palette = PALETTES [ ` NOCOLOR_PALETTE ` ] . copy ( ) . copy ( )",
        "Var_Maps": [
            {
                "NOCOLOR_PALETTE": "var_0",
                "PALETTES": "var_1",
                "palette": "var_2",
                "copy": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_1 in var_0 , [SEP]",
        "reference": "for part in parts : pass",
        "Output": "for part in parts : pass",
        "Var_Maps": [
            {
                "parts": "var_0",
                "part": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 is contained in var_0 , [SEP]",
        "reference": "if part in PALETTES : pass",
        "Output": "if part in PALETTES : pass",
        "Var_Maps": [
            {
                "PALETTES": "var_0",
                "part": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] get the value under the var_3 key of the var_0 dictionary , var_2 with it var_1 dictionary . [SEP]",
        "reference": "palette . update ( PALETTES [ part ] )",
        "Output": "PALETTES [ part ] . update ( )",
        "Var_Maps": [
            {
                "PALETTES": "var_0",
                "palette": "var_1",
                "update": "var_2",
                "part": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] otherwise if str_0 is contained in var_0 , [SEP]",
        "reference": "if True : pass elif ` = ` in part : pass",
        "Output": "if ` True ` : pass elif ` = ` in part : pass",
        "Var_Maps": [
            {
                "=": "var_1",
                "part": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an empty dictionary , [SEP]",
        "reference": "definition = { }",
        "Output": "definition = { }",
        "Var_Maps": [
            {
                "definition": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 var_3 by str_0 character , substitute the result for var_2 and var_0 , respectively . [SEP]",
        "reference": "role , instructions = part . split ( ` = ` )",
        "Output": "role , instructions = part . split ( ` = ` )",
        "Var_Maps": [
            {
                "=": "var_4",
                "instructions": "var_0",
                "split": "var_1",
                "role": "var_2",
                "part": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] convert var_1 to var_0 case . [SEP]",
        "reference": "role = role . upper ( )",
        "Output": "role = role . upper ( )",
        "Var_Maps": [
            {
                "upper": "var_0",
                "role": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 var_0 by str_0 character var_3 substitute the result for var_1 . [SEP]",
        "reference": "styles = instructions . split ( ` , ` )",
        "Output": "styles = instructions . split ( ` , ` )",
        "Var_Maps": [
            {
                ",": "var_3",
                "instructions": "var_0",
                "styles": "var_1",
                "split": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 the order of elements of var_1 . [SEP]",
        "reference": "styles . reverse ( )",
        "Output": "styles . reverse ( )",
        "Var_Maps": [
            {
                "reverse": "var_0",
                "styles": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] remove first element from var_1 , var_2 it by the str_0 character , substitute the result for var_0 . [SEP]",
        "reference": "colors = styles . pop ( ) . split ( ` / ` )",
        "Output": "colors = styles . pop ( ) . split ( ` pop ` )",
        "Var_Maps": [
            {
                "/": "var_4",
                "colors": "var_0",
                "styles": "var_1",
                "split": "var_2",
                "pop": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 the order of var_1 elements , [SEP]",
        "reference": "colors . reverse ( )",
        "Output": "colors . reverse ( )",
        "Var_Maps": [
            {
                "reverse": "var_0",
                "colors": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] remove the first element from var_0 , substitute it for var_2 . [SEP]",
        "reference": "fg = colors . pop ( )",
        "Output": "fg = pop . var_3 ( )",
        "Var_Maps": [
            {
                "colors": "var_0",
                "pop": "var_1",
                "fg": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 is contained in var_0 , [SEP]",
        "reference": "if fg in color_names : pass",
        "Output": "if fg in color_names : pass",
        "Var_Maps": [
            {
                "color_names": "var_0",
                "fg": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for value under the str_0 key of var_0 dictionary . [SEP]",
        "reference": "definition [ ` fg ` ] = fg",
        "Output": "definition [ ` fg ` ] = fg",
        "Var_Maps": [
            {
                "fg": "var_2",
                "definition": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 is true and last element of var_1 is contained in var_0 , [SEP]",
        "reference": "if colors and colors [ - 1 ] in color_names : pass",
        "Output": "if colors and colors [ - 1 ] in color_names : pass",
        "Var_Maps": [
            {
                "color_names": "var_0",
                "colors": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute last element of var_1 for value under the str_0 key of var_0 dictionary . [SEP]",
        "reference": "definition [ ` bg ` ] = colors [ - 1 ]",
        "Output": "definition [ ` bg ` ] = colors [ - 1 ]",
        "Var_Maps": [
            {
                "bg": "var_2",
                "definition": "var_0",
                "colors": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_3 i var_5 a var_2 created out of element var_5 var_5 , for every var_5 in var_1 i var_5 var_5 i var_5 in the var_4 of the var_0 dictionary . [SEP]",
        "reference": "opts = tuple ( s for s in styles if s in opt_dict . keys ( ) )",
        "Output": "opts = tuple ( s for s in opt_dict . styles ( ) )",
        "Var_Maps": [
            {
                "opt_dict": "var_0",
                "styles": "var_1",
                "tuple": "var_2",
                "opts": "var_3",
                "keys": "var_4",
                "s": "var_7"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if opts : pass",
        "Output": "if opts : pass",
        "Var_Maps": [
            {
                "opts": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for value under the str_0 key of var_0 dictionary . [SEP]",
        "reference": "definition [ ` opts ` ] = opts",
        "Output": "definition [ ` opts ` ] = opts",
        "Var_Maps": [
            {
                "opts": "var_2",
                "definition": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_3 is contained in value under the var_0 key of the var_2 dictionary and var_1 is true , [SEP]",
        "reference": "if role in PALETTES [ NOCOLOR_PALETTE ] and definition : pass",
        "Output": "if role in PALETTES [ NOCOLOR_PALETTE ] : pass",
        "Var_Maps": [
            {
                "NOCOLOR_PALETTE": "var_0",
                "definition": "var_1",
                "PALETTES": "var_2",
                "role": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for value under the var_2 key of var_1 dictionary . [SEP]",
        "reference": "palette [ role ] = definition",
        "Output": "palette [ role ] = definition",
        "Var_Maps": [
            {
                "definition": "var_0",
                "palette": "var_1",
                "role": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 equals value under the var_0 key of the var_1 dictionary , [SEP]",
        "reference": "if palette = = PALETTES [ NOCOLOR_PALETTE ] : pass",
        "Output": "if palette = = PALETTES [ NOCOLOR_PALETTE ] : pass",
        "Var_Maps": [
            {
                "NOCOLOR_PALETTE": "var_0",
                "PALETTES": "var_1",
                "palette": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return none . [SEP]",
        "reference": "return None",
        "Output": "return None",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return palette",
        "Output": "return palette",
        "Var_Maps": [
            {
                "palette": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] from var_1 import var_0 into default name space . [SEP]",
        "reference": "from __future__ import unicode_literals",
        "Output": "from __future__ import unicode_literals",
        "Var_Maps": [
            {
                "unicode_literals": "var_0",
                "__future__": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_0 . [SEP]",
        "reference": "import re",
        "Output": "import re",
        "Var_Maps": [
            {
                "re": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_0 . [SEP]",
        "reference": "import unicodedata",
        "Output": "import unicodedata",
        "Var_Maps": [
            {
                "unicodedata": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] from var_1 import var_0 into default name space . [SEP]",
        "reference": "from gzip import Gzip File",
        "Output": "from gzip import Gzip File",
        "Var_Maps": [
            {
                "GzipFile": "var_0",
                "gzip": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_1 import var_0 into default name space . [SEP]",
        "reference": "from io import Bytes IO",
        "Output": "from io import Bytes IO",
        "Var_Maps": [
            {
                "BytesIO": "var_0",
                "io": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_0 . [SEP]",
        "reference": "import warnings",
        "Output": "import warnings",
        "Var_Maps": [
            {
                "warnings": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . utils . deprecation import Removed In Django19Warning",
        "Output": "from django . utils . deprecation import Removed In Django19Warning",
        "Var_Maps": [
            {
                "django.utils.deprecation": "var_0",
                "RemovedInDjango19Warning": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . utils . encoding import force_text",
        "Output": "from django . utils . encoding import force_text",
        "Var_Maps": [
            {
                "django.utils.encoding": "var_0",
                "force_text": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_2 and var_1 into default name space . [SEP]",
        "reference": "from django . utils . functional import allow_lazy , Simple Lazy Object",
        "Output": "from django . utils . functional import allow_lazy , Simple Lazy Object",
        "Var_Maps": [
            {
                "django.utils.functional": "var_0",
                "SimpleLazyObject": "var_1",
                "allow_lazy": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . utils import six",
        "Output": "from django . utils import six",
        "Var_Maps": [
            {
                "django.utils": "var_0",
                "six": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . utils . six . moves import html_entities",
        "Output": "from django . utils . six . moves import html_entities",
        "Var_Maps": [
            {
                "django.utils.six.moves": "var_0",
                "html_entities": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var var_4 0 import var var_4 1 , var var_4 2 as var_4 and var var_4 3 into default name space . [SEP]",
        "reference": "from django . utils . translation import ugettext_lazy , ugettext as _ , pgettext",
        "Output": "from django . utils . translation import ugettext_lazy , ugettext as _",
        "Var_Maps": [
            {
                "django.utils.translation": "var_0",
                "ugettext_lazy": "var_1",
                "ugettext": "var_2",
                "pgettext": "var_3",
                "_": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . utils . safestring import mark_safe",
        "Output": "from django . utils . safestring import mark_safe",
        "Var_Maps": [
            {
                "django.utils.safestring": "var_0",
                "mark_safe": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 . var_1 is true , [SEP]",
        "reference": "if six . PY2 : pass",
        "Output": "if six . PY2 : pass",
        "Var_Maps": [
            {
                "six": "var_0",
                "PY2": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 . [SEP]",
        "reference": "from django . utils . encoding import force_unicode",
        "Output": "from django . utils . encoding import force_unicode",
        "Var_Maps": [
            {
                "django.utils.encoding": "var_0",
                "force_unicode": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if identity lambda function returns false , substitute the var_4 for var_2 , if not call the function var_0 with an argument var_4 , [SEP]",
        "reference": "capfirst = lambda x : x and force_text ( x ) [ 0 ] . upper ( ) + force_text ( x ) [ 1 : ]",
        "Output": "upper = var_5 or var_0 ( var_5 ) or force_text ( var_5 )",
        "Var_Maps": [
            {
                "force_text": "var_1",
                "capfirst": "var_2",
                "upper": "var_3",
                "x": "var_7"
            }
        ]
    },
    {
        "intent": "[CLS] convert the first element of the result to upper ##case , app ##end to it the rest of the result , substitute it for var_2 . call the function var_0 with 3 arguments : var_2 and var_4 . var_1 . [SEP]",
        "reference": "capfirst = allow_lazy ( capfirst , six . text_type )",
        "Output": "capfirst . allow_lazy ( capfirst , six . text_type )",
        "Var_Maps": [
            {
                "allow_lazy": "var_0",
                "text_type": "var_1",
                "capfirst": "var_3",
                "six": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_3 . var_2 with 2 arguments : raw string str_0 and bit ##wise or performed with 2 opera ##nds , [SEP]",
        "reference": "re_words = re . compile ( ` < . * ? > | ( ( ? : \\ \\ w [ - \\ \\ w ] * | & . * ? ; ) + ) ` , re . U | re . S )",
        "Output": "re_words = var_4 . compile ( ` < . * ? > | ( ( ? : \\ w [ - \\ w ] * | & . * ? ; ) + ) ` , re . var_4 )",
        "Var_Maps": [
            {
                "<.*?>|((?:\\w[-\\w]*|&.*?;)+)": "var_0",
                "re_words": "var_1",
                "compile": "var_2",
                "re": "var_5",
                "U": "var_6",
                "S": "var_7"
            }
        ]
    },
    {
        "intent": "[CLS] var_3 . var_6 and var_3 . var _ 7 , substitute the var_3 sul ##t for var_3 _ words . call the function var_3 . var_2 with 2 arguments : raw string str_0 and bit ##wise or performed with 2 opera ##nds , [SEP]",
        "reference": "re_chars = re . compile ( ` < . * ? > | ( . ) ` , re . U | re . S )",
        "Output": "< . * ? > | ( . ) = var_4 . compile ( ` re ` , re . S , re . S )",
        "Var_Maps": [
            {
                "<.*?>|(.)": "var_0",
                "re_chars": "var_1",
                "compile": "var_2",
                "re": "var_5",
                "U": "var_6",
                "S": "var_7"
            }
        ]
    },
    {
        "intent": "[CLS] var_3 . u and var_3 . var_5 , substitute the var_3 sul ##t for var_3 _ char ##s . call the function var_3 . var_1 with 2 arguments : raw string str_0 and bit ##wise or performed with 2 opera ##nds , [SEP]",
        "reference": "re_tag = re . compile ( ` < ( / ) ? ( [ ^ ] + ? ) ( ? : ( \\ \\ s * / ) | . * ? ) ? > ` , re . S )",
        "Output": "< ( / ) ? ( [ ^ ] + ? ) ( ? : ( \\ s * / ) | . * ? ) ? > = var_3 . compile ( ` re_tag ` )",
        "Var_Maps": [
            {
                "<(/)?([^ ]+?)(?:(\\s*/)| .*?)?>": "var_0",
                "compile": "var_1",
                "re_tag": "var_2",
                "re": "var_4",
                "S": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] var_3 . u and var_3 . s , substitute the var_3 sul ##t for var_3 _ char ##s . call the function var_3 . var_1 with an argument raw string str_0 , substitute the var_3 sul ##t for var_0 . [SEP]",
        "reference": "re_newlines = re . compile ( ` \\ \\ r \\ \\ n | \\ \\ r ` )",
        "Output": "re_newlines = re . compile ( ` \\ r \\ n | \\ r ` )",
        "Var_Maps": [
            {
                "\\r\\n|\\r": "var_2",
                "re_newlines": "var_0",
                "compile": "var_1",
                "re": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_3 . var_2 with an argument raw string str_0 , substitute the var_3 sul ##t for var_1 . [SEP]",
        "reference": "re_camel_case = re . compile ( ` ( ( ( ? < = [ a - z ] ) [ A - Z ] ) | ( [ A - Z ] ( ? ! [ A - Z ] | $ ) ) ) ` )",
        "Output": "re_camel_case = re . compile ( ` ( ( ( ? < = [ a - z ] ) [ A - Z ] ) | ( [ A - Z ] ( ? ! [ A - Z ] | $ ) ) ) ` )",
        "Var_Maps": [
            {
                "(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))": "var_0",
                "re_camel_case": "var_1",
                "compile": "var_2",
                "re": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_1 with 2 arguments var_2 and var_0 . [SEP]",
        "reference": "def wrap ( text , width ) : pass",
        "Output": "def wrap ( text , width ) : pass",
        "Var_Maps": [
            {
                "width": "var_0",
                "wrap": "var_1",
                "text": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_1 , substitute the result for var_1 . [SEP]",
        "reference": "text = force_text ( text )",
        "Output": "text = force_text ( text )",
        "Var_Maps": [
            {
                "force_text": "var_0",
                "text": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 . [SEP]",
        "reference": "def _generator ( ) : pass",
        "Output": "def _generator ( ) : pass",
        "Var_Maps": [
            {
                "_generator": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 with an argument boo ##lean true , for every var_1 in the result , [SEP]",
        "reference": "for line in text . splitlines ( True ) : pass",
        "Output": "for line in text . splitlines ( ) : pass",
        "Var_Maps": [
            {
                "splitlines": "var_0",
                "line": "var_1",
                "text": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_5 ends with a new var_5 character substitute var_2 inc ##rem ##ented by integer 1 for var_0 , if not substitute var_2 for var_0 . [SEP]",
        "reference": "max_width = min ( line . endswith ( ` \\ n ` ) and width + 1 or width , width )",
        "Output": "",
        "Var_Maps": [
            {
                "max_width": "var_0",
                "endswith": "var_1",
                "width": "var_4",
                "line": "var_5",
                "min": "var_6",
                "\n": "var_7"
            }
        ]
    },
    {
        "intent": "[CLS] while var_2 gt ##h of var_1 is gr ##ater than var_0 , [SEP]",
        "reference": "while len ( line ) > max_width : pass",
        "Output": "while len ( line ) > max_width : pass",
        "Var_Maps": [
            {
                "max_width": "var_0",
                "line": "var_1",
                "len": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] get var_4 fist var_4 var_0 var_4 inc ##rem ##ented var_4 by var_4 1 var_4 elements var_4 from var_4 var_3 , var_4 find var_4 index var_4 of var_4 the var_4 first var_4 occur ##ren ##ece var_4 of var_4 white var_1 var_4 from var_4 the var_4 right var_4 side , [SEP]",
        "reference": "space = line [ : max_width + 1 ] . rfind ( ` ` ) + 1",
        "Output": "rfind = space [ : 1 ] . rfind ( ) + space [ 1 : ]",
        "Var_Maps": [
            {
                "max_width": "var_0",
                "space": "var_1",
                "rfind": "var_2",
                "line": "var_3",
                " ": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] add integer 1 to it , substitute the result for var_0 . if var_0 equals integer 0 , [SEP]",
        "reference": "if space = = 0 : pass",
        "Output": "if space = = 0 : pass",
        "Var_Maps": [
            {
                "space": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 var_3 first var_3 index var_3 of var_3 white var_0 var_3 occurrence var_3 in var_3 var_1 , var_3 add var_3 integer var_3 1 var_3 to var_3 it , var_3 substitute var_3 the var_3 result var_3 for var_3 var_0 . [SEP]",
        "reference": "space = line . find ( ` ` ) + 1",
        "Output": "space = . find . line ( )",
        "Var_Maps": [
            {
                "space": "var_0",
                "line": "var_1",
                "find": "var_2",
                " ": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 equals integer 0 , [SEP]",
        "reference": "if space = = 0 : pass",
        "Output": "if space = = 0 : pass",
        "Var_Maps": [
            {
                "space": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] yield var_0 . [SEP]",
        "reference": "yield line",
        "Output": "yield line",
        "Var_Maps": [
            {
                "line": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 v var_1 a var_1 r var_1 _ var_1 0 var_1 var_1 i var_1 s var_1 var_1 a var_1 n var_1 var_1 e var_1 m var_1 p var_1 t var_1 y var_1 var_1 s var_1 t var_1 r var_1 i var_1 n var_1 g var_1 . var_1 [SEP]",
        "reference": "line = ` `",
        "Output": "line = ` `",
        "Var_Maps": [
            {
                "line": "var_0",
                "": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] break from the loop execution [SEP]",
        "reference": "break",
        "Output": "break",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] get the first var_0 dec ##rem ##ented with integer 1 elements from string var_1 , app ##end new var_1 character to it , and yield the result . [SEP]",
        "reference": "yield ` % s \\ n ` % line [ : space - 1 ]",
        "Output": "yield space ( line [ : ] ) + ` % s `",
        "Var_Maps": [
            {
                "space": "var_0",
                "line": "var_1",
                "%s\n": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] remove all the elements from var_0 index of var_1 . [SEP]",
        "reference": "line = line [ space : ]",
        "Output": "line = var_1 . var_3 ( space )",
        "Var_Maps": [
            {
                "space": "var_0",
                "line": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_5 ends with a new var_5 character substitute var_2 inc ##rem ##ented by integer 1 for var_0 , if not substitute var_2 for var_0 . [SEP]",
        "reference": "max_width = min ( line . endswith ( ` \\ n ` ) and width + 1 or width , width )",
        "Output": "",
        "Var_Maps": [
            {
                "max_width": "var_0",
                "endswith": "var_1",
                "width": "var_4",
                "line": "var_5",
                "min": "var_6",
                "\n": "var_7"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if line : pass",
        "Output": "if line : pass",
        "Var_Maps": [
            {
                "line": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] yield var_0 . [SEP]",
        "reference": "yield line",
        "Output": "yield line",
        "Var_Maps": [
            {
                "line": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 c var_2 a var_2 l var_2 l var_2 var_2 t var_2 h var_2 e var_2 var_2 f var_2 u var_2 n var_2 c var_2 t var_2 i var_2 o var_2 n var_2 var_2 v var_2 a var_2 r var_2 _ var_2 0 var_2 , var_2 var_2 v var_2 a var_2 r var_2 _ var_2 1 var_2 var_2 t var_2 h var_2 e var_2 var_2 r var_2 e var_2 s var_2 u var_2 l var_2 t var_2 var_2 i var_2 n var_2 t var_2 o var_2 var_2 a var_2 var_2 s var_2 t var_2 r var_2 i var_2 n var_2 g var_2 , var_2 var_2 r var_2 e var_2 t var_2 u var_2 r var_2 n var_2 var_2 t var_2 h var_2 e var_2 var_2 r var_2 e var_2 s var_2 u var_2 l var_2 t var_2 . var_2 [SEP]",
        "reference": "return ` ` . join ( _generator ( ) )",
        "Output": "return ` ` . join ( _generator )",
        "Var_Maps": [
            {
                "_generator": "var_0",
                "join": "var_1",
                "": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with 2 arguments : var_2 and var_4 . var_1 , substitute the result for var_2 . [SEP]",
        "reference": "wrap = allow_lazy ( wrap , six . text_type )",
        "Output": "wrap = allow_lazy ( wrap , six . text_type )",
        "Var_Maps": [
            {
                "allow_lazy": "var_0",
                "text_type": "var_1",
                "wrap": "var_3",
                "six": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] derive the class var_1 form the var_0 class . [SEP]",
        "reference": "class Truncator ( Simple Lazy Object ) : pass",
        "Output": "class Truncator ( Simple Lazy Object ) : pass",
        "Var_Maps": [
            {
                "SimpleLazyObject": "var_0",
                "Truncator": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments : var_1 and var_2 . [SEP]",
        "reference": "def __init__ ( self , text ) : pass",
        "Output": "def __init__ ( self , text ) : pass",
        "Var_Maps": [
            {
                "__init__": "var_0",
                "self": "var_1",
                "text": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 from the base class of the class var_1 , [SEP]",
        "reference": "super ( Truncator , self ) . __init__ ( lambda : force_text ( text ) )",
        "Output": "super ( Truncator , text ) . __init__ ( )",
        "Var_Maps": [
            {
                "force_text": "var_0",
                "Truncator": "var_1",
                "__init__": "var_2",
                "super": "var_3",
                "self": "var_4",
                "text": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] called with with an argument lambda function which returns result of the force _ var_3 function called with an argument var_3 . define the method var_0 with 3 arguments : var_2 , var_3 and var_1 set to none . [SEP]",
        "reference": "def add_truncation_text ( self , text , truncate = None ) : pass",
        "Output": "def add_truncation_text ( self , text , truncate = None ) : pass",
        "Var_Maps": [
            {
                "add_truncation_text": "var_0",
                "truncate": "var_1",
                "self": "var_2",
                "text": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if truncate is None : pass",
        "Output": "if truncate is None : pass",
        "Var_Maps": [
            {
                "truncate": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_3 with an argument str_0 , str_1 , substitute the result for var_2 . [SEP]",
        "reference": "truncate = pgettext ( ` String to return when truncating text ` , ` % ( truncated_text ) s . . . ` )",
        "Output": "truncate = pgettext ( ` % ( truncated_text ) s . . . ` , ` String to return when truncating text ` )",
        "Var_Maps": [
            {
                "String to return when truncating text": "var_0",
                "%(truncated_text)s...": "var_1",
                "truncate": "var_2",
                "pgettext": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_1 , substitute the result for var_1 . [SEP]",
        "reference": "truncate = force_text ( truncate )",
        "Output": "truncate = force_text ( truncate )",
        "Var_Maps": [
            {
                "force_text": "var_0",
                "truncate": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if string str_0 is contained in var_1 , [SEP]",
        "reference": "if ` % ( truncated_text ) s ` in truncate : pass",
        "Output": "if ` % ( truncated_text ) s ` in truncate : pass",
        "Var_Maps": [
            {
                "%(truncated_text)s": "var_0",
                "truncate": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] format var_1 with a dictionary with an element : var_2 for str_0 , return the result . [SEP]",
        "reference": "return truncate % { ` truncated_text ` : text }",
        "Output": "return ` truncated_text ` % { ` var_3 ` : text }",
        "Var_Maps": [
            {
                "truncated_text": "var_0",
                "truncate": "var_1",
                "text": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 ends with var_1 , [SEP]",
        "reference": "if text . endswith ( truncate ) : pass",
        "Output": "if text . endswith ( truncate ) : pass",
        "Var_Maps": [
            {
                "endswith": "var_0",
                "truncate": "var_1",
                "text": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return text",
        "Output": "return text",
        "Var_Maps": [
            {
                "text": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] app ##end var_0 to var_2 , return the result . [SEP]",
        "reference": "return ` % s % s ` % ( text , truncate )",
        "Output": "return text + truncate",
        "Var_Maps": [
            {
                "truncate": "var_0",
                "%s%s": "var_1",
                "text": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_1 with 4 arguments : var_2 , var_4 , var_0 set to none , var_3 set to boo ##lean false . [SEP]",
        "reference": "def chars ( self , num , truncate = None , html = False ) : pass",
        "Output": "def chars ( self , num , truncate = None , html = ` False ` ) : pass",
        "Var_Maps": [
            {
                "truncate": "var_0",
                "chars": "var_1",
                "self": "var_2",
                "html": "var_3",
                "num": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] convert var_2 to an var_1 e ##ger , substitute it for var_0 . [SEP]",
        "reference": "length = int ( num )",
        "Output": "length = int ( num )",
        "Var_Maps": [
            {
                "length": "var_0",
                "int": "var_1",
                "num": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 . var_1 with 2 arguments : string str_0 and var_4 . var_2 , substitute the result for var_3 . [SEP]",
        "reference": "text = unicodedata . normalize ( ` NFC ` , self . _wrapped )",
        "Output": "text = unicodedata . normalize ( ` NFC ` , self . _wrapped )",
        "Var_Maps": [
            {
                "NFC": "var_5",
                "unicodedata": "var_0",
                "normalize": "var_1",
                "_wrapped": "var_2",
                "text": "var_3",
                "self": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "truncate_len = length",
        "Output": "truncate_len = length",
        "Var_Maps": [
            {
                "truncate_len": "var_0",
                "length": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_1 with an argument var_2 , if it evaluate ##s to false , [SEP]",
        "reference": "if not unicodedata . combining ( char ) : pass",
        "Output": "if not unicodedata . combining ( char ) : pass",
        "Var_Maps": [
            {
                "unicodedata": "var_0",
                "combining": "var_1",
                "char": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] dec ##rem ##ent var_0 by integer 1 . [SEP]",
        "reference": "truncate_len - = 1",
        "Output": "truncate_len - = 1",
        "Var_Maps": [
            {
                "truncate_len": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 equals integer 0 . [SEP]",
        "reference": "if truncate_len = = 0 : pass",
        "Output": "if truncate_len = = 0 : pass",
        "Var_Maps": [
            {
                "truncate_len": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] break from the loop execution . [SEP]",
        "reference": "break",
        "Output": "break",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if html : pass",
        "Output": "if html : pass",
        "Var_Maps": [
            {
                "html": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_4 . var_0 with 5 arguments : var_3 , var_2 , var_5 , var_1 and boo ##lean false , return the result . [SEP]",
        "reference": "return self . _truncate_html ( length , truncate , text , truncate_len , False )",
        "Output": "return self . _truncate_html ( length , truncate , text , truncate_len , ` False ` )",
        "Var_Maps": [
            {
                "_truncate_html": "var_0",
                "truncate_len": "var_1",
                "truncate": "var_2",
                "length": "var_3",
                "self": "var_4",
                "text": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_4 . var_1 with 4 arguments : var_3 , var_2 , var_5 and var_0 , return the result . [SEP]",
        "reference": "return self . _text_chars ( length , truncate , text , truncate_len )",
        "Output": "return self . _text_chars ( length , truncate , text , truncate_len )",
        "Var_Maps": [
            {
                "truncate_len": "var_0",
                "_text_chars": "var_1",
                "truncate": "var_2",
                "length": "var_3",
                "self": "var_4",
                "text": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_1 , substitute the result for var_1 . [SEP]",
        "reference": "chars = allow_lazy ( chars )",
        "Output": "chars = allow_lazy ( chars )",
        "Var_Maps": [
            {
                "allow_lazy": "var_0",
                "chars": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_1 with 5 arguments : var_4 , var_3 , var_2 , var_5 and var_0 . [SEP]",
        "reference": "def _text_chars ( self , length , truncate , text , truncate_len ) : pass",
        "Output": "def _text_chars ( self , length , truncate , text , truncate_len ) : pass",
        "Var_Maps": [
            {
                "truncate_len": "var_0",
                "_text_chars": "var_1",
                "truncate": "var_2",
                "length": "var_3",
                "self": "var_4",
                "text": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is integer 0 . [SEP]",
        "reference": "s_len = 0",
        "Output": "s_len = 0",
        "Var_Maps": [
            {
                "s_len": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is none . [SEP]",
        "reference": "end_index = None",
        "Output": "end_index = None",
        "Var_Maps": [
            {
                "end_index": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_3 and var_1 var_3 n var_0 d var_2 , [SEP]",
        "reference": "for i , char in enumerate ( text ) : pass",
        "Output": "for i , char in enumerate ( text ) : pass",
        "Var_Maps": [
            {
                "enumerate": "var_0",
                "char": "var_1",
                "text": "var_2",
                "i": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 . var_1 with an argument var_2 , if it evaluate ##s to true , [SEP]",
        "reference": "if unicodedata . combining ( char ) : pass",
        "Output": "if unicodedata . combining ( char ) : pass",
        "Var_Maps": [
            {
                "unicodedata": "var_0",
                "combining": "var_1",
                "char": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] skip this loop iteration , s [SEP]",
        "reference": "continue",
        "Output": "continue",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] inc ##rem ##ent var_0 by integer 1 , [SEP]",
        "reference": "s_len + = 1",
        "Output": "s_len + = 1",
        "Var_Maps": [
            {
                "s_len": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 is none and var_2 is greater than var_0 , [SEP]",
        "reference": "if end_index is None and s_len > truncate_len : pass",
        "Output": "if end_index is None and s_len > truncate_len : pass",
        "Var_Maps": [
            {
                "truncate_len": "var_0",
                "end_index": "var_1",
                "s_len": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] sub ##st var_1 tu ##te var_1 for var_0 . [SEP]",
        "reference": "end_index = i",
        "Output": "end_index = i",
        "Var_Maps": [
            {
                "end_index": "var_0",
                "i": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 is greater than var_0 , [SEP]",
        "reference": "if s_len > length : pass",
        "Output": "if s_len > length : pass",
        "Var_Maps": [
            {
                "length": "var_0",
                "s_len": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_3 . var_0 with 2 arguments : if var_1 is greater than zero , first var_1 elements of var_4 , [SEP]",
        "reference": "return self . add_truncation_text ( text [ : end_index or 0 ] , truncate )",
        "Output": "self . add_truncation_text ( truncate , truncate = truncate )",
        "Var_Maps": [
            {
                "add_truncation_text": "var_0",
                "end_index": "var_1",
                "truncate": "var_2",
                "self": "var_3",
                "text": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if not an empty string , and tr ##un ##cate , return the result . return var_0 . [SEP]",
        "reference": "return text",
        "Output": "return text",
        "Var_Maps": [
            {
                "text": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_1 with 4 arguments : var_2 , var_4 , var_0 set to none , var_3 set to boo ##lean false . [SEP]",
        "reference": "def words ( self , num , truncate = None , html = False ) : pass",
        "Output": "def words ( self , num , truncate = None , html = ` False ` ) : pass",
        "Var_Maps": [
            {
                "truncate": "var_0",
                "words": "var_1",
                "self": "var_2",
                "html": "var_3",
                "num": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] convert var_2 to an var_1 e ##ger , substitute the result for var_0 . [SEP]",
        "reference": "length = int ( num )",
        "Output": "length = int ( num )",
        "Var_Maps": [
            {
                "length": "var_0",
                "int": "var_1",
                "num": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if html : pass",
        "Output": "if html : pass",
        "Var_Maps": [
            {
                "html": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_5 . var_0 with 5 arguments : var_3 , var_1 , var_5 . var_2 , var_3 and boo ##lean true , return the result . [SEP]",
        "reference": "return self . _truncate_html ( length , truncate , self . _wrapped , length , True )",
        "Output": "return self . _truncate_html ( length , self . _wrapped , length , ` True ` )",
        "Var_Maps": [
            {
                "_truncate_html": "var_0",
                "truncate": "var_1",
                "_wrapped": "var_2",
                "length": "var_4",
                "self": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_3 . var_0 with 2 arguments var_2 and var_1 , return the result . [SEP]",
        "reference": "return self . _text_words ( length , truncate )",
        "Output": "return self . _text_words ( length , truncate )",
        "Var_Maps": [
            {
                "_text_words": "var_0",
                "truncate": "var_1",
                "length": "var_2",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_1 , substitute the result for var_1 . [SEP]",
        "reference": "words = allow_lazy ( words )",
        "Output": "words = allow_lazy ( words )",
        "Var_Maps": [
            {
                "allow_lazy": "var_0",
                "words": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 3 arguments : var_3 , var_2 and var_1 . [SEP]",
        "reference": "def _text_words ( self , length , truncate ) : pass",
        "Output": "def _text_words ( self , length , truncate ) : pass",
        "Var_Maps": [
            {
                "_text_words": "var_0",
                "truncate": "var_1",
                "length": "var_2",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 var_3 . var_0 into var_1 , substitute the result for var_1 . [SEP]",
        "reference": "words = self . _wrapped . split ( )",
        "Output": "var_4 = var_4 . split ( self . _wrapped )",
        "Var_Maps": [
            {
                "_wrapped": "var_0",
                "words": "var_1",
                "split": "var_2",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 of var_1 is greater than var_0 , [SEP]",
        "reference": "if len ( words ) > length : pass",
        "Output": "if len ( words ) > length : pass",
        "Var_Maps": [
            {
                "length": "var_0",
                "words": "var_1",
                "len": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute first var_0 elements of var_1 for var_1 . [SEP]",
        "reference": "words = words [ : length ]",
        "Output": "words = words [ : length ]",
        "Var_Maps": [
            {
                "length": "var_0",
                "words": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call var_5 the var_5 method var_5 var_3 . var_0 var_5 with var_5 2 var_5 arguments : var_5 elements var_5 of var_5 var_2 var_5 var_4 ed var_5 in var_5 a var_5 string , var_5 separated var_5 with var_5 whites ##pace ##s , [SEP]",
        "reference": "return self . add_truncation_text ( ` ` . join ( words ) , truncate )",
        "Output": "truncate [ ` words ` ] = ` self ` . add_truncation_text ( var_6 . words [ ` join ` ] )",
        "Var_Maps": [
            {
                "add_truncation_text": "var_0",
                "truncate": "var_1",
                "words": "var_2",
                "self": "var_3",
                "join": "var_4",
                " ": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] and var_2 tr ##un ##cate , var_2 return var_2 the var_2 result . var_2 var_2 var_2 return var_2 elements var_2 of var_2 var_0 var_2 var_1 ed var_2 in var_2 a var_2 string , var_2 separated var_2 with var_2 whites ##pace ##s . [SEP]",
        "reference": "return ` ` . join ( words )",
        "Output": "return ` join ` . ( words )",
        "Var_Maps": [
            {
                "words": "var_0",
                "join": "var_1",
                " ": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 6 arguments : var_5 , var_3 , var_2 , var_6 , var_1 and var_4 . [SEP]",
        "reference": "def _truncate_html ( self , length , truncate , text , truncate_len , words ) : pass",
        "Output": "def _truncate_html ( self , length , truncate , text , truncate_len , words ) : pass",
        "Var_Maps": [
            {
                "_truncate_html": "var_0",
                "truncate_len": "var_1",
                "truncate": "var_2",
                "length": "var_3",
                "words": "var_4",
                "self": "var_5",
                "text": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 is not empty and var_0 is smaller than or equal to integer 0 , [SEP]",
        "reference": "if words and length < = 0 : pass",
        "Output": "if words and length < = 0 : pass",
        "Var_Maps": [
            {
                "length": "var_0",
                "words": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 r var_0 e var_0 t var_0 u var_0 r var_0 n var_0 var_0 a var_0 n var_0 var_0 e var_0 m var_0 p var_0 t var_0 y var_0 var_0 s var_0 t var_0 r var_0 i var_0 n var_0 g var_0 . var_0 [SEP]",
        "reference": "return ` `",
        "Output": "return ` `",
        "Var_Maps": [
            {
                "": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a tu ##ple with 9 elements : strings str_0 , str_1 , str_2 , str_3 , str_4 , str_5 , str_6 , st ##r _ 7 and st ##r _ 8 . [SEP]",
        "reference": "html4_singlets = ( ` br ` , ` col ` , ` link ` , ` base ` , ` img ` , ` param ` , ` area ` , ` hr ` , ` input ` )",
        "Output": "html4_singlets = ( ` param ` , ` input ` , ` link ` , ` base ` , ` area ` , ` col ` , ` img ` , ` br ` , ` hr ` , ` param ` , ` param0 ` , ` input ` , ` link ` , ` base ` , ` area ` , ` col ` , ` img ` )",
        "Var_Maps": [
            {
                "br": "var_8",
                "col": "var_6",
                "link": "var_3",
                "base": "var_4",
                "img": "var_7",
                "param": "var_1",
                "area": "var_5",
                "hr": "var_9",
                "input": "var_2",
                "html4_singlets": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is equal to integer 0 . [SEP]",
        "reference": "pos = 0",
        "Output": "pos = 0",
        "Var_Maps": [
            {
                "pos": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is equal to integer 0 . [SEP]",
        "reference": "end_text_pos = 0",
        "Output": "end_text_pos = 0",
        "Var_Maps": [
            {
                "end_text_pos": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is equal to integer 0 . [SEP]",
        "reference": "current_len = 0",
        "Output": "current_len = 0",
        "Var_Maps": [
            {
                "current_len": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an empty list . [SEP]",
        "reference": "open_tags = [ ]",
        "Output": "open_tags = [ ]",
        "Var_Maps": [
            {
                "open_tags": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_3 is true , substitute var_0 for var_2 , if not substitute var_1 for var_2 . [SEP]",
        "reference": "regex = re_words if words else re_chars",
        "Output": "regex = words or re_words or re_chars",
        "Var_Maps": [
            {
                "re_words": "var_0",
                "re_chars": "var_1",
                "regex": "var_2",
                "words": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] while var_0 is smaller than or equal to var_1 , [SEP]",
        "reference": "while current_len < = length : pass",
        "Output": "while current_len < = length : pass",
        "Var_Maps": [
            {
                "current_len": "var_0",
                "length": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the var_4 et ##ho ##d var_1 . var_0 with 2 ar ##gu var_4 en ##ts : var_2 and var_3 . [SEP]",
        "reference": "m = regex . search ( text , pos )",
        "Output": "regex . search ( text , pos )",
        "Var_Maps": [
            {
                "search": "var_0",
                "regex": "var_1",
                "text": "var_2",
                "pos": "var_3",
                "m": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is false , [SEP]",
        "reference": "if not m : pass",
        "Output": "if not m : pass",
        "Var_Maps": [
            {
                "m": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] break from the loop execution , [SEP]",
        "reference": "break",
        "Output": "break",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the var_2 et ##ho ##d var_2 . var_1 with an ar ##gu var_2 en ##t integer 0 , substitute the result for var_0 . [SEP]",
        "reference": "pos = m . end ( 0 )",
        "Output": "pos = m . end ( 0 )",
        "Var_Maps": [
            {
                "pos": "var_0",
                "end": "var_1",
                "m": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 . var_0 , if the result evaluate ##s to true , [SEP]",
        "reference": "if m . group ( 1 ) : pass",
        "Output": "if m . group ( ) : pass",
        "Var_Maps": [
            {
                "group": "var_0",
                "m": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] inc ##rem ##ent var_0 by integer 1 , [SEP]",
        "reference": "current_len + = 1",
        "Output": "current_len + = 1",
        "Var_Maps": [
            {
                "current_len": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 equals var_0 , [SEP]",
        "reference": "if current_len = = truncate_len : pass",
        "Output": "if current_len = = truncate_len : pass",
        "Var_Maps": [
            {
                "truncate_len": "var_0",
                "current_len": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "end_text_pos = pos",
        "Output": "end_text_pos = pos",
        "Var_Maps": [
            {
                "end_text_pos": "var_0",
                "pos": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] skip this loop iteration . [SEP]",
        "reference": "continue",
        "Output": "continue",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the var_4 et ##ho ##d var_4 . var_2 with an ar ##gu var_4 en ##t integer 0 , use it as an ar ##gu var_4 en ##t for the call to the var_0 . var_1 function , [SEP]",
        "reference": "tag = re_tag . match ( m . group ( 0 ) )",
        "Output": "re_tag = re_tag . match ( m . group ( 0 ) )",
        "Var_Maps": [
            {
                "re_tag": "var_0",
                "match": "var_1",
                "group": "var_2",
                "tag": "var_3",
                "m": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] substitute the result for var_2 . if var_2 is false or var_1 is greater or equal to var_0 , [SEP]",
        "reference": "if not tag or current_len > = truncate_len : pass",
        "Output": "if not tag or current_len > = truncate_len : pass",
        "Var_Maps": [
            {
                "truncate_len": "var_0",
                "current_len": "var_1",
                "tag": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] skip this loop iteration . [SEP]",
        "reference": "continue",
        "Output": "continue",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the method var_4 . var_3 , substitute the result for var_1 , var_2 and var_0 , respectively . [SEP]",
        "reference": "closing_tag , tagname , self_closing = tag . groups ( )",
        "Output": "closing_tag , tagname , self_closing = tag . groups ( )",
        "Var_Maps": [
            {
                "self_closing": "var_0",
                "closing_tag": "var_1",
                "tagname": "var_2",
                "groups": "var_3",
                "tag": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] convert var_0 to var_2 case , substitute it for var_0 . [SEP]",
        "reference": "tagname = tagname . lower ( )",
        "Output": "tagname = tagname . lower ( )",
        "Var_Maps": [
            {
                "tagname": "var_1",
                "lower": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 is true or var_2 is contained in var_0 , [SEP]",
        "reference": "if self_closing or tagname in html4_singlets : pass",
        "Output": "if self_closing and tagname in html4_singlets : pass",
        "Var_Maps": [
            {
                "html4_singlets": "var_0",
                "self_closing": "var_1",
                "tagname": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] do nothing . [SEP]",
        "reference": "pass",
        "Output": "pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] otherwise if var_0 is true , [SEP]",
        "reference": "if True : pass elif closing_tag : pass",
        "Output": "if ` True ` : pass elif closing_tag : pass",
        "Var_Maps": [
            {
                "closing_tag": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] get the var_2 of the f var_3 rs ##t occurrence of var_1 , sub ##st var_3 tu ##te var_3 t for var_3 . [SEP]",
        "reference": "i = open_tags . index ( tagname )",
        "Output": "i = open_tags . index ( tagname )",
        "Var_Maps": [
            {
                "open_tags": "var_0",
                "tagname": "var_1",
                "index": "var_2",
                "i": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Value Error : pass",
        "Output": "try : pass except Value Error : pass",
        "Var_Maps": [
            {
                "ValueError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] do nothing . [SEP]",
        "reference": "pass",
        "Output": "pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] create a l var_2 st out of var_0 elements form ( var_2 + 1 ) - th var_2 n ##de ##x to the end , sub ##st var_2 tu ##te var_2 t for var_0 . [SEP]",
        "reference": "open_tags = open_tags [ i + 1 : ]",
        "Output": "open_tags = i ( i + 1 )",
        "Var_Maps": [
            {
                "open_tags": "var_1",
                "i": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] var_2 var_1 at the beginning of var_0 . [SEP]",
        "reference": "open_tags . insert ( 0 , tagname )",
        "Output": "open_tags . insert ( 0 , tagname )",
        "Var_Maps": [
            {
                "open_tags": "var_0",
                "tagname": "var_1",
                "insert": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is smaller than or equal to var_1 , [SEP]",
        "reference": "if current_len < = length : pass",
        "Output": "if current_len < = length : pass",
        "Var_Maps": [
            {
                "current_len": "var_0",
                "length": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return text",
        "Output": "return text",
        "Var_Maps": [
            {
                "text": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] create a list var_2 of fist var_0 var_1 el ##em ##nts , sub ##sti ##tu ##e it for var_2 . [SEP]",
        "reference": "out = text [ : end_text_pos ]",
        "Output": "var_3 = [ end_text_pos ] + text",
        "Var_Maps": [
            {
                "end_text_pos": "var_0",
                "text": "var_1",
                "out": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if truncate_text : pass",
        "Output": "if truncate_text : pass",
        "Var_Maps": [
            {
                "truncate_text": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] app ##end var_0 to var_1 . [SEP]",
        "reference": "out + = truncate_text",
        "Output": "out + = truncate_text",
        "Var_Maps": [
            {
                "truncate_text": "var_0",
                "out": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_1 in var_0 , [SEP]",
        "reference": "for tag in open_tags : pass",
        "Output": "for tag in open_tags : pass",
        "Var_Maps": [
            {
                "open_tags": "var_0",
                "tag": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] replace %s in string str_0 with var_2 , app ##end the result to var_1 . [SEP]",
        "reference": "out + = ` < / % s > ` % tag",
        "Output": "out + = ` < / % s > ` % tag",
        "Var_Maps": [
            {
                "</%s>": "var_0",
                "out": "var_1",
                "tag": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return out",
        "Output": "return out",
        "Var_Maps": [
            {
                "out": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def get_valid_filename ( s ) : pass",
        "Output": "def get_valid_filename ( s ) : pass",
        "Var_Maps": [
            {
                "get_valid_filename": "var_0",
                "s": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call ##var var_6 5th ##eva ##r var_6 5 ##fu ##nction ##var var_6 5 ##var var_6 0 ##var var_6 5 ##with ##var var_6 5 ##an ##var var_6 5 ##ar ##gum ##ent ##var var_6 5 ##var var_6 3 , var var_6 5 ##var var_6 2 ##var var_6 5th ##eva ##r var_6 5 ##re ##var var_6 3 ##ult ##var var_6 5 ##of ##var var_6 5 ##w ##hit ##eva ##r var_6 3 ##pace ##var var_6 3 ##var var_6 5 ##fr ##om ##var var_6 5 ##bot ##h ##var var_6 5 ##end ##var var_6 3 , [SEP]",
        "reference": "s = force_text ( s ) . strip ( ) . replace ( ` ` , ` _ ` )",
        "Output": "force_text = s ( ` _ ` . ( ` var_3 ` ) , strip )",
        "Var_Maps": [
            {
                "force_text": "var_0",
                "replace": "var_1",
                "strip": "var_2",
                "s": "var_4",
                " ": "var_5",
                "_": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_2 with 2 arguments : var_0 and var_4 . var_3 , substitute the result for var_0 . [SEP]",
        "reference": "get_valid_filename = allow_lazy ( get_valid_filename , six . text_type )",
        "Output": "get_valid_filename = allow_lazy ( get_valid_filename , six . text_type )",
        "Var_Maps": [
            {
                "get_valid_filename": "var_1",
                "allow_lazy": "var_2",
                "text_type": "var_3",
                "six": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 2 arguments : var_3 and var_2 set to result of the function var_1 called with an argument string str_0 . [SEP]",
        "reference": "def get_text_list ( list_ , last_word = ugettext_lazy ( ` or ` ) ) : pass",
        "Output": "def get_text_list ( list_ , last_word = ugettext_lazy ( ` or ` ) ) : pass",
        "Var_Maps": [
            {
                "or": "var_4",
                "get_text_list": "var_0",
                "ugettext_lazy": "var_1",
                "last_word": "var_2",
                "list_": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] is var_1 gt ##h of var_0 equals integer 0 , [SEP]",
        "reference": "if len ( list_ ) = = 0 : pass",
        "Output": "if len ( list_ ) = = 0 : pass",
        "Var_Maps": [
            {
                "list_": "var_0",
                "len": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 r var_0 e var_0 t var_0 u var_0 r var_0 n var_0 var_0 a var_0 n var_0 var_0 e var_0 m var_0 p var_0 t var_0 y var_0 var_0 s var_0 t var_0 r var_0 i var_0 n var_0 g var_0 . var_0 [SEP]",
        "reference": "return ` `",
        "Output": "return ` `",
        "Var_Maps": [
            {
                "": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 gt ##h of var_0 equals integer 1 , [SEP]",
        "reference": "if len ( list_ ) = = 1 : pass",
        "Output": "if len ( list_ ) = = 1 : pass",
        "Var_Maps": [
            {
                "list_": "var_0",
                "len": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with first element of var_1 as an argument , return the result . [SEP]",
        "reference": "return force_text ( list_ [ 0 ] )",
        "Output": "return force_text ( list_ [ 0 ] )",
        "Var_Maps": [
            {
                "force_text": "var_0",
                "list_": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return a st ##r var_1 0 ##ng st ##rva ##r _ 90 format ##ed w var_1 0 ##th 3 elements : result of the fun ##ct var_1 0 ##on var ##var _ 90 called w var_1 0 ##th an argument var_1 0 , [SEP]",
        "reference": "return ` % s % s % s ` % ( _ ( ` , ` ) . join ( force_text ( i ) for i in list_ [ : - 1 ] ) , force_text ( last_word ) , force_text ( list_ [ - 1 ] ) )",
        "Output": "return ` var_0 ` % var_1 ( var_10 )",
        "Var_Maps": [
            {
                "%s %s %s": "var_4",
                "force_text": "var_2",
                "last_word": "var_3",
                "list_": "var_6",
                "join": "var_7",
                ", ": "var_8",
                "_": "var_9",
                "i": "var_11"
            }
        ]
    },
    {
        "intent": "[CLS] separated by result of the function _ called with an argument string str_0 , for every i in list _ without last element , result of the function force _ text called with an argument last _ word , result of the function force _ text called with an argument : last element of list _ . call the function var_2 with 2 arguments : var_0 and var_4 . var_3 , substitute the result for var_0 . [SEP]",
        "reference": "get_text_list = allow_lazy ( get_text_list , six . text_type )",
        "Output": "get_text_list = allow_lazy ( get_text_list , six . text_type )",
        "Var_Maps": [
            {
                ", ": "str_0",
                "get_text_list": "var_1",
                "allow_lazy": "var_2",
                "text_type": "var_3",
                "six": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def normalize_newlines ( text ) : pass",
        "Output": "def normalize_newlines ( text ) : pass",
        "Var_Maps": [
            {
                "normalize_newlines": "var_0",
                "text": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_1 , substitute the result for var_1 . [SEP]",
        "reference": "text = force_text ( text )",
        "Output": "text = force_text ( text )",
        "Var_Maps": [
            {
                "force_text": "var_0",
                "text": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_2 with 2 arguments : str_0 and var_1 , return the result . [SEP]",
        "reference": "return re_newlines . sub ( ` \\ n ` , text )",
        "Output": "return re_newlines . sub ( ` ` , text )",
        "Var_Maps": [
            {
                "\\n": "str_0",
                "re_newlines": "var_0",
                "text": "var_1",
                "sub": "var_2",
                "\n": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_2 with 2 arguments : var_0 and var_4 . var_3 , substitute the result for var_0 . [SEP]",
        "reference": "normalize_newlines = allow_lazy ( normalize_newlines , six . text_type )",
        "Output": "normalize_newlines = allow_lazy ( normalize_newlines , six . text_type )",
        "Var_Maps": [
            {
                "normalize_newlines": "var_1",
                "allow_lazy": "var_2",
                "text_type": "var_3",
                "six": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def phone2numeric ( phone ) : pass",
        "Output": "def phone2numeric ( phone ) : pass",
        "Var_Maps": [
            {
                "phone2numeric": "var_0",
                "phone": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_2 with an argument var_0 , substitute the result for var_0 . [SEP]",
        "reference": "phone2numeric = allow_lazy ( phone2numeric )",
        "Output": "phone2numeric = allow_lazy ( phone2numeric )",
        "Var_Maps": [
            {
                "phone2numeric": "var_1",
                "allow_lazy": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def compress_string ( s ) : pass",
        "Output": "def compress_string ( s ) : pass",
        "Var_Maps": [
            {
                "compress_string": "var_0",
                "s": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 is an instance of var_0 class . [SEP]",
        "reference": "zbuf = Bytes IO ( )",
        "Output": "zbuf = Bytes IO ( )",
        "Var_Maps": [
            {
                "BytesIO": "var_0",
                "zbuf": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_3 is an instance of var_1 class , created with 3 arguments : var_4 set to string str_0 , var_0 set to integer 6 , [SEP]",
        "reference": "zfile = Gzip File ( mode = ` wb ` , compresslevel = 6 , fileobj = zbuf )",
        "Output": "zfile = Gzip File ( mode = ` fileobj ` , compresslevel = 6 )",
        "Var_Maps": [
            {
                "wb": "var_6",
                "compresslevel": "var_0",
                "GzipFile": "var_1",
                "fileobj": "var_2",
                "zfile": "var_3",
                "mode": "var_4",
                "zbuf": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] and file ##ob ##j var_2 et to z ##bu ##f . call the method var_0 . var_1 with an argument var_2 . [SEP]",
        "reference": "zfile . write ( s )",
        "Output": "zfile . write ( s )",
        "Var_Maps": [
            {
                "zfile": "var_0",
                "write": "var_1",
                "s": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_1 . [SEP]",
        "reference": "zfile . close ( )",
        "Output": "zfile . close ( )",
        "Var_Maps": [
            {
                "zfile": "var_0",
                "close": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_0 , return the result . [SEP]",
        "reference": "return zbuf . getvalue ( )",
        "Output": "return zbuf . getvalue ( )",
        "Var_Maps": [
            {
                "getvalue": "var_0",
                "zbuf": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] derive the class var_0 from the var_1 base class . [SEP]",
        "reference": "class Streaming Buffer ( object ) : pass",
        "Output": "class Streaming Buffer ( object ) : pass",
        "Var_Maps": [
            {
                "StreamingBuffer": "var_0",
                "object": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def __init__ ( self ) : pass",
        "Output": "def __init__ ( self ) : pass",
        "Var_Maps": [
            {
                "__init__": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 . var_1 is an empty list . [SEP]",
        "reference": "self . vals = [ ]",
        "Output": "self . vals = [ ]",
        "Var_Maps": [
            {
                "self": "var_0",
                "vals": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments : var_1 and var_2 . [SEP]",
        "reference": "def write ( self , val ) : pass",
        "Output": "def write ( self , val ) : pass",
        "Var_Maps": [
            {
                "write": "var_0",
                "self": "var_1",
                "val": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 var_3 to var_1 . var_2 . [SEP]",
        "reference": "self . vals . append ( val )",
        "Output": "self . vals . append ( val )",
        "Var_Maps": [
            {
                "append": "var_0",
                "self": "var_1",
                "vals": "var_2",
                "val": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def read ( self ) : pass",
        "Output": "def read ( self ) : pass",
        "Var_Maps": [
            {
                "read": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 elements of var_1 . var_2 into a bytes string , substitute the result for var_3 . [SEP]",
        "reference": "ret = b ` ` . join ( self . vals )",
        "Output": "ret = ` b ` ` ` . join ( self . vals )",
        "Var_Maps": [
            {
                "join": "var_0",
                "self": "var_1",
                "vals": "var_2",
                "ret": "var_3",
                "b''": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 . var_1 is an empty list . [SEP]",
        "reference": "self . vals = [ ]",
        "Output": "self . vals = [ ]",
        "Var_Maps": [
            {
                "self": "var_0",
                "vals": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 ur ##n var_0 . [SEP]",
        "reference": "return ret",
        "Output": "return ret",
        "Var_Maps": [
            {
                "ret": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def flush ( self ) : pass",
        "Output": "def flush ( self ) : pass",
        "Var_Maps": [
            {
                "flush": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return nothing . [SEP]",
        "reference": "return",
        "Output": "return",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def close ( self ) : pass",
        "Output": "def close ( self ) : pass",
        "Var_Maps": [
            {
                "close": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return nothing . [SEP]",
        "reference": "return",
        "Output": "return",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def compress_sequence ( sequence ) : pass",
        "Output": "def compress_sequence ( sequence ) : pass",
        "Var_Maps": [
            {
                "compress_sequence": "var_0",
                "sequence": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 is an instance of var_0 class . [SEP]",
        "reference": "buf = Streaming Buffer ( )",
        "Output": "buf = Streaming Buffer ( )",
        "Var_Maps": [
            {
                "StreamingBuffer": "var_0",
                "buf": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_3 is an instance of var_1 class , created with 3 arguments : var_4 set to string str_0 , var_0 set to integer 6 , [SEP]",
        "reference": "zfile = Gzip File ( mode = ` wb ` , compresslevel = 6 , fileobj = buf )",
        "Output": "zfile = Gzip File ( mode = ` fileobj ` , compresslevel = 6 )",
        "Var_Maps": [
            {
                "wb": "var_6",
                "compresslevel": "var_0",
                "GzipFile": "var_1",
                "fileobj": "var_2",
                "zfile": "var_3",
                "mode": "var_4",
                "buf": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] and file ##ob ##j set to var_1 . var_0 data from var_1 file stream , yield the result . [SEP]",
        "reference": "yield buf . read ( )",
        "Output": "yield buf . read ( )",
        "Var_Maps": [
            {
                "read": "var_0",
                "buf": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_1 in var_0 , [SEP]",
        "reference": "for item in sequence : pass",
        "Output": "for item in sequence : pass",
        "Var_Maps": [
            {
                "sequence": "var_0",
                "item": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 var_2 to var_0 stream . [SEP]",
        "reference": "zfile . write ( item )",
        "Output": "zfile . write ( item )",
        "Var_Maps": [
            {
                "zfile": "var_0",
                "write": "var_1",
                "item": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 var_0 stream buffer . [SEP]",
        "reference": "zfile . flush ( )",
        "Output": "var_2 . flush ( ` zfile ` )",
        "Var_Maps": [
            {
                "zfile": "var_0",
                "flush": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 data from var_1 , yield the result . [SEP]",
        "reference": "yield buf . read ( )",
        "Output": "yield buf . read ( )",
        "Var_Maps": [
            {
                "read": "var_0",
                "buf": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 var_0 stream . [SEP]",
        "reference": "zfile . close ( )",
        "Output": "zfile . close ( )",
        "Var_Maps": [
            {
                "zfile": "var_0",
                "close": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 data from var_1 , yield the result . [SEP]",
        "reference": "yield buf . read ( )",
        "Output": "yield buf . read ( )",
        "Var_Maps": [
            {
                "read": "var_0",
                "buf": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_3 . var_1 with an argument string str_0 , substitute the var_3 sul ##t for var_0 . [SEP]",
        "reference": "ustring_re = re . compile ( ` ( [ \\ x80 - \\ uffff ] ) ` )",
        "Output": "ustring_re = re . compile ( ` ( [ \u0080 - \uffff ] ) ` )",
        "Var_Maps": [
            {
                "([\\u0080-\\uffff])": "str_0",
                "ustring_re": "var_0",
                "compile": "var_1",
                "([\u0080-\uffff])": "var_2",
                "re": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_1 with 2 argument var_2 : var_2 and var_0 var_2 et to boo ##lean fa ##l var_2 e . [SEP]",
        "reference": "def javascript_quote ( s , quote_double_quotes = False ) : pass",
        "Output": "def javascript_quote ( s , quote_double_quotes = ` False ` ) : pass",
        "Var_Maps": [
            {
                "quote_double_quotes": "var_0",
                "javascript_quote": "var_1",
                "s": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 is an string str_0 . [SEP]",
        "reference": "msg = ( ` django . utils . text . javascript_quote ( ) is deprecated . Use django . utils . html . escapejs ( ) instead . ` )",
        "Output": "msg = ` django . utils . text . javascript_quote ( ) is deprecated . Use django . utils . html . escapejs ( ) instead . `",
        "Var_Maps": [
            {
                "django.utils.text.javascript_quote() is deprecated. Use django.utils.html.escapejs() instead.": "var_0",
                "msg": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_2 . var_3 with 3 arguments : var_4 , var_0 and var_1 as integer 2 . [SEP]",
        "reference": "warnings . warn ( msg , Removed In Django19Warning , stacklevel = 2 )",
        "Output": "warnings . warn ( msg , Removed In Django19Warning , stacklevel = 2 )",
        "Var_Maps": [
            {
                "RemovedInDjango19Warning": "var_0",
                "stacklevel": "var_1",
                "warnings": "var_2",
                "warn": "var_3",
                "msg": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_1 with an argument var_0 . [SEP]",
        "reference": "def fix ( match ) : pass",
        "Output": "def fix ( match ) : pass",
        "Var_Maps": [
            {
                "match": "var_0",
                "fix": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] get the unicode representation of result of the method var_1 . var_2 called with an integer 1 , format with in a string str_0 , [SEP]",
        "reference": "return ` \\ \\ u % 04x ` % ord ( match . group ( 1 ) )",
        "Output": "match . group ( ` \\ u % 04x ` % ( 1 , ord . var_4 ( ) ) )",
        "Var_Maps": [
            {
                "\\\\u%04x": "str_0",
                "\\u%04x": "var_0",
                "match": "var_1",
                "group": "var_2",
                "ord": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] return the re var_2 ul ##t . if var_1 of var_2 equal var_2 var_0 , [SEP]",
        "reference": "if type ( s ) = = bytes : pass",
        "Output": "if type ( s ) = = s : pass",
        "Var_Maps": [
            {
                "bytes": "var_0",
                "type": "var_1",
                "s": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 with an argument var_2 tri ##ng var_2 tr _ 0 , var_2 u ##b var_2 ti ##tute the re var_2 ul ##t for var_2 . [SEP]",
        "reference": "s = s . decode ( ` utf - 8 ` )",
        "Output": "var_2 = var_2 . decode ( ` utf - 8 ` )",
        "Var_Maps": [
            {
                "utf-8": "var_1",
                "decode": "var_0",
                "s": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] other ##wi var_3 e if , var_1 of var_3 doe var_3 nt equal to var_2 . var_0 , [SEP]",
        "reference": "if True : pass elif type ( s ) ! = six . text_type : pass",
        "Output": "if ` True ` : pass elif type ( s ) = = six . text_type : pass",
        "Var_Maps": [
            {
                "text_type": "var_0",
                "type": "var_1",
                "six": "var_2",
                "s": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] rai var_1 e an var_0 with an argument var_1 . [SEP]",
        "reference": "raise Type Error ( s )",
        "Output": "raise Type Error ( s )",
        "Var_Maps": [
            {
                "TypeError": "var_0",
                "s": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 every occurrence of var_2 tr _ 0 var_1 var_1 ' . [SEP]",
        "reference": "s = s . replace ( ` \\ \\ ` , ` \\ \\ \\ \\ ` )",
        "Output": "var_2 . replace ( ` \\ \\ ` )",
        "Var_Maps": [
            {
                "\\\\' in s with ": "str_0",
                "replace": "var_0",
                "\\\\": "var_1",
                "s": "var_3",
                "\\": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 every occurrence of var_2 tr _ 0 in var_2 with var_2 tr _ 1 . [SEP]",
        "reference": "s = s . replace ( ` \\ r ` , ` \\ \\ r ` )",
        "Output": "var_2 . replace ( ` \\ r ` )",
        "Var_Maps": [
            {
                "\\r": "var_1",
                "\\\\r": "str_1",
                "replace": "var_0",
                "s": "var_3",
                "\r": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 every occurrence of var_2 tr _ 0 in var_2 with var_2 tr _ 1 . [SEP]",
        "reference": "s = s . replace ( ` \\ n ` , ` \\ \\ n ` )",
        "Output": "var_2 . replace ( ` \\ n ` )",
        "Var_Maps": [
            {
                "\\n": "var_1",
                "\\\\n": "str_1",
                "replace": "var_0",
                "s": "var_3",
                "\n": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 every occurrence of var_2 tr _ 0 in var_2 with var_2 tr _ 1 . [SEP]",
        "reference": "s = s . replace ( ` \\ t ` , ` \\ \\ t ` )",
        "Output": "var_2 . replace ( ` \\ t ` )",
        "Var_Maps": [
            {
                "\\t": "var_1",
                "\\\\t": "str_1",
                "replace": "var_0",
                "s": "var_3",
                "\t": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 every occurrence of var_2 tr _ 0 in var_2 with var_2 tr _ 1 . [SEP]",
        "reference": "s = s . replace ( ` ` ` , ` \\ \\ ` ` )",
        "Output": "var_2 . replace ( ` \\ ` ` )",
        "Var_Maps": [
            {
                "'": "var_4",
                "\\\\'": "str_1",
                "replace": "var_0",
                "\\'": "var_1",
                "s": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 every occurrence of var_3 tr _ 0 in var_3 with var_3 tr _ 1 . [SEP]",
        "reference": "s = s . replace ( ` < / ` , ` < \\ \\ / ` )",
        "Output": "var_3 . replace ( ` < \\ / ` )",
        "Var_Maps": [
            {
                "</": "var_2",
                "<\\\\/": "str_1",
                "replace": "var_0",
                "<\\/": "var_1",
                "s": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if quote_double_quotes : pass",
        "Output": "if quote_double_quotes : pass",
        "Var_Maps": [
            {
                "quote_double_quotes": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 every occurrence of var_2 tr _ 0 in var_2 with var_2 tr _ 1 . [SEP]",
        "reference": "s = s . replace ( ` ` ` , ` & quot ; ` )",
        "Output": "var_2 . replace ( ` & quot ; ` )",
        "Var_Maps": [
            {
                "\"": "var_4",
                "&quot;": "var_1",
                "replace": "var_0",
                "s": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_1 with 2 argument var_3 : var_2 and var_3 , return the re var_3 ul ##t . [SEP]",
        "reference": "return ustring_re . sub ( fix , s )",
        "Output": "return ustring_re . sub ( fix , var_4 )",
        "Var_Maps": [
            {
                "ustring_re": "var_0",
                "sub": "var_1",
                "fix": "var_2",
                "s": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_2 with 2 arguments : var_0 and var_4 . var_3 , substitute the result for var_0 . [SEP]",
        "reference": "javascript_quote = allow_lazy ( javascript_quote , six . text_type )",
        "Output": "javascript_quote = allow_lazy ( javascript_quote , six . text_type )",
        "Var_Maps": [
            {
                "javascript_quote": "var_1",
                "allow_lazy": "var_2",
                "text_type": "var_3",
                "six": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_4 . var_2 with 2 arguments : raw string str_0 ] * ( ? : ( ? : str_1 \\ \\ ] | \\ \\ . ) * str_2 ] * ) + ) | \\ + ) \" , [SEP]",
        "reference": "smart_split_re = re . compile ( ` ( ( ? : [ ^ \\ \\ s \\ ` ` ] * ( ? : ( ? : ` ( ? : [ ^ ` \\ \\ \\ \\ ] | \\ \\ \\ \\ . ) * ` | \\ ` ( ? : [ ^ \\ ` \\ \\ \\ \\ ] | \\ \\ \\ \\ . ) * \\ ` ) [ ^ \\ \\ s \\ ` ` ] * ) + ) | \\ \\ S + ) ` , re . VERBOSE )",
        "Output": "smart_split_re = re . compile ( ` ( ( ? : [ ^ \\ s ` ` ] * ( ? : ( ? : ` ( ? : [ ^ ` \\ \\ ] | \\ \\ . ) * ` | ` ( ? : [ ^ ` \\ \\ ] | \\ \\ . ) * ` ) [ ^ \\ s ` ` ] * ) + ) | \\ S + ) ` % re . VERBOSE )",
        "Var_Maps": [
            {
                "((?:[^\\s'": "str_0",
                "(?:[^": "str_1",
                " | '(?:[^'\\\\]|\\\\.)*')[^\\s'": "str_2",
                "     ((?:         [^\\s'\"]*         (?:             (?:\"(?:[^\"\\\\]|\\\\.)*\" | '(?:[^'\\\\]|\\\\.)*')             [^\\s'\"]*         )+     ) | \\S+) ": "var_0",
                "smart_split_re": "var_1",
                "compile": "var_2",
                "VERBOSE": "var_3",
                "re": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] and re . verb ##ose , substitute the result for var_0 _ re . define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def smart_split ( text ) : pass",
        "Output": "def smart_split ( text ) : pass",
        "Var_Maps": [
            {
                "smart_split": "var_0",
                "text": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_1 , substitute the result for var_1 . [SEP]",
        "reference": "text = force_text ( text )",
        "Output": "text = force_text ( text )",
        "Var_Maps": [
            {
                "force_text": "var_0",
                "text": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_1 with an argument var_2 , for every var_3 in result , [SEP]",
        "reference": "for bit in smart_split_re . finditer ( text ) : pass",
        "Output": "for bit in smart_split_re . finditer ( text ) : pass",
        "Var_Maps": [
            {
                "smart_split_re": "var_0",
                "finditer": "var_1",
                "text": "var_2",
                "bit": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_0 with an argument integer 0 , yield the result . [SEP]",
        "reference": "yield bit . group ( 0 )",
        "Output": "yield bit . group ( 0 )",
        "Var_Maps": [
            {
                "group": "var_0",
                "bit": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def _replace_entity ( match ) : pass",
        "Output": "def _replace_entity ( match ) : pass",
        "Var_Maps": [
            {
                "_replace_entity": "var_0",
                "match": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_1 with an argument integer 1 , substitute the result for var_2 . [SEP]",
        "reference": "text = match . group ( 1 )",
        "Output": "text = match . group ( 1 )",
        "Var_Maps": [
            {
                "match": "var_0",
                "group": "var_1",
                "text": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if first element of var_0 equals str_0 , [SEP]",
        "reference": "if text [ 0 ] = = ` # ` : pass",
        "Output": "if text [ 0 ] = = ` # ` : pass",
        "Var_Maps": [
            {
                "#": "var_1",
                "text": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] remove first element of var_0 . [SEP]",
        "reference": "text = text [ 1 : ]",
        "Output": "var_0 . text ( 0 )",
        "Var_Maps": [
            {
                "text": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] if first element of var_0 is contained in str_0 . [SEP]",
        "reference": "if text [ 0 ] in ` x X ` : pass",
        "Output": "if text [ 0 ] in ` x X ` : pass",
        "Var_Maps": [
            {
                "xX": "var_1",
                "text": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 on ##vert var_0 without first element to he ##xa ##de var_2 im ##al var_1 e ##ger , substitute it for var_2 . [SEP]",
        "reference": "c = int ( text [ 1 : ] , 16 )",
        "Output": "c = text . int ( var_3 [ 0 ] )",
        "Var_Maps": [
            {
                "text": "var_0",
                "int": "var_1",
                "c": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if nor , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] var_2 on ##vert var_0 to an var_1 e ##ger , substitute it for var_2 . [SEP]",
        "reference": "c = int ( text )",
        "Output": "c = int ( text )",
        "Var_Maps": [
            {
                "text": "var_0",
                "int": "var_1",
                "c": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 all the method var_1 . var_0 with an argument var_2 , return the result . [SEP]",
        "reference": "return six . unichr ( c )",
        "Output": "return six . unichr ( c )",
        "Var_Maps": [
            {
                "unichr": "var_0",
                "six": "var_1",
                "c": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Value Error : pass",
        "Output": "try : pass except Value Error : pass",
        "Var_Maps": [
            {
                "ValueError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_1 with an argument integer 0 , return the result . [SEP]",
        "reference": "return match . group ( 0 )",
        "Output": "return match . group ( 0 )",
        "Var_Maps": [
            {
                "match": "var_0",
                "group": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the function var_4 . var_2 with value under the var_3 key of the var_1 . var_0 dictionary , return the result . [SEP]",
        "reference": "return six . unichr ( html_entities . name2codepoint [ text ] )",
        "Output": "return six . unichr ( html_entities . name2codepoint [ text ] )",
        "Var_Maps": [
            {
                "name2codepoint": "var_0",
                "html_entities": "var_1",
                "unichr": "var_2",
                "text": "var_3",
                "six": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if over ##flower ##ror or var_0 exceptions are caught , [SEP]",
        "reference": "try : pass except ( Value Error , Key Error ) : pass",
        "Output": "try : pass except ( Value Error , Key Error ) : pass",
        "Var_Maps": [
            {
                "ValueError": "var_0",
                "KeyError": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_1 with an argument integer 0 , return the result . [SEP]",
        "reference": "return match . group ( 0 )",
        "Output": "return match . group ( 0 )",
        "Var_Maps": [
            {
                "match": "var_0",
                "group": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_3 . var_2 with an argument raw string str_0 , substitute the var_3 sul ##t for var_1 . [SEP]",
        "reference": "_entity_re = re . compile ( ` & ( # ? [ x X ] ? ( ? : [ 0 - 9a - f A - F ] + | \\ \\ w { 1 , 8 } ) ) ; ` )",
        "Output": "_entity_re = re . compile ( ` & ( # ? [ x X ] ? ( ? : [ 0 - 9a - f A - F ] + | \\ w { 1 , 8 } ) ) ; ` )",
        "Var_Maps": [
            {
                "&(#?[xX]?(?:[0-9a-fA-F]+|\\w{1,8}));": "var_0",
                "_entity_re": "var_1",
                "compile": "var_2",
                "re": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def unescape_entities ( text ) : pass",
        "Output": "def unescape_entities ( text ) : pass",
        "Var_Maps": [
            {
                "unescape_entities": "var_0",
                "text": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_3 with 2 arguments : var_0 and var_2 , return the result . [SEP]",
        "reference": "return _entity_re . sub ( _replace_entity , text )",
        "Output": "return _entity_re . sub ( _replace_entity , text )",
        "Var_Maps": [
            {
                "_replace_entity": "var_0",
                "_entity_re": "var_1",
                "text": "var_2",
                "sub": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_2 with 2 arguments : var_0 and var_4 . var_3 , substitute the result for var_0 . [SEP]",
        "reference": "unescape_entities = allow_lazy ( unescape_entities , six . text_type )",
        "Output": "unescape_entities = allow_lazy ( unescape_entities , six . text_type )",
        "Var_Maps": [
            {
                "unescape_entities": "var_1",
                "allow_lazy": "var_2",
                "text_type": "var_3",
                "six": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def unescape_string_literal ( s ) : pass",
        "Output": "def unescape_string_literal ( s ) : pass",
        "Var_Maps": [
            {
                "unescape_string_literal": "var_0",
                "s": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if fir var_1 t element of var_1 i var_1 not contained in var_1 tr _ 0 or la var_1 t element of var_1 i var_1 not equal to fir var_1 t element of var_1 , [SEP]",
        "reference": "if s [ 0 ] not in ` ` \\ ` ` or s [ - 1 ] ! = s [ 0 ] : pass",
        "Output": "if var_1 [ 1 ] not in var_2 [ 0 ] : pass",
        "Var_Maps": [
            {
                "\\\"'": "str_0",
                "\"'": "var_0",
                "s": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] rai var_2 e an var_1 exception wit an argument var_2 tri ##ng var_2 tr _ 0 , where var_2 tr _ 1 i var_2 replaced with var_2 . [SEP]",
        "reference": "raise Value Error ( ` Not a string literal : % r ` % s )",
        "Output": "raise Value Error ( ` Not a string literal : % r ` % s )",
        "Var_Maps": [
            {
                "Not a string literal: %r": "var_0",
                "%r": "str_1",
                "ValueError": "var_1",
                "s": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 u ##b var_1 ti ##tute fir var_1 t element of var_1 for var_0 . [SEP]",
        "reference": "quote = s [ 0 ]",
        "Output": "quote = s [ : 1 ]",
        "Var_Maps": [
            {
                "quote": "var_0",
                "s": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] remove fir var_6 t and la var_6 t element var_6 of var_6 , var_0 every occurrence of var_6 tri ##ng var_6 tr _ 0 format ##ed with var_2 with var_2 , [SEP]",
        "reference": "return s [ 1 : - 1 ] . replace ( ` \\ \\ % s ` % quote , quote ) . replace ( ` \\ \\ \\ \\ ` , ` \\ \\ ` )",
        "Output": "quote . \\ % s ( ` var_0 ` % ( quote , replace ) , ` \\ \\ ` )",
        "Var_Maps": [
            {
                "\\%s": "var_4",
                "replace": "var_1",
                "quote": "var_3",
                "\\\\": "var_5",
                "s": "var_6",
                "\\": "var_7"
            }
        ]
    },
    {
        "intent": "[CLS] replace every occurrence of raw string str_0 \\ \\ ' , return the result . call the function var_2 with an argument var_0 , substitute the result for var_0 . [SEP]",
        "reference": "unescape_string_literal = allow_lazy ( unescape_string_literal )",
        "Output": "unescape_string_literal = allow_lazy ( unescape_string_literal )",
        "Var_Maps": [
            {
                "\\\\' in the result with string ": "str_0",
                "unescape_string_literal": "var_1",
                "allow_lazy": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def slugify ( value ) : pass",
        "Output": "def slugify ( value ) : pass",
        "Var_Maps": [
            {
                "slugify": "var_0",
                "value": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_1 with 2 arguments : string str_0 and var_5 , var_2 the result with 2 arguments : string str_1 , [SEP]",
        "reference": "value = unicodedata . normalize ( ` NFKD ` , value ) . encode ( ` ascii ` , ` ignore ` ) . decode ( ` ascii ` )",
        "Output": "unicodedata . normalize ( ` decode ` , var_5 ) . encode ( ` ignore ` )",
        "Var_Maps": [
            {
                "NFKD": "var_9",
                "ascii": "var_8",
                "unicodedata": "var_0",
                "normalize": "var_1",
                "encode": "var_2",
                "ignore": "var_3",
                "decode": "var_4",
                "value": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] and convert it to lower ##case , var_3 st ##it ##ute the var_4 sul ##t for var_2 . call the function var_4 . var_3 with 3 arguments : string str_0 , string str_1 and var_2 , use the var_4 sul ##t as an argument for the call to the , [SEP]",
        "reference": "return mark_safe ( re . sub ( ` [ - \\ \\ s ] + ` , ` - ` , value ) )",
        "Output": "- = re . sub ( ` [ - \\ s ] + ` , ` mark_safe ` , value )",
        "Var_Maps": [
            {
                "[-\\s]+": "var_1",
                "-": "var_5",
                "mark_safe": "var_0",
                "value": "var_2",
                "sub": "var_3",
                "re": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] mark _ safe function , return the result . call the function var_0 with 2 arguments : var_2 and var_4 . var_1 , substitute the result var_2 . [SEP]",
        "reference": "slugify = allow_lazy ( slugify , six . text_type )",
        "Output": "text_type = allow_lazy ( slugify , six . text_type )",
        "Var_Maps": [
            {
                "allow_lazy": "var_0",
                "text_type": "var_1",
                "slugify": "var_3",
                "six": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def camel_case_to_spaces ( value ) : pass",
        "Output": "def camel_case_to_spaces ( value ) : pass",
        "Var_Maps": [
            {
                "camel_case_to_spaces": "var_0",
                "value": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_4 with 2 arguments : raw string str_0 and var_1 , var_2 the result of whites ##pace ##s from both ends , [SEP]",
        "reference": "return re_camel_case . sub ( ` \\ \\ 1 ` , value ) . strip ( ) . lower ( )",
        "Output": "\\ 1 = re_camel_case . sub ( ` \\ 1 ` , value ) . strip ( )",
        "Var_Maps": [
            {
                " \\1": "var_5",
                "re_camel_case": "var_0",
                "value": "var_1",
                "strip": "var_2",
                "lower": "var_3",
                "sub": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] from var_1 import var_0 into default name space . [SEP]",
        "reference": "from __future__ import unicode_literals",
        "Output": "from __future__ import unicode_literals",
        "Var_Maps": [
            {
                "unicode_literals": "var_0",
                "__future__": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_0 . [SEP]",
        "reference": "import datetime",
        "Output": "import datetime",
        "Var_Maps": [
            {
                "datetime": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . utils . html import avoid_wrapping",
        "Output": "from django . utils . html import avoid_wrapping",
        "Var_Maps": [
            {
                "django.utils.html": "var_0",
                "avoid_wrapping": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 and var_2 into default name space . [SEP]",
        "reference": "from django . utils . timezone import is_aware , utc",
        "Output": "from django . utils . timezone import is_aware , utc",
        "Var_Maps": [
            {
                "django.utils.timezone": "var_0",
                "is_aware": "var_1",
                "utc": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_2 and var_1 into default name space . [SEP]",
        "reference": "from django . utils . translation import ugettext , ungettext_lazy",
        "Output": "from django . utils . translation import ugettext , ungettext_lazy",
        "Var_Maps": [
            {
                "django.utils.translation": "var_0",
                "ungettext_lazy": "var_1",
                "ugettext": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_3 e ##fine the function var_0 with var_3 , var_2 var_3 e ##fa ##ult ##ing to none , var_1 var_3 e ##fa ##ult ##ing to false as arguments . [SEP]",
        "reference": "def timesince ( d , now = None , reversed = False ) : pass",
        "Output": "def timesince ( d , now = None , reversed = ` False ` ) : pass",
        "Var_Maps": [
            {
                "timesince": "var_0",
                "reversed": "var_1",
                "now": "var_2",
                "d": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_3 is not an instance of var_1 . var_1 , [SEP]",
        "reference": "if not isinstance ( d , datetime . datetime ) : pass",
        "Output": "if not isinstance ( d , datetime . datetime ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "datetime": "var_2",
                "d": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 . var_0 with 3 arguments , var_5 . var_3 , var_5 . var_2 an var_5 var_5 . var_4 , substitute the result for var_5 . [SEP]",
        "reference": "d = datetime . datetime ( d . year , d . month , d . day )",
        "Output": "var_6 = datetime . datetime ( var_6 . year , var_6 . month )",
        "Var_Maps": [
            {
                "datetime": "var_1",
                "month": "var_2",
                "year": "var_3",
                "day": "var_4",
                "d": "var_8"
            }
        ]
    },
    {
        "intent": "[CLS] if var_3 equals to boo ##lean true and var_3 is not an instance of var_1 . var_1 , [SEP]",
        "reference": "if now and not isinstance ( now , datetime . datetime ) : pass",
        "Output": "if now = = datetime . datetime and not isinstance ( now , datetime . datetime ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "datetime": "var_2",
                "now": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 . var_0 with 3 arguments , var_4 . var_3 , var_4 . var_2 and var_4 . var _ 8 , substitute the result for var_4 . [SEP]",
        "reference": "now = datetime . datetime ( now . year , now . month , now . day )",
        "Output": "var_6 = datetime . var_0 ( var_6 . year , var_6 . month , var_6 . day )",
        "Var_Maps": [
            {
                "datetime": "var_1",
                "month": "var_2",
                "year": "var_3",
                "now": "var_7",
                "day": "var_8"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is false , [SEP]",
        "reference": "if not now : pass",
        "Output": "if not now : pass",
        "Var_Maps": [
            {
                "now": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 . var_0 with var_5 as argument if call to the var_2 ( var_6 ) returns true , if not none is the argument , store the result in var_3 . [SEP]",
        "reference": "now = datetime . datetime . now ( utc if is_aware ( d ) else None )",
        "Output": "var_3 = datetime . datetime ( d , None )",
        "Var_Maps": [
            {
                "datetime": "var_1",
                "is_aware": "var_2",
                "now": "var_4",
                "utc": "var_5",
                "d": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true substitute var_4 if ##ference of var_4 an var_4 var_2 for var_1 , if not substitute the var_4 if ##ference of var_2 an var_4 var_4 for var_1 . [SEP]",
        "reference": "delta = d - now if reversed else now - d",
        "Output": "delta = d + var_4 ( now ) if reversed else var_4",
        "Var_Maps": [
            {
                "reversed": "var_0",
                "delta": "var_1",
                "now": "var_3",
                "d": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] multi ##ply var_2 . var_4 , integer 24 , integer 60 and integer 60 add var_2 . var_0 to it , substitute the result for var_1 . [SEP]",
        "reference": "since = delta . days * 24 * 60 * 60 + delta . seconds",
        "Output": "since = delta . days * 60 + delta . seconds",
        "Var_Maps": [
            {
                "seconds": "var_0",
                "since": "var_1",
                "delta": "var_3",
                "days": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is lesser or equal to integer 0 , [SEP]",
        "reference": "if since < = 0 : pass",
        "Output": "if since > = 0 : pass",
        "Var_Maps": [
            {
                "since": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_2 with str_0 as argument , use the result as the argument for the call to the var_0 function , return the result . [SEP]",
        "reference": "return avoid_wrapping ( ugettext ( ` 0 minutes ` ) )",
        "Output": "return avoid_wrapping ( ugettext ( ` 0 minutes ` ) )",
        "Var_Maps": [
            {
                "0 minutes": "var_1",
                "avoid_wrapping": "var_0",
                "ugettext": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_4 and tu ##ple con ##ta var_4 n var_4 ng 2 elements : var_1 and var_3 , var_4 n var_0 d var_2 , [SEP]",
        "reference": "for i , ( seconds , name ) in enumerate ( chunks ) : pass",
        "Output": "for i , ( seconds , name ) in enumerate ( chunks ) : pass",
        "Var_Maps": [
            {
                "enumerate": "var_0",
                "seconds": "var_1",
                "chunks": "var_2",
                "name": "var_3",
                "i": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] divide var_2 by var_0 , store the floor ##ed result in var_1 . [SEP]",
        "reference": "count = since / / seconds",
        "Output": "count = since / / seconds",
        "Var_Maps": [
            {
                "seconds": "var_0",
                "count": "var_1",
                "since": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 does not equals to integer 0 , [SEP]",
        "reference": "if count ! = 0 : pass",
        "Output": "if count ! = 0 : pass",
        "Var_Maps": [
            {
                "count": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] break the execution of the smallest en ##cl ##osing loop . [SEP]",
        "reference": "break",
        "Output": "break",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] use the remainder of the division of var_3 by var_2 as the argument for the call to the var_0 function , store the var_1 in var_1 . [SEP]",
        "reference": "result = avoid_wrapping ( name % count )",
        "Output": "result = avoid_wrapping ( name / / count [ 1 ] )",
        "Var_Maps": [
            {
                "avoid_wrapping": "var_0",
                "result": "var_1",
                "count": "var_2",
                "name": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 f var_2 var_2 nc ##rem ##ented by 1 var_2 s lesser than var_1 gt ##h of var_0 , [SEP]",
        "reference": "if i + 1 < len ( chunks ) : pass",
        "Output": "",
        "Var_Maps": [
            {
                "chunks": "var_0",
                "len": "var_1",
                "i": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] get the element of var_1 at the ( var_3 + 1 ) - the var_3 n ##de ##x , ass var_3 g ##n var_3 t to the var_0 and var_2 , respect var_3 ve ##ly . [SEP]",
        "reference": "seconds2 , name2 = chunks [ i + 1 ]",
        "Output": "seconds2 , name2 = chunks [ 1 ]",
        "Var_Maps": [
            {
                "seconds2": "var_0",
                "chunks": "var_1",
                "name2": "var_2",
                "i": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] multi ##ply var_1 by var_4 , sub ##tra ##ct it from var_3 , divide the result by var_0 , store the floor ##ed result in var_2 . [SEP]",
        "reference": "count2 = ( since - seconds * count ) / / seconds2",
        "Output": "count2 = since * ( seconds - count )",
        "Var_Maps": [
            {
                "seconds2": "var_0",
                "seconds": "var_1",
                "count2": "var_2",
                "since": "var_3",
                "count": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 does not equals to integer 0 , [SEP]",
        "reference": "if count2 ! = 0 : pass",
        "Output": "if count2 ! = 0 : pass",
        "Var_Maps": [
            {
                "count2": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call var_0 function with var_4 mod ##ulus var_3 as argument var_5 call the var_1 with str_0 as argument var_5 add previous 2 var_2 s var_5 inc ##rem ##ent variable var_2 by it . [SEP]",
        "reference": "result + = ugettext ( ` , ` ) + avoid_wrapping ( name2 % count2 )",
        "Output": "result = avoid_wrapping ( name2 ) + ugettext ( result )",
        "Var_Maps": [
            {
                ", ": "var_5",
                "avoid_wrapping": "var_0",
                "ugettext": "var_1",
                "result": "var_2",
                "count2": "var_3",
                "name2": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return result",
        "Output": "return result",
        "Var_Maps": [
            {
                "result": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 e ##fine the function var_0 with 2 arguments , var_2 an var_2 var_1 var_2 e ##fa ##ult ##ing to none . [SEP]",
        "reference": "def timeuntil ( d , now = None ) : pass",
        "Output": "def timeuntil ( d , now = None ) : pass",
        "Var_Maps": [
            {
                "timeuntil": "var_0",
                "now": "var_1",
                "d": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] evaluate the function var_0 with var_3 , var_2 an var_3 var_1 set to boo ##lean true as arguments , return the result . [SEP]",
        "reference": "return timesince ( d , now , reversed = True )",
        "Output": "return timesince ( d , now , reversed = ` True ` )",
        "Var_Maps": [
            {
                "timesince": "var_0",
                "reversed": "var_1",
                "now": "var_2",
                "d": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] from var_1 import var_1 , var_0 and var_3 into default name space . [SEP]",
        "reference": "from datetime import datetime , timedelta , tzinfo",
        "Output": "from var_1 import datetime , timedelta , tzinfo",
        "Var_Maps": [
            {
                "timedelta": "var_0",
                "datetime": "var_2",
                "tzinfo": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from threading import local",
        "Output": "from threading import local",
        "Var_Maps": [
            {
                "threading": "var_0",
                "local": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_0 . [SEP]",
        "reference": "import sys",
        "Output": "import sys",
        "Var_Maps": [
            {
                "sys": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_1 as var_0 . [SEP]",
        "reference": "import time as _time",
        "Output": "import time as _time",
        "Var_Maps": [
            {
                "_time": "var_0",
                "time": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] import var_0 . [SEP]",
        "reference": "import pytz",
        "Output": "import pytz",
        "Var_Maps": [
            {
                "pytz": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Import Error : pass",
        "Output": "try : pass except Import Error : pass",
        "Var_Maps": [
            {
                "ImportError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is none . [SEP]",
        "reference": "pytz = None",
        "Output": "pytz = None",
        "Var_Maps": [
            {
                "pytz": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . conf import settings",
        "Output": "from django . conf import settings",
        "Var_Maps": [
            {
                "django.conf": "var_0",
                "settings": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . utils import six",
        "Output": "from django . utils import six",
        "Var_Maps": [
            {
                "django.utils": "var_0",
                "six": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 3 is a list with 15 elements : strings str_0 , str_1 , str_2 , str_3 , str_4 , str_5 , str_6 , st ##r _ 7 , st ##r _ 8 , st ##r _ 9 , str_1 0 , str_1 1 , str_1 2 , str_1 3 and str_1 4 . [SEP]",
        "reference": "__all__ = [ ` utc ` , ` get_fixed_timezone ` , ` get_default_timezone ` , ` get_default_timezone_name ` , ` get_current_timezone ` , ` get_current_timezone_name ` , ` activate ` , ` deactivate ` , ` override ` , ` localtime ` , ` now ` , ` is_aware ` , ` is_naive ` , ` make_aware ` , ` make_naive ` ]",
        "Output": "get_current_timezone_name6 = [ ` localtime ` , ` get_current_timezone_name0 ` , ` make_naive ` , ` get_current_timezone_name0 ` , ` get_current_timezone ` , ` get_fixed_timezone ` , ` deactivate ` , ` get_current_timezone_name ` , ` make_aware ` , ` make_naive ` , ` localtime ` , ` activate ` , ` get_default_timezone ` , ` get_current_timezone ` , ` get_fixed_timezone ` , ` deactivate ` , ` localtime ` , ` activate ` , ` get_current_timezone_name ` , ` get_default_timezone_name ` , ` get_current_timezone_name0 ` , ` get_current_timezone_name1 ` , ` get_current_timezone_name2 ` ]",
        "Var_Maps": [
            {
                "utc": "var_14",
                "get_fixed_timezone": "var_4",
                "get_default_timezone": "var_2",
                "get_default_timezone_name": "var_0",
                "get_current_timezone": "var_3",
                "get_current_timezone_name": "var_1",
                "activate": "var_9",
                "deactivate": "var_5",
                "override": "var_10",
                "localtime": "var_8",
                "now": "var_15",
                "is_aware": "var_11",
                "is_naive": "var_12",
                "make_aware": "var_6",
                "make_naive": "var_7",
                "__all__": "var_13"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument integer 0 , substitute the result for var_1 . [SEP]",
        "reference": "ZERO = timedelta ( 0 )",
        "Output": "ZERO = timedelta ( 0 )",
        "Var_Maps": [
            {
                "timedelta": "var_0",
                "ZERO": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] derive the class var_1 from the var_0 base class . [SEP]",
        "reference": "class UTC ( tzinfo ) : pass",
        "Output": "class UTC ( tzinfo ) : pass",
        "Var_Maps": [
            {
                "tzinfo": "var_0",
                "UTC": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def __repr__ ( self ) : pass",
        "Output": "def __repr__ ( self ) : pass",
        "Var_Maps": [
            {
                "__repr__": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return a string str_0 . [SEP]",
        "reference": "return ` < UTC > `",
        "Output": "return ` < UTC > `",
        "Var_Maps": [
            {
                "<UTC>": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments var_1 and var_2 . [SEP]",
        "reference": "def utcoffset ( self , dt ) : pass",
        "Output": "def utcoffset ( self , dt ) : pass",
        "Var_Maps": [
            {
                "utcoffset": "var_0",
                "self": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return ZERO",
        "Output": "return ZERO",
        "Var_Maps": [
            {
                "ZERO": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments var_1 and var_2 . [SEP]",
        "reference": "def tzname ( self , dt ) : pass",
        "Output": "def tzname ( self , dt ) : pass",
        "Var_Maps": [
            {
                "tzname": "var_0",
                "self": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return a string str_0 . [SEP]",
        "reference": "return ` UTC `",
        "Output": "return ` UTC `",
        "Var_Maps": [
            {
                "UTC": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_1 with 2 arguments var_0 and var_2 . [SEP]",
        "reference": "def dst ( self , dt ) : pass",
        "Output": "def dst ( self , dt ) : pass",
        "Var_Maps": [
            {
                "self": "var_0",
                "dst": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return ZERO",
        "Output": "return ZERO",
        "Var_Maps": [
            {
                "ZERO": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] derive the class var_0 from the var_1 base class . [SEP]",
        "reference": "class Fixed Offset ( tzinfo ) : pass",
        "Output": "class Fixed Offset ( tzinfo ) : pass",
        "Var_Maps": [
            {
                "FixedOffset": "var_0",
                "tzinfo": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 3 arguments : var_2 , var_1 set to none , var_3 set to none . [SEP]",
        "reference": "def __init__ ( self , offset = None , name = None ) : pass",
        "Output": "def __init__ ( self , offset = None , name = None ) : pass",
        "Var_Maps": [
            {
                "__init__": "var_0",
                "offset": "var_1",
                "self": "var_2",
                "name": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is not none , [SEP]",
        "reference": "if offset is not None : pass",
        "Output": "if offset is not None : pass",
        "Var_Maps": [
            {
                "offset": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_2 set to var_3 , substitute the result for var_4 . var_1 . [SEP]",
        "reference": "self . __offset = timedelta ( minutes = offset )",
        "Output": "self . __offset = timedelta ( minutes = offset )",
        "Var_Maps": [
            {
                "timedelta": "var_0",
                "__offset": "var_1",
                "minutes": "var_2",
                "offset": "var_3",
                "self": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is not none , [SEP]",
        "reference": "if name is not None : pass",
        "Output": "if name is not None : pass",
        "Var_Maps": [
            {
                "name": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_2 for var_1 . var_0 . [SEP]",
        "reference": "self . __name = name",
        "Output": "self . __name = name",
        "Var_Maps": [
            {
                "__name": "var_0",
                "self": "var_1",
                "name": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments : var_1 and var_2 . [SEP]",
        "reference": "def utcoffset ( self , dt ) : pass",
        "Output": "def utcoffset ( self , dt ) : pass",
        "Var_Maps": [
            {
                "utcoffset": "var_0",
                "self": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_1 . var_0 . [SEP]",
        "reference": "return self . __offset",
        "Output": "return self . __offset",
        "Var_Maps": [
            {
                "__offset": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments : var_1 and var_2 . [SEP]",
        "reference": "def tzname ( self , dt ) : pass",
        "Output": "def tzname ( self , dt ) : pass",
        "Var_Maps": [
            {
                "tzname": "var_0",
                "self": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_1 . var_0 . [SEP]",
        "reference": "return self . __name",
        "Output": "return self . __name",
        "Var_Maps": [
            {
                "__name": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_1 with 2 arguments : var_0 and var_2 . [SEP]",
        "reference": "def dst ( self , dt ) : pass",
        "Output": "def dst ( self , dt ) : pass",
        "Var_Maps": [
            {
                "self": "var_0",
                "dst": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return ZERO",
        "Output": "return ZERO",
        "Var_Maps": [
            {
                "ZERO": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] derive the class var_0 from the var_1 base class . [SEP]",
        "reference": "class Reference Local Timezone ( tzinfo ) : pass",
        "Output": "class Reference Local Timezone ( tzinfo ) : pass",
        "Var_Maps": [
            {
                "ReferenceLocalTimezone": "var_0",
                "tzinfo": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def __init__ ( self ) : pass",
        "Output": "def __init__ ( self ) : pass",
        "Var_Maps": [
            {
                "__init__": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 with an argument var_3 set to negative var_4 . var_2 , substitute the result for var_5 . var_0 . [SEP]",
        "reference": "self . STDOFFSET = timedelta ( seconds = - _time . timezone )",
        "Output": "self . STDOFFSET = timedelta ( seconds = _time . timezone )",
        "Var_Maps": [
            {
                "STDOFFSET": "var_0",
                "timedelta": "var_1",
                "timezone": "var_2",
                "seconds": "var_3",
                "_time": "var_4",
                "self": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 . var_0 is true , [SEP]",
        "reference": "if _time . daylight : pass",
        "Output": "if _time . daylight : pass",
        "Var_Maps": [
            {
                "daylight": "var_0",
                "_time": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 with an argument var_2 set to negative var_4 . var_3 , substitute the result for var_5 . var_0 . [SEP]",
        "reference": "self . DSTOFFSET = timedelta ( seconds = - _time . altzone )",
        "Output": "self . DSTOFFSET = timedelta ( seconds = _time . altzone )",
        "Var_Maps": [
            {
                "DSTOFFSET": "var_0",
                "timedelta": "var_1",
                "seconds": "var_2",
                "altzone": "var_3",
                "_time": "var_4",
                "self": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] substitute var_2 . var_1 for var_2 . var_0 . [SEP]",
        "reference": "self . DSTOFFSET = self . STDOFFSET",
        "Output": "self . DSTOFFSET = self . STDOFFSET",
        "Var_Maps": [
            {
                "DSTOFFSET": "var_0",
                "STDOFFSET": "var_1",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] sub ##tra ##ct var_3 . var_1 with var_3 . var_0 , substitute the result for var_3 . var_2 . [SEP]",
        "reference": "self . DSTDIFF = self . DSTOFFSET - self . STDOFFSET",
        "Output": "var_4 . DSTDIFF = var_4 . STDOFFSET - var_4 . DSTOFFSET",
        "Var_Maps": [
            {
                "DSTOFFSET": "var_0",
                "STDOFFSET": "var_1",
                "DSTDIFF": "var_2",
                "self": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_0 with an argument var_2 . [SEP]",
        "reference": "tzinfo . __init__ ( self )",
        "Output": "tzinfo . __init__ ( self )",
        "Var_Maps": [
            {
                "__init__": "var_0",
                "tzinfo": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments : var_1 and var_2 . [SEP]",
        "reference": "def utcoffset ( self , dt ) : pass",
        "Output": "def utcoffset ( self , dt ) : pass",
        "Var_Maps": [
            {
                "utcoffset": "var_0",
                "self": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_0 with an argument var_2 , if it evaluate ##s to true , [SEP]",
        "reference": "if self . _isdst ( dt ) : pass",
        "Output": "if self . _isdst ( dt ) : pass",
        "Var_Maps": [
            {
                "_isdst": "var_0",
                "self": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_1 . var_0 . [SEP]",
        "reference": "return self . DSTOFFSET",
        "Output": "return self . DSTOFFSET",
        "Var_Maps": [
            {
                "DSTOFFSET": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] return var_1 . var_0 . [SEP]",
        "reference": "return self . STDOFFSET",
        "Output": "return self . STDOFFSET",
        "Var_Maps": [
            {
                "STDOFFSET": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method utc ##offs ##et with 2 arguments : var_0 and var_2 . [SEP]",
        "reference": "def dst ( self , dt ) : pass",
        "Output": "def dst ( self , dt ) : pass",
        "Var_Maps": [
            {
                "self": "var_0",
                "dst": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_0 with an argument var_2 , if it evaluate ##s to true , [SEP]",
        "reference": "if self . _isdst ( dt ) : pass",
        "Output": "if self . _isdst ( dt ) : pass",
        "Var_Maps": [
            {
                "_isdst": "var_0",
                "self": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_1 . var_0 . [SEP]",
        "reference": "return self . DSTDIFF",
        "Output": "return self . DSTDIFF",
        "Var_Maps": [
            {
                "DSTDIFF": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return ZERO",
        "Output": "return ZERO",
        "Var_Maps": [
            {
                "ZERO": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments : var_1 and var_2 . [SEP]",
        "reference": "def tzname ( self , dt ) : pass",
        "Output": "def tzname ( self , dt ) : pass",
        "Var_Maps": [
            {
                "tzname": "var_0",
                "self": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_3 . var_1 with an argument var_4 , use it as an key to get the value from the var_2 . var_0 dictionary , return it . [SEP]",
        "reference": "return _time . tzname [ self . _isdst ( dt ) ]",
        "Output": "return _time . tzname [ self . _isdst ( dt ) ]",
        "Var_Maps": [
            {
                "tzname": "var_0",
                "_isdst": "var_1",
                "_time": "var_2",
                "self": "var_3",
                "dt": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments : var_1 and var_2 . [SEP]",
        "reference": "def _isdst ( self , dt ) : pass",
        "Output": "def _isdst ( self , dt ) : pass",
        "Var_Maps": [
            {
                "_isdst": "var_0",
                "self": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var _ 7 is a tu ##ple with 9 elements : var _ 8 . var_4 , var _ 8 . var_3 , var _ 8 . var_6 , var _ 8 . var_5 , var _ 8 . var_1 , var _ 8 . var_2 , result of the method var _ 8 . var_0 , [SEP]",
        "reference": "tt = dt . year , dt . month , dt . day , dt . hour , dt . minute , dt . second , dt . weekday ( ) , 0 , 0",
        "Output": "tt = minute1 . year , minute1 . month , minute1 . day , minute1 . weekday ( )",
        "Var_Maps": [
            {
                "weekday": "var_0",
                "minute": "var_1",
                "second": "var_2",
                "month": "var_3",
                "year": "var_4",
                "hour": "var_5",
                "day": "var_6",
                "tt": "var_7",
                "dt": "var_14"
            }
        ]
    },
    {
        "intent": "[CLS] ing ##eter 0 and integer 0 . call the method var_2 . var_0 with an argument var_3 , substitute the result for var_1 . [SEP]",
        "reference": "stamp = _time . mktime ( tt )",
        "Output": "stamp = _time . mktime ( tt )",
        "Var_Maps": [
            {
                "mktime": "var_0",
                "stamp": "var_1",
                "_time": "var_2",
                "tt": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_0 with an argument var_2 , substitute the result for var_3 . [SEP]",
        "reference": "tt = _time . localtime ( stamp )",
        "Output": "tt = _time . localtime ( stamp )",
        "Var_Maps": [
            {
                "localtime": "var_0",
                "_time": "var_1",
                "stamp": "var_2",
                "tt": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 . var_0 is greater than integer 0 , return the result . [SEP]",
        "reference": "return tt . tm_isdst > 0",
        "Output": "return tt . tm_isdst > 0",
        "Var_Maps": [
            {
                "tm_isdst": "var_0",
                "tt": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] derive the class var_1 from the var_0 base class . [SEP]",
        "reference": "class Local Timezone ( Reference Local Timezone ) : pass",
        "Output": "class Local Timezone ( Reference Local Timezone ) : pass",
        "Var_Maps": [
            {
                "ReferenceLocalTimezone": "var_0",
                "LocalTimezone": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments : var_1 and var_2 . [SEP]",
        "reference": "def tzname ( self , dt ) : pass",
        "Output": "def tzname ( self , dt ) : pass",
        "Var_Maps": [
            {
                "tzname": "var_0",
                "self": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_3 is none , var_0 is boo ##lean false , otherwise call the method var_1 with an argument var_3 , substitute the result for var_0 . [SEP]",
        "reference": "is_dst = False if dt is None else self . _isdst ( dt )",
        "Output": "self = dt is None or _isdst ( dt )",
        "Var_Maps": [
            {
                "is_dst": "var_0",
                "_isdst": "var_1",
                "self": "var_2",
                "dt": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] return the value under the var_1 key of the var_2 . var_0 dictionary . [SEP]",
        "reference": "return _time . tzname [ is_dst ]",
        "Output": "return _time . tzname [ is_dst ]",
        "Var_Maps": [
            {
                "tzname": "var_0",
                "is_dst": "var_1",
                "_time": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments : var_1 and var_2 . [SEP]",
        "reference": "def _isdst ( self , dt ) : pass",
        "Output": "def _isdst ( self , dt ) : pass",
        "Var_Maps": [
            {
                "_isdst": "var_0",
                "self": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the method var_1 with an argument var_4 from the base class of the class var_0 , return the result . [SEP]",
        "reference": "return super ( Local Timezone , self ) . _isdst ( dt )",
        "Output": "return super ( Local Timezone , self ) . _isdst ( dt )",
        "Var_Maps": [
            {
                "LocalTimezone": "var_0",
                "_isdst": "var_1",
                "super": "var_2",
                "self": "var_3",
                "dt": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 or var_1 , renamed to var_2 , var_2 ep ##tions are caught , [SEP]",
        "reference": "try : pass except ( Overflow Error , Value Error ) as exc : pass",
        "Output": "try : pass except ( Overflow Error , Value Error ) as exc : pass",
        "Var_Maps": [
            {
                "OverflowError": "var_0",
                "ValueError": "var_1",
                "exc": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] get the var_1 of the var_2 object , substitute it for var_0 . [SEP]",
        "reference": "exc_type = type ( exc )",
        "Output": "exc_type = exc . type ( )",
        "Var_Maps": [
            {
                "exc_type": "var_0",
                "type": "var_1",
                "exc": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_2 with an argument string str_0 , replace %s with var_3 , [SEP]",
        "reference": "exc_value = exc_type ( ` Unsupported value : % r . You should install pytz . ` % dt )",
        "Output": "exc_type ( ` Unsupported value : % r . You should install pytz . ` % ( dt , var_4 ( exc_value ) ) )",
        "Var_Maps": [
            {
                "Unsupported value: %r. You should install pytz.": "var_0",
                "exc_value": "var_1",
                "exc_type": "var_2",
                "dt": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] substitute the result for var_0 . substitute var_2 for var_0 . var_1 . [SEP]",
        "reference": "exc_value . __cause__ = exc",
        "Output": "exc_value . __cause__ = exc",
        "Var_Maps": [
            {
                "exc_value": "var_0",
                "__cause__": "var_1",
                "exc": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_4 . var_3 with 3 arguments : var_1 , var_0 and third element of the result of the method var_5 . var_2 . [SEP]",
        "reference": "six . reraise ( exc_type , exc_value , sys . exc_info ( ) [ 2 ] )",
        "Output": "six . reraise ( exc_type , exc_value , sys . exc_info ( ) [ 2 ] )",
        "Var_Maps": [
            {
                "exc_value": "var_0",
                "exc_type": "var_1",
                "exc_info": "var_2",
                "reraise": "var_3",
                "six": "var_4",
                "sys": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , substitute var_0 . var_2 for var_2 , otherwise substitute result of the function var_4 for var_2 . [SEP]",
        "reference": "utc = pytz . utc if pytz else UTC ( )",
        "Output": "utc = pytz or pytz . utc",
        "Var_Maps": [
            {
                "pytz": "var_1",
                "utc": "var_3",
                "UTC": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def get_fixed_timezone ( offset ) : pass",
        "Output": "def get_fixed_timezone ( offset ) : pass",
        "Var_Maps": [
            {
                "get_fixed_timezone": "var_0",
                "offset": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 is an instance of var_1 class , [SEP]",
        "reference": "if isinstance ( offset , timedelta ) : pass",
        "Output": "if isinstance ( offset , timedelta ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "timedelta": "var_1",
                "offset": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 . var_0 for var_1 . [SEP]",
        "reference": "offset = offset . seconds / / 60",
        "Output": "offset = offset . seconds",
        "Var_Maps": [
            {
                "seconds": "var_0",
                "offset": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is smaller than integer 0 , var_1 is str_0 , otherwise var_1 is str_1 . [SEP]",
        "reference": "sign = ` - ` if offset < 0 else ` + `",
        "Output": "sign = offset < 0",
        "Var_Maps": [
            {
                "-": "var_2",
                "+": "var_3",
                "offset": "var_0",
                "sign": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] divide var_4 ol ##ute var_2 by module 60 , use the result to format string str_0 , substitute it for var_3 . [SEP]",
        "reference": "hhmm = ` % 02d % 02d ` % divmod ( abs ( offset ) , 60 )",
        "Output": "hhmm = ` divmod ` % ( offset , abs ( % 02d % 02d ) )",
        "Var_Maps": [
            {
                "%02d%02d": "var_0",
                "divmod": "var_1",
                "offset": "var_2",
                "hhmm": "var_3",
                "abs": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] sum var_1 and var_2 , substitute the result for var_0 . [SEP]",
        "reference": "name = sign + hhmm",
        "Output": "name = sign + hhmm",
        "Var_Maps": [
            {
                "name": "var_0",
                "sign": "var_1",
                "hhmm": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return an instance of var_0 class , created with 2 arguments : var_1 and var_2 . [SEP]",
        "reference": "return Fixed Offset ( offset , name )",
        "Output": "return Fixed Offset ( offset , name )",
        "Var_Maps": [
            {
                "FixedOffset": "var_0",
                "offset": "var_1",
                "name": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is none . [SEP]",
        "reference": "_localtime = None",
        "Output": "_localtime = None",
        "Var_Maps": [
            {
                "_localtime": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 . [SEP]",
        "reference": "def get_default_timezone ( ) : pass",
        "Output": "def get_default_timezone ( ) : pass",
        "Var_Maps": [
            {
                "get_default_timezone": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] use global variable var_0 . [SEP]",
        "reference": "global _localtime",
        "Output": "",
        "Var_Maps": [
            {
                "_localtime": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if _localtime is None : pass",
        "Output": "if _localtime is None : pass",
        "Var_Maps": [
            {
                "_localtime": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_3 . var_2 is an instance of var_5 . var_0 and var_4 is not none , [SEP]",
        "reference": "if isinstance ( settings . TIME_ZONE , six . string_types ) and pytz is not None : pass",
        "Output": "if isinstance ( settings . TIME_ZONE , six . string_types ) and pytz is not None : pass",
        "Var_Maps": [
            {
                "string_types": "var_0",
                "isinstance": "var_1",
                "TIME_ZONE": "var_2",
                "settings": "var_3",
                "pytz": "var_4",
                "six": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_4 . var_2 with an argument var_3 . var_1 , substitute the result for var_0 . [SEP]",
        "reference": "_localtime = pytz . timezone ( settings . TIME_ZONE )",
        "Output": "_localtime = pytz . timezone ( settings . TIME_ZONE )",
        "Var_Maps": [
            {
                "_localtime": "var_0",
                "TIME_ZONE": "var_1",
                "timezone": "var_2",
                "settings": "var_3",
                "pytz": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] var_1 is an instance of var_0 class . [SEP]",
        "reference": "_localtime = Local Timezone ( )",
        "Output": "_localtime = Local Timezone ( )",
        "Var_Maps": [
            {
                "LocalTimezone": "var_0",
                "_localtime": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return _localtime",
        "Output": "return _localtime",
        "Var_Maps": [
            {
                "_localtime": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 . [SEP]",
        "reference": "def get_default_timezone_name ( ) : pass",
        "Output": "def get_default_timezone_name ( ) : pass",
        "Var_Maps": [
            {
                "get_default_timezone_name": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 , use the result as an argument for the call to the function var_1 , return the result . [SEP]",
        "reference": "return _get_timezone_name ( get_default_timezone ( ) )",
        "Output": "return _get_timezone_name ( get_default_timezone ( ) )",
        "Var_Maps": [
            {
                "get_default_timezone": "var_0",
                "_get_timezone_name": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 , substitute the result for var_0 . [SEP]",
        "reference": "_active = local ( )",
        "Output": "_active = local ( )",
        "Var_Maps": [
            {
                "_active": "var_0",
                "local": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 . [SEP]",
        "reference": "def get_current_timezone ( ) : pass",
        "Output": "def get_current_timezone ( ) : pass",
        "Var_Maps": [
            {
                "get_current_timezone": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] get str_0 attribute of the var_2 object , if it exists return it , if not , call the function var_0 and return the result . [SEP]",
        "reference": "return getattr ( _active , ` value ` , get_default_timezone ( ) )",
        "Output": "return getattr ( _active , ` value ` , getattr ( ) )",
        "Var_Maps": [
            {
                "value": "var_3",
                "get_default_timezone": "var_0",
                "getattr": "var_1",
                "_active": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 . [SEP]",
        "reference": "def get_current_timezone_name ( ) : pass",
        "Output": "def get_current_timezone_name ( ) : pass",
        "Var_Maps": [
            {
                "get_current_timezone_name": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 , use the result as an argument for the call to the function var_1 , return the result . [SEP]",
        "reference": "return _get_timezone_name ( get_current_timezone ( ) )",
        "Output": "return _get_timezone_name ( get_current_timezone ( ) )",
        "Var_Maps": [
            {
                "get_current_timezone": "var_0",
                "_get_timezone_name": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def _get_timezone_name ( timezone ) : pass",
        "Output": "def _get_timezone_name ( timezone ) : pass",
        "Var_Maps": [
            {
                "_get_timezone_name": "var_0",
                "timezone": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] return var_0 . var_1 . [SEP]",
        "reference": "return timezone . zone",
        "Output": "return timezone . zone",
        "Var_Maps": [
            {
                "timezone": "var_0",
                "zone": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Attribute Error : pass",
        "Output": "try : pass except Attribute Error : pass",
        "Var_Maps": [
            {
                "AttributeError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_1 with an argument none , return the result . [SEP]",
        "reference": "return timezone . tzname ( None )",
        "Output": "return timezone . tzname ( None )",
        "Var_Maps": [
            {
                "timezone": "var_0",
                "tzname": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def activate ( timezone ) : pass",
        "Output": "def activate ( timezone ) : pass",
        "Var_Maps": [
            {
                "activate": "var_0",
                "timezone": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 is an instance of var_2 , [SEP]",
        "reference": "if isinstance ( timezone , tzinfo ) : pass",
        "Output": "if isinstance ( timezone , tzinfo ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "timezone": "var_1",
                "tzinfo": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_1 . var_2 . [SEP]",
        "reference": "_active . value = timezone",
        "Output": "_active . value = timezone",
        "Var_Maps": [
            {
                "timezone": "var_0",
                "_active": "var_1",
                "value": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] otherwise if var_2 is an instance of var_4 . var_0 and var_3 is not none , [SEP]",
        "reference": "if True : pass elif isinstance ( timezone , six . string_types ) and pytz is not None : pass",
        "Output": "if ` True ` : pass elif isinstance ( timezone , six . string_types ) and pytz is not None : pass",
        "Var_Maps": [
            {
                "string_types": "var_0",
                "isinstance": "var_1",
                "timezone": "var_2",
                "pytz": "var_3",
                "six": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_4 . var_0 with an argument var_0 , substitute the result for var_2 . var_3 . [SEP]",
        "reference": "_active . value = pytz . timezone ( timezone )",
        "Output": "_active . value = pytz . timezone ( timezone )",
        "Var_Maps": [
            {
                "timezone": "var_1",
                "_active": "var_2",
                "value": "var_3",
                "pytz": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] raise an var_1 with an argument string str_0 , substitute str_1 with var_2 . [SEP]",
        "reference": "raise Value Error ( ` Invalid timezone : % r ` % timezone )",
        "Output": "raise Value Error ( ` Invalid timezone : % r ` % timezone )",
        "Var_Maps": [
            {
                "Invalid timezone: %r": "var_0",
                "%r": "str_1",
                "ValueError": "var_1",
                "timezone": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 . [SEP]",
        "reference": "def deactivate ( ) : pass",
        "Output": "def deactivate ( ) : pass",
        "Var_Maps": [
            {
                "deactivate": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if active has an attribute str_0 , [SEP]",
        "reference": "if hasattr ( _active , ` value ` ) : pass",
        "Output": "if _active ( hasattr , ` value ` ) : pass",
        "Var_Maps": [
            {
                "value": "var_2",
                "hasattr": "var_0",
                "_active": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] del ##ete var_0 . var_1 . [SEP]",
        "reference": "del _active . value",
        "Output": "del _active . value",
        "Var_Maps": [
            {
                "_active": "var_0",
                "value": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] derive the class var_0 from the var_1 base class . [SEP]",
        "reference": "class override ( object ) : pass",
        "Output": "class override ( object ) : pass",
        "Var_Maps": [
            {
                "override": "var_0",
                "object": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments : var_2 and var_1 . [SEP]",
        "reference": "def __init__ ( self , timezone ) : pass",
        "Output": "def __init__ ( self , timezone ) : pass",
        "Var_Maps": [
            {
                "__init__": "var_0",
                "timezone": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_2 . var_0 . [SEP]",
        "reference": "self . timezone = timezone",
        "Output": "self . timezone = timezone",
        "Var_Maps": [
            {
                "timezone": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] get str_0 attribute of the var_2 object [SEP]",
        "reference": "self . old_timezone = getattr ( _active , ` value ` , None )",
        "Output": "getattr ( _active , ` old_timezone ` )",
        "Var_Maps": [
            {
                "value": "var_3",
                "old_timezone": "var_0",
                "getattr": "var_1",
                "_active": "var_2",
                "self": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def __enter__ ( self ) : pass",
        "Output": "def __enter__ ( self ) : pass",
        "Var_Maps": [
            {
                "__enter__": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 . var_0 is none , [SEP]",
        "reference": "if self . timezone is None : pass",
        "Output": "if self . timezone is None : pass",
        "Var_Maps": [
            {
                "timezone": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . [SEP]",
        "reference": "deactivate ( )",
        "Output": "deactivate ( )",
        "Var_Maps": [
            {
                "deactivate": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the method var_0 with an argument var_2 . var_1 . [SEP]",
        "reference": "activate ( self . timezone )",
        "Output": "activate ( self . timezone )",
        "Var_Maps": [
            {
                "activate": "var_0",
                "timezone": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_2 with 4 arguments var_4 , var_3 , var_0 and var_1 . [SEP]",
        "reference": "def __exit__ ( self , exc_type , exc_value , traceback ) : pass",
        "Output": "def __exit__ ( self , exc_type , exc_value , traceback ) : pass",
        "Var_Maps": [
            {
                "exc_value": "var_0",
                "traceback": "var_1",
                "__exit__": "var_2",
                "exc_type": "var_3",
                "self": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 . var_0 is none , [SEP]",
        "reference": "if self . old_timezone is None : pass",
        "Output": "if self . old_timezone is None : pass",
        "Var_Maps": [
            {
                "old_timezone": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . [SEP]",
        "reference": "deactivate ( )",
        "Output": "deactivate ( )",
        "Var_Maps": [
            {
                "deactivate": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] substitute var_3 . var_0 for var_1 . var_2 . [SEP]",
        "reference": "_active . value = self . old_timezone",
        "Output": "_active . value = self . old_timezone",
        "Var_Maps": [
            {
                "old_timezone": "var_0",
                "_active": "var_1",
                "value": "var_2",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 2 arguments : var_2 and var_1 set to none . [SEP]",
        "reference": "def template_localtime ( value , use_tz = None ) : pass",
        "Output": "def template_localtime ( value , use_tz = None ) : pass",
        "Var_Maps": [
            {
                "template_localtime": "var_0",
                "use_tz": "var_1",
                "value": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 0 is an instance of var_3 and var_4 . var _ 8 if var _ 7 is none else var _ 7 and call to the function var_5 , [SEP]",
        "reference": "should_convert = isinstance ( value , datetime ) and ( settings . USE_TZ if use_tz is None else use_tz ) and not is_naive ( value ) and getattr ( value , ` convert_to_local_time ` , True )",
        "Output": "if isinstance ( should_convert0 , datetime ) and settings . USE_TZ is None and is_naive ( convert_to_local_time ) : pass",
        "Var_Maps": [
            {
                "convert_to_local_time": "var_0",
                "should_convert": "var_1",
                "isinstance": "var_2",
                "datetime": "var_3",
                "settings": "var_4",
                "is_naive": "var_5",
                "getattr": "var_6",
                "use_tz": "var_9",
                "USE_TZ": "var_8",
                "value": "var_12"
            }
        ]
    },
    {
        "intent": "[CLS] with an argument var_2 evaluate ##s to false , and if str_0 attribute of var_2 object doesn ##t exists , or is it does is boo ##lean true , var_0 is boo ##lean true , otherwise is boo ##lean false . if var_0 is true , call the function var_1 with an argument var_2 and return the result , otherwise return var_2 . [SEP]",
        "reference": "return localtime ( value ) if should_convert else value",
        "Output": "return localtime ( value ) if should_convert else value",
        "Var_Maps": [
            {
                "convert_to_local_time": "str_0",
                "should_convert": "var_0",
                "localtime": "var_1",
                "value": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 2 arguments : var_2 and var_1 set to none . [SEP]",
        "reference": "def localtime ( value , timezone = None ) : pass",
        "Output": "def localtime ( value , timezone = None ) : pass",
        "Var_Maps": [
            {
                "localtime": "var_0",
                "timezone": "var_1",
                "value": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if timezone is None : pass",
        "Output": "if timezone is None : pass",
        "Var_Maps": [
            {
                "timezone": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 , substitute the result for var_1 . [SEP]",
        "reference": "timezone = get_current_timezone ( )",
        "Output": "timezone = get_current_timezone ( )",
        "Var_Maps": [
            {
                "get_current_timezone": "var_0",
                "timezone": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 with an argument var_1 , substitute the result for var_2 . [SEP]",
        "reference": "value = value . astimezone ( timezone )",
        "Output": "value = value . astimezone ( timezone )",
        "Var_Maps": [
            {
                "astimezone": "var_0",
                "timezone": "var_1",
                "value": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 has an attribute str_0 , [SEP]",
        "reference": "if hasattr ( timezone , ` normalize ` ) : pass",
        "Output": "if normalize ( timezone , ` hasattr ` ) : pass",
        "Var_Maps": [
            {
                "normalize": "var_0",
                "timezone": "var_1",
                "hasattr": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_0 with an argument var_2 , substitute the result for var_2 . [SEP]",
        "reference": "value = timezone . normalize ( value )",
        "Output": "value = timezone . normalize ( value )",
        "Var_Maps": [
            {
                "normalize": "var_0",
                "timezone": "var_1",
                "value": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return value",
        "Output": "return value",
        "Var_Maps": [
            {
                "value": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 . [SEP]",
        "reference": "def now ( ) : pass",
        "Output": "def now ( ) : pass",
        "Var_Maps": [
            {
                "now": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 . var_1 is true , [SEP]",
        "reference": "if settings . USE_TZ : pass",
        "Output": "if settings . USE_TZ : pass",
        "Var_Maps": [
            {
                "settings": "var_0",
                "USE_TZ": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_2 , on the result call the method var_1 with an argument var_3 set to var_4 , return the result . [SEP]",
        "reference": "return datetime . utcnow ( ) . replace ( tzinfo = utc )",
        "Output": "return datetime . utcnow ( tzinfo = utc ) . replace ( )",
        "Var_Maps": [
            {
                "datetime": "var_0",
                "replace": "var_1",
                "utcnow": "var_2",
                "tzinfo": "var_3",
                "utc": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_1 , return the result . [SEP]",
        "reference": "return datetime . now ( )",
        "Output": "return datetime . now ( )",
        "Var_Maps": [
            {
                "datetime": "var_0",
                "now": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def is_aware ( value ) : pass",
        "Output": "def is_aware ( value ) : pass",
        "Var_Maps": [
            {
                "is_aware": "var_0",
                "value": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_3 . var_1 is not none and call to the method var_3 . var_1 . var_0 called with an argument var_3 evaluate ##s to not none , [SEP]",
        "reference": "return value . tzinfo is not None and value . tzinfo . utcoffset ( value ) is not None",
        "Output": "if var_4 . tzinfo is not None and var_4 . tzinfo . utcoffset ( var_4 ) : pass",
        "Var_Maps": [
            {
                "utcoffset": "var_0",
                "tzinfo": "var_2",
                "value": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] return boo ##lean true , otherwise return boo ##lean false . define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def is_naive ( value ) : pass",
        "Output": "def is_naive ( value ) : pass",
        "Var_Maps": [
            {
                "is_naive": "var_0",
                "value": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_3 . var_1 is none and call to the method var_3 . var_1 . var_0 called with an argument var_3 evaluate ##s to none , [SEP]",
        "reference": "return value . tzinfo is None or value . tzinfo . utcoffset ( value ) is None",
        "Output": "if var_4 . tzinfo is None and var_4 . tzinfo . utcoffset ( var_4 ) : pass",
        "Var_Maps": [
            {
                "utcoffset": "var_0",
                "tzinfo": "var_2",
                "value": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] return boo ##lean true , otherwise return boo ##lean false . define the function var_0 with 2 arguments : var_2 and var_1 . [SEP]",
        "reference": "def make_aware ( value , timezone ) : pass",
        "Output": "def make_aware ( value , timezone ) : pass",
        "Var_Maps": [
            {
                "make_aware": "var_0",
                "timezone": "var_1",
                "value": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 has an attribute str_0 , [SEP]",
        "reference": "if hasattr ( timezone , ` localize ` ) : pass",
        "Output": "if localize ( timezone , ` hasattr ` ) : pass",
        "Var_Maps": [
            {
                "localize": "var_1",
                "timezone": "var_0",
                "hasattr": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_1 with 2 arguments : var_3 and var_2 as none , return the result . [SEP]",
        "reference": "return timezone . localize ( value , is_dst = None )",
        "Output": "return timezone . localize ( value , is_dst )",
        "Var_Maps": [
            {
                "timezone": "var_0",
                "localize": "var_1",
                "is_dst": "var_2",
                "value": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_1 , if it evaluate ##s to true , [SEP]",
        "reference": "if is_aware ( value ) : pass",
        "Output": "if is_aware ( value ) : pass",
        "Var_Maps": [
            {
                "is_aware": "var_0",
                "value": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] raise an var_1 exception with an argument string str_0 , where %s is replaced with var_2 . [SEP]",
        "reference": "raise Value Error ( ` make_aware expects a naive datetime , got % s ` % value )",
        "Output": "raise Value Error ( ` make_aware expects a naive datetime , got % s ` % value )",
        "Var_Maps": [
            {
                "make_aware expects a naive datetime, got %s": "var_0",
                "ValueError": "var_1",
                "value": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_3 . var_1 with an argument var_2 as var_0 , return the result . [SEP]",
        "reference": "return value . replace ( tzinfo = timezone )",
        "Output": "return value . replace ( tzinfo = timezone )",
        "Var_Maps": [
            {
                "timezone": "var_0",
                "replace": "var_1",
                "tzinfo": "var_2",
                "value": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 2 arguments : var_2 and var_1 . [SEP]",
        "reference": "def make_naive ( value , timezone ) : pass",
        "Output": "def make_naive ( value , timezone ) : pass",
        "Var_Maps": [
            {
                "make_naive": "var_0",
                "timezone": "var_1",
                "value": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 with an argument var_1 , substitute the result for var_2 . [SEP]",
        "reference": "value = value . astimezone ( timezone )",
        "Output": "value = value . astimezone ( timezone )",
        "Var_Maps": [
            {
                "astimezone": "var_0",
                "timezone": "var_1",
                "value": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 has an attribute str_0 , [SEP]",
        "reference": "if hasattr ( timezone , ` normalize ` ) : pass",
        "Output": "if normalize ( timezone , ` hasattr ` ) : pass",
        "Var_Maps": [
            {
                "normalize": "var_0",
                "timezone": "var_1",
                "hasattr": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_0 with an argument var_2 , substitute the result for var_2 . [SEP]",
        "reference": "value = timezone . normalize ( value )",
        "Output": "value = timezone . normalize ( value )",
        "Var_Maps": [
            {
                "normalize": "var_0",
                "timezone": "var_1",
                "value": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 with an ar ##ug ##ment var_1 set to none , return the result . [SEP]",
        "reference": "return value . replace ( tzinfo = None )",
        "Output": "return value . replace ( tzinfo = None )",
        "Var_Maps": [
            {
                "replace": "var_0",
                "tzinfo": "var_1",
                "value": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] from var_1 import var_0 into default name space . [SEP]",
        "reference": "from __future__ import unicode_literals",
        "Output": "from __future__ import unicode_literals",
        "Var_Maps": [
            {
                "unicode_literals": "var_0",
                "__future__": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_0 . [SEP]",
        "reference": "import re",
        "Output": "import re",
        "Var_Maps": [
            {
                "re": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . utils . encoding import force_text",
        "Output": "from django . utils . encoding import force_text",
        "Var_Maps": [
            {
                "django.utils.encoding": "var_0",
                "force_text": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . utils . functional import lazy",
        "Output": "from django . utils . functional import lazy",
        "Var_Maps": [
            {
                "django.utils.functional": "var_0",
                "lazy": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . utils import six",
        "Output": "from django . utils import six",
        "Var_Maps": [
            {
                "django.utils": "var_0",
                "six": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 6 is an list containing strings : str_0 , str_1 , str_2 , str_3 , str_4 , [SEP]",
        "reference": "__all__ = [ ` activate ` , ` deactivate ` , ` override ` , ` deactivate_all ` , ` get_language ` , ` get_language_from_request ` , ` get_language_info ` , ` get_language_bidi ` , ` check_for_language ` , ` to_locale ` , ` templatize ` , ` string_concat ` , ` gettext ` , ` gettext_lazy ` , ` gettext_noop ` , ` ugettext ` , ` ugettext_lazy ` , ` ugettext_noop ` , ` ngettext ` , ` ngettext_lazy ` , ` ungettext ` , ` ungettext_lazy ` , ` pgettext ` , ` pgettext_lazy ` , ` npgettext ` , ` npgettext_lazy ` , ` LANGUAGE_SESSION_KEY ` ]",
        "Output": "override = [ ` deactivate ` , ` LANGUAGE_SESSION_KEY7 ` , ` check_for_language0 ` , ` activate ` , ` LANGUAGE_SESSION_KEY ` ]",
        "Var_Maps": [
            {
                "activate": "var_21",
                "deactivate": "var_16",
                "override": "var_22",
                "deactivate_all": "var_5",
                "get_language": "var_13",
                "get_language_from_request": "var_0",
                "LANGUAGE_SESSION_KEY": "var_1",
                "check_for_language": "var_2",
                "get_language_info": "var_3",
                "get_language_bidi": "var_4",
                "ungettext_lazy": "var_6",
                "npgettext_lazy": "var_7",
                "string_concat": "var_8",
                "ugettext_lazy": "var_9",
                "ugettext_noop": "var_10",
                "ngettext_lazy": "var_11",
                "pgettext_lazy": "var_12",
                "gettext_lazy": "var_14",
                "gettext_noop": "var_15",
                "templatize": "var_17",
                "to_locale": "var_18",
                "ungettext": "var_19",
                "npgettext": "var_20",
                "ugettext": "var_23",
                "ngettext": "var_24",
                "pgettext": "var_25",
                "__all__": "var_26",
                "gettext": "var_27"
            }
        ]
    },
    {
        "intent": "[CLS] str_0 , str_1 , str_2 , str_3 , str_4 , str_5 , str_6 , st ##r _ 7 , st ##r _ 8 , st ##r _ 9 , str_1 0 , str_1 1 , str_1 2 , str_1 3 , str_1 4 , str_1 5 , str_1 6 , str_1 7 , str_1 8 , str_1 9 , str_2 0 and str_2 1 . var_0 is an string str_2 2 . [SEP]",
        "reference": "LANGUAGE_SESSION_KEY = ` _language `",
        "Output": "LANGUAGE_SESSION_KEY = ` _language `",
        "Var_Maps": [
            {
                "get_language_from_request": "str_0",
                "get_language_info": "str_1",
                "get_language_bidi": "str_2",
                "check_for_language": "str_3",
                "to_locale": "str_4",
                "templatize": "str_5",
                "string_concat": "str_6",
                "gettext": "str_7",
                "gettext_lazy": "str_8",
                "gettext_noop": "str_9",
                "ugettext": "str_10",
                "ugettext_lazy": "str_11",
                "ugettext_noop": "str_12",
                "ngettext": "str_13",
                "ngettext_lazy": "str_14",
                "ungettext": "str_15",
                "ungettext_lazy": "str_16",
                "pgettext": "str_17",
                "pgettext_lazy": "str_18",
                "npgettext": "str_19",
                "npgettext_lazy": "str_20",
                "LANGUAGE_SESSION_KEY": "var_0",
                "_language": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] derive the class var_0 from the var_1 base class . [SEP]",
        "reference": "class Translator Comment Warning ( Syntax Warning ) : pass",
        "Output": "class Translator Comment Warning ( Syntax Warning ) : pass",
        "Var_Maps": [
            {
                "TranslatorCommentWarning": "var_0",
                "SyntaxWarning": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] do nothing . [SEP]",
        "reference": "pass",
        "Output": "pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] derive the class var_1 from the var_0 base class . [SEP]",
        "reference": "class Trans ( object ) : pass",
        "Output": "class Trans ( object ) : pass",
        "Var_Maps": [
            {
                "object": "var_0",
                "Trans": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments : var_2 and var_1 . [SEP]",
        "reference": "def __getattr__ ( self , real_name ) : pass",
        "Output": "def __getattr__ ( self , real_name ) : pass",
        "Var_Maps": [
            {
                "__getattr__": "var_0",
                "real_name": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 . [SEP]",
        "reference": "from django . conf import settings",
        "Output": "from django . conf import settings",
        "Var_Maps": [
            {
                "django.conf": "var_0",
                "settings": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 . var_1 is true , [SEP]",
        "reference": "if settings . USE_I18N : pass",
        "Output": "if settings . USE_I18N : pass",
        "Var_Maps": [
            {
                "settings": "var_0",
                "USE_I18N": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 as var_2 . [SEP]",
        "reference": "from django . utils . translation import trans_real as trans",
        "Output": "from django . utils . translation import trans_real as trans",
        "Var_Maps": [
            {
                "django.utils.translation": "var_0",
                "trans_real": "var_1",
                "trans": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 as var_2 . [SEP]",
        "reference": "from django . utils . translation import trans_null as trans",
        "Output": "from django . utils . translation import trans_null as trans",
        "Var_Maps": [
            {
                "django.utils.translation": "var_0",
                "trans_null": "var_1",
                "trans": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] set var_0 attribute of the var_5 object to value of var_0 attribute of var_4 object . [SEP]",
        "reference": "setattr ( self , real_name , getattr ( trans , real_name ) )",
        "Output": "real_name ( self , real_name )",
        "Var_Maps": [
            {
                "real_name": "var_1",
                "setattr": "var_2",
                "getattr": "var_3",
                "trans": "var_4",
                "self": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] get attribute var_0 from the var_2 object , return it . [SEP]",
        "reference": "return getattr ( trans , real_name )",
        "Output": "return getattr ( trans , getattr )",
        "Var_Maps": [
            {
                "real_name": "var_0",
                "getattr": "var_1",
                "trans": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an instance of var_1 class . [SEP]",
        "reference": "_trans = Trans ( )",
        "Output": "_trans = Trans ( )",
        "Var_Maps": [
            {
                "_trans": "var_0",
                "Trans": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] del ##ete var_0 . [SEP]",
        "reference": "del Trans",
        "Output": "del Trans",
        "Var_Maps": [
            {
                "Trans": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def gettext_noop ( message ) : pass",
        "Output": "def gettext_noop ( message ) : pass",
        "Var_Maps": [
            {
                "gettext_noop": "var_0",
                "message": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 with an argument var_1 . [SEP]",
        "reference": "return _trans . gettext_noop ( message )",
        "Output": "_trans . gettext_noop ( message )",
        "Var_Maps": [
            {
                "gettext_noop": "var_0",
                "message": "var_1",
                "_trans": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "ugettext_noop = gettext_noop",
        "Output": "ugettext_noop = gettext_noop",
        "Var_Maps": [
            {
                "ugettext_noop": "var_0",
                "gettext_noop": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 _ no ##op with an argument var_1 . [SEP]",
        "reference": "def gettext ( message ) : pass",
        "Output": "def gettext ( message ) : pass",
        "Var_Maps": [
            {
                "gettext": "var_0",
                "message": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 with an argument var_1 . [SEP]",
        "reference": "return _trans . gettext ( message )",
        "Output": "_trans . gettext ( message )",
        "Var_Maps": [
            {
                "gettext": "var_0",
                "message": "var_1",
                "_trans": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 3 arguments : var_1 , var_2 and var_3 . [SEP]",
        "reference": "def ngettext ( singular , plural , number ) : pass",
        "Output": "def ngettext ( singular , plural , number ) : pass",
        "Var_Maps": [
            {
                "ngettext": "var_0",
                "singular": "var_1",
                "plural": "var_2",
                "number": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 with 3 arguments var_1 , var_3 and var_4 . [SEP]",
        "reference": "return _trans . ngettext ( singular , plural , number )",
        "Output": "_trans . ngettext ( singular , plural , number )",
        "Var_Maps": [
            {
                "ngettext": "var_0",
                "singular": "var_1",
                "_trans": "var_2",
                "plural": "var_3",
                "number": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def ugettext ( message ) : pass",
        "Output": "def ugettext ( message ) : pass",
        "Var_Maps": [
            {
                "ugettext": "var_0",
                "message": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . get ##text _ no ##op with an argument var_1 . [SEP]",
        "reference": "return _trans . ugettext ( message )",
        "Output": "_trans . ugettext ( message )",
        "Var_Maps": [
            {
                "ugettext": "var_0",
                "message": "var_1",
                "_trans": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 3 arguments : var_1 , var_2 and var_3 . [SEP]",
        "reference": "def ungettext ( singular , plural , number ) : pass",
        "Output": "def ungettext ( singular , plural , number ) : pass",
        "Var_Maps": [
            {
                "ungettext": "var_0",
                "singular": "var_1",
                "plural": "var_2",
                "number": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 with 3 arguments var_1 , var_3 and var_4 . [SEP]",
        "reference": "return _trans . ungettext ( singular , plural , number )",
        "Output": "_trans . ungettext ( singular , plural , number )",
        "Var_Maps": [
            {
                "ungettext": "var_0",
                "singular": "var_1",
                "_trans": "var_2",
                "plural": "var_3",
                "number": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 2 arguments : var_1 and var_2 . [SEP]",
        "reference": "def pgettext ( context , message ) : pass",
        "Output": "def pgettext ( context , message ) : pass",
        "Var_Maps": [
            {
                "pgettext": "var_0",
                "context": "var_1",
                "message": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_3 . var_0 with 2 arguments var_1 and var_2 . [SEP]",
        "reference": "return _trans . pgettext ( context , message )",
        "Output": "_trans . pgettext ( context , message )",
        "Var_Maps": [
            {
                "pgettext": "var_0",
                "context": "var_1",
                "message": "var_2",
                "_trans": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 4 arguments : var_2 , var_1 , var_3 and var_4 . [SEP]",
        "reference": "def npgettext ( context , singular , plural , number ) : pass",
        "Output": "def npgettext ( context , singular , plural , number ) : pass",
        "Var_Maps": [
            {
                "npgettext": "var_0",
                "singular": "var_1",
                "context": "var_2",
                "plural": "var_3",
                "number": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_3 . var_0 with 4 arguments var_2 , var_1 , var_4 and var_5 . [SEP]",
        "reference": "return _trans . npgettext ( context , singular , plural , number )",
        "Output": "_trans . npgettext ( context , singular , plural , number )",
        "Var_Maps": [
            {
                "npgettext": "var_0",
                "singular": "var_1",
                "context": "var_2",
                "_trans": "var_3",
                "plural": "var_4",
                "number": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_2 with 2 arguments : var_1 and var_3 , substitute var_0 . [SEP]",
        "reference": "gettext_lazy = lazy ( gettext , str )",
        "Output": "gettext_lazy = lazy ( gettext , str )",
        "Var_Maps": [
            {
                "gettext_lazy": "var_0",
                "gettext": "var_1",
                "lazy": "var_2",
                "str": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_3 with 2 arguments : var_2 and var_4 . var_1 , substitute var_0 . [SEP]",
        "reference": "ugettext_lazy = lazy ( ugettext , six . text_type )",
        "Output": "ugettext_lazy = lazy ( ugettext , six . text_type )",
        "Var_Maps": [
            {
                "ugettext_lazy": "var_0",
                "text_type": "var_1",
                "ugettext": "var_2",
                "lazy": "var_3",
                "six": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_3 with 2 arguments : var_2 and var_4 . var_1 , substitute var_0 . [SEP]",
        "reference": "pgettext_lazy = lazy ( pgettext , six . text_type )",
        "Output": "pgettext_lazy = lazy ( pgettext , six . text_type )",
        "Var_Maps": [
            {
                "pgettext_lazy": "var_0",
                "text_type": "var_1",
                "pgettext": "var_2",
                "lazy": "var_3",
                "six": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] define the var_4 ti ##on var_0 with 4 arguments : var_4 , var_1 , var_2 set to none and un ##pack ##ed dictionary var_3 . [SEP]",
        "reference": "def lazy_number ( func , resultclass , number = None , * * kwargs ) : pass",
        "Output": "def lazy_number ( func , resultclass , number = None , * * kwargs ) : pass",
        "Var_Maps": [
            {
                "lazy_number": "var_0",
                "resultclass": "var_1",
                "number": "var_2",
                "kwargs": "var_3",
                "func": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 is an instance of var_2 type . [SEP]",
        "reference": "if isinstance ( number , int ) : pass",
        "Output": "if isinstance ( number , int ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "number": "var_1",
                "int": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for value under the str_0 key of the var_0 dictionary . [SEP]",
        "reference": "kwargs [ ` number ` ] = number",
        "Output": "kwargs [ ` number ` ] = number",
        "Var_Maps": [
            {
                "number": "var_2",
                "kwargs": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the var_4 ti ##on var_3 with 2 arguments : var_4 and var_0 , call the result with an argument , un ##pack ##ed dictionary var_1 , [SEP]",
        "reference": "proxy = lazy ( func , resultclass ) ( * * kwargs )",
        "Output": "return lazy ( func , resultclass ) ( * kwargs , * * kwargs )",
        "Var_Maps": [
            {
                "resultclass": "var_0",
                "kwargs": "var_1",
                "proxy": "var_2",
                "lazy": "var_3",
                "func": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] substitute the result for proxy . if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] derive the class var_0 from the var_1 base class . [SEP]",
        "reference": "class Number Aware String ( resultclass ) : pass",
        "Output": "class Number Aware String ( resultclass ) : pass",
        "Var_Maps": [
            {
                "NumberAwareString": "var_0",
                "resultclass": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments : var_1 and var_2 . [SEP]",
        "reference": "def __mod__ ( self , rhs ) : pass",
        "Output": "def __mod__ ( self , rhs ) : pass",
        "Var_Maps": [
            {
                "__mod__": "var_0",
                "self": "var_1",
                "rhs": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_3 is an instance of var_2 type and var_1 is true , [SEP]",
        "reference": "if isinstance ( rhs , dict ) and number : pass",
        "Output": "if isinstance ( rhs , dict ) and number : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "number": "var_1",
                "dict": "var_2",
                "rhs": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] substitute value under the var_1 key of the var_2 dictionary for var_0 . [SEP]",
        "reference": "number_value = rhs [ number ]",
        "Output": "number_value = rhs . var_3 ( number )",
        "Var_Maps": [
            {
                "number_value": "var_0",
                "number": "var_1",
                "rhs": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Key Error : pass",
        "Output": "try : pass except Key Error : pass",
        "Var_Maps": [
            {
                "KeyError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] raise an var_1 with an argument string str_0 [SEP]",
        "reference": "raise Key Error ( ` Your dictionary lacks key ` % s ` . Please provide it , because it is required to determine whether string is singular or plural . ` % number )",
        "Output": "raise Key Error ( ` Your dictionary lacks key ` % s ` . Please provide it , because it is required to determine whether string is singular or plural . ` )",
        "Var_Maps": [
            {
                "Your dictionary lacks key \\'%s\\'. Please provide it, because it is required to ": "str_0",
                "Your dictionary lacks key '%s'. Please provide it, because it is required to determine whether string is singular or plural.": "var_0",
                "KeyError": "var_1",
                "number": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] str_0 , where %s is replaced with number . if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {
                "determine whether string is singular or plural.": "str_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "number_value = rhs",
        "Output": "number_value = rhs",
        "Var_Maps": [
            {
                "number_value": "var_0",
                "rhs": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_1 dictionary value under the str_0 key . [SEP]",
        "reference": "kwargs [ ` number ` ] = number_value",
        "Output": "kwargs [ ` number ` ] = number_value",
        "Var_Maps": [
            {
                "number": "var_2",
                "number_value": "var_0",
                "kwargs": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the var_2 ti ##on var_2 with un ##pack ##ed dictionary var_1 as an argument , substitute the result for var_0 . [SEP]",
        "reference": "translated = func ( * * kwargs )",
        "Output": "translated = func ( * * kwargs )",
        "Var_Maps": [
            {
                "translated": "var_0",
                "kwargs": "var_1",
                "func": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] format var_0 with var_2 , substitute the result for var_0 . [SEP]",
        "reference": "translated = translated % rhs",
        "Output": "translated = translated % rhs",
        "Var_Maps": [
            {
                "translated": "var_1",
                "rhs": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Type Error : pass",
        "Output": "try : pass except Type Error : pass",
        "Var_Maps": [
            {
                "TypeError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] do nothing . [SEP]",
        "reference": "pass",
        "Output": "pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return translated",
        "Output": "return translated",
        "Var_Maps": [
            {
                "translated": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_5 with 2 arguments : lambda function with un ##pack ##ed dictionary var_2 as an argument and return value an instance of var_0 class and var_0 , call the result with an argument un ##pack ##ed dictionary var_2 , substitute the result for var_4 . [SEP]",
        "reference": "proxy = lazy ( lambda * * kwargs : Number Aware String ( ) , Number Aware String ) ( * * kwargs )",
        "Output": "proxy = lazy ( lambda kwargs : Number Aware String ( * * Number Aware String ) . kwargs , * * kwargs ) ( )",
        "Var_Maps": [
            {
                "NumberAwareString": "var_1",
                "kwargs": "var_3",
                "proxy": "var_4",
                "lazy": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return proxy",
        "Output": "return proxy",
        "Var_Maps": [
            {
                "proxy": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 3 arguments : var_1 , var_2 and var_3 set to none . [SEP]",
        "reference": "def ngettext_lazy ( singular , plural , number = None ) : pass",
        "Output": "def ngettext_lazy ( singular , plural , number = None ) : pass",
        "Var_Maps": [
            {
                "ngettext_lazy": "var_0",
                "singular": "var_1",
                "plural": "var_2",
                "number": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with 5 arguments : var_1 , var _ 8 , var_2 set to var_2 , var_4 set to var_4 , [SEP]",
        "reference": "return lazy_number ( ngettext , str , singular = singular , plural = plural , number = number )",
        "Output": "lazy_number ( ngettext , str , singular = singular , plural = plural )",
        "Var_Maps": [
            {
                "lazy_number": "var_0",
                "ngettext": "var_1",
                "singular": "var_3",
                "plural": "var_5",
                "number": "var_7",
                "str": "var_8"
            }
        ]
    },
    {
        "intent": "[CLS] and var_3 set to var_3 , return the result . define the function var_0 with 3 arguments : var_1 , var_2 and var_3 set to none . [SEP]",
        "reference": "def ungettext_lazy ( singular , plural , number = None ) : pass",
        "Output": "def ungettext_lazy ( singular , plural , number = None ) : pass",
        "Var_Maps": [
            {
                "ungettext_lazy": "var_0",
                "singular": "var_1",
                "plural": "var_2",
                "number": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with 5 arguments : var_1 , var _ 9 . var_2 , var_3 set to var_3 , var_5 set to var_5 , [SEP]",
        "reference": "return lazy_number ( ungettext , six . text_type , singular = singular , plural = plural , number = number )",
        "Output": "lazy_number ( ungettext , six . text_type , singular = singular , plural = plural )",
        "Var_Maps": [
            {
                "lazy_number": "var_0",
                "ungettext": "var_1",
                "text_type": "var_2",
                "singular": "var_4",
                "plural": "var_6",
                "number": "var_8",
                "six": "var_9"
            }
        ]
    },
    {
        "intent": "[CLS] and var_4 set to var_4 , return the result . define the function var_0 with 4 arguments : var_2 , var_1 , var_3 and var_4 set to none . [SEP]",
        "reference": "def npgettext_lazy ( context , singular , plural , number = None ) : pass",
        "Output": "def npgettext_lazy ( context , singular , plural , number = None ) : pass",
        "Var_Maps": [
            {
                "npgettext_lazy": "var_0",
                "singular": "var_1",
                "context": "var_2",
                "plural": "var_3",
                "number": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with 6 arguments : var_1 , var_1 1 . var_2 , var_5 set to var_5 , var_3 set to var_3 , [SEP]",
        "reference": "return lazy_number ( npgettext , six . text_type , context = context , singular = singular , plural = plural , number = number )",
        "Output": "var_9 = lazy_number ( npgettext , npgettext1 . text_type , context = context , singular = var_7 )",
        "Var_Maps": [
            {
                "lazy_number": "var_0",
                "npgettext": "var_1",
                "text_type": "var_2",
                "singular": "var_4",
                "context": "var_6",
                "plural": "var_8",
                "number": "var_10",
                "six": "var_11"
            }
        ]
    },
    {
        "intent": "[CLS] plural set to plural and number set to number , return the result . define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def activate ( language ) : pass",
        "Output": "def activate ( language ) : pass",
        "Var_Maps": [
            {
                "activate": "var_0",
                "language": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_2 . var_0 with an argument var_1 , return the result . [SEP]",
        "reference": "return _trans . activate ( language )",
        "Output": "return _trans . activate ( language )",
        "Var_Maps": [
            {
                "activate": "var_0",
                "language": "var_1",
                "_trans": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 . [SEP]",
        "reference": "def deactivate ( ) : pass",
        "Output": "def deactivate ( ) : pass",
        "Var_Maps": [
            {
                "deactivate": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 . var_0 , return the result . [SEP]",
        "reference": "return _trans . deactivate ( )",
        "Output": "return _trans . deactivate ( )",
        "Var_Maps": [
            {
                "deactivate": "var_0",
                "_trans": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] derive the class var_0 from the var_1 base class . [SEP]",
        "reference": "class override ( object ) : pass",
        "Output": "class override ( object ) : pass",
        "Var_Maps": [
            {
                "override": "var_0",
                "object": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_1 with 3 arguments : var_3 , var_2 and var_0 set to boo ##lean false . [SEP]",
        "reference": "def __init__ ( self , language , deactivate = False ) : pass",
        "Output": "def __init__ ( self , language , deactivate = ` False ` ) : pass",
        "Var_Maps": [
            {
                "deactivate": "var_0",
                "__init__": "var_1",
                "language": "var_2",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_2 . var_0 . [SEP]",
        "reference": "self . language = language",
        "Output": "self . language = language",
        "Var_Maps": [
            {
                "language": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_2 . var_0 . [SEP]",
        "reference": "self . deactivate = deactivate",
        "Output": "self . deactivate = deactivate",
        "Var_Maps": [
            {
                "deactivate": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 , substitute the result for var_2 . var_0 . [SEP]",
        "reference": "self . old_language = get_language ( )",
        "Output": "self . old_language = get_language ( )",
        "Var_Maps": [
            {
                "old_language": "var_0",
                "get_language": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def __enter__ ( self ) : pass",
        "Output": "def __enter__ ( self ) : pass",
        "Var_Maps": [
            {
                "__enter__": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 . var_0 is not none , [SEP]",
        "reference": "if self . language is not None : pass",
        "Output": "if self . language is not None : pass",
        "Var_Maps": [
            {
                "language": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_2 . var_1 . [SEP]",
        "reference": "activate ( self . language )",
        "Output": "activate ( self . language )",
        "Var_Maps": [
            {
                "activate": "var_0",
                "language": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the function var_0 . [SEP]",
        "reference": "deactivate_all ( )",
        "Output": "deactivate_all ( )",
        "Var_Maps": [
            {
                "deactivate_all": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_2 with 4 arguments : var_4 , var_3 , var_0 and var_1 . [SEP]",
        "reference": "def __exit__ ( self , exc_type , exc_value , traceback ) : pass",
        "Output": "def __exit__ ( self , exc_type , exc_value , traceback ) : pass",
        "Var_Maps": [
            {
                "exc_value": "var_0",
                "traceback": "var_1",
                "__exit__": "var_2",
                "exc_type": "var_3",
                "self": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 . var_0 is true , [SEP]",
        "reference": "if self . deactivate : pass",
        "Output": "if self . deactivate : pass",
        "Var_Maps": [
            {
                "deactivate": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . [SEP]",
        "reference": "deactivate ( )",
        "Output": "deactivate ( )",
        "Var_Maps": [
            {
                "deactivate": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the method var_1 with an argument var_2 . var_0 . [SEP]",
        "reference": "activate ( self . old_language )",
        "Output": "activate ( self . old_language )",
        "Var_Maps": [
            {
                "old_language": "var_0",
                "activate": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 . [SEP]",
        "reference": "def get_language ( ) : pass",
        "Output": "def get_language ( ) : pass",
        "Var_Maps": [
            {
                "get_language": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 . var_0 , return the result . [SEP]",
        "reference": "return _trans . get_language ( )",
        "Output": "return _trans . get_language ( )",
        "Var_Maps": [
            {
                "get_language": "var_0",
                "_trans": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 . [SEP]",
        "reference": "def get_language_bidi ( ) : pass",
        "Output": "def get_language_bidi ( ) : pass",
        "Var_Maps": [
            {
                "get_language_bidi": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 . var_0 , return the result . [SEP]",
        "reference": "return _trans . get_language_bidi ( )",
        "Output": "return _trans . get_language_bidi ( )",
        "Var_Maps": [
            {
                "get_language_bidi": "var_0",
                "_trans": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def check_for_language ( lang_code ) : pass",
        "Output": "def check_for_language ( lang_code ) : pass",
        "Var_Maps": [
            {
                "check_for_language": "var_0",
                "lang_code": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_2 . var_0 with an argument var_1 , return the result . [SEP]",
        "reference": "return _trans . check_for_language ( lang_code )",
        "Output": "return _trans . check_for_language ( lang_code )",
        "Var_Maps": [
            {
                "check_for_language": "var_0",
                "lang_code": "var_1",
                "_trans": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def to_locale ( language ) : pass",
        "Output": "def to_locale ( language ) : pass",
        "Var_Maps": [
            {
                "to_locale": "var_0",
                "language": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_2 . var_0 with an argument var_1 , return the result . [SEP]",
        "reference": "return _trans . to_locale ( language )",
        "Output": "return _trans . to_locale ( language )",
        "Var_Maps": [
            {
                "to_locale": "var_0",
                "language": "var_1",
                "_trans": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 2 arguments : var_2 and var_1 set to boo ##lean false . [SEP]",
        "reference": "def get_language_from_request ( request , check_path = False ) : pass",
        "Output": "def get_language_from_request ( request , check_path = ` False ` ) : pass",
        "Var_Maps": [
            {
                "get_language_from_request": "var_0",
                "check_path": "var_1",
                "request": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_3 . var_0 with 2 arguments : var_2 and var_1 , return the result . [SEP]",
        "reference": "return _trans . get_language_from_request ( request , check_path )",
        "Output": "return _trans . get_language_from_request ( request , check_path )",
        "Var_Maps": [
            {
                "get_language_from_request": "var_0",
                "check_path": "var_1",
                "request": "var_2",
                "_trans": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def get_language_from_path ( path ) : pass",
        "Output": "def get_language_from_path ( path ) : pass",
        "Var_Maps": [
            {
                "get_language_from_path": "var_0",
                "path": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 . var_0 with an argument var_2 , return the result . [SEP]",
        "reference": "return _trans . get_language_from_path ( path )",
        "Output": "return _trans . get_language_from_path ( path )",
        "Var_Maps": [
            {
                "get_language_from_path": "var_0",
                "_trans": "var_1",
                "path": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 2 arguments : var_2 and var_1 set to none . [SEP]",
        "reference": "def templatize ( src , origin = None ) : pass",
        "Output": "def templatize ( src , origin = None ) : pass",
        "Var_Maps": [
            {
                "templatize": "var_0",
                "origin": "var_1",
                "src": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 . var_0 with 2 arguments : var_3 and var_2 , return the result . [SEP]",
        "reference": "return _trans . templatize ( src , origin )",
        "Output": "return _trans . templatize ( src , origin )",
        "Var_Maps": [
            {
                "templatize": "var_0",
                "_trans": "var_1",
                "origin": "var_2",
                "src": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 . [SEP]",
        "reference": "def deactivate_all ( ) : pass",
        "Output": "def deactivate_all ( ) : pass",
        "Var_Maps": [
            {
                "deactivate_all": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 . var_0 , return the result . [SEP]",
        "reference": "return _trans . deactivate_all ( )",
        "Output": "return _trans . deactivate_all ( )",
        "Var_Maps": [
            {
                "deactivate_all": "var_0",
                "_trans": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument un ##pack ##ed list var_1 . [SEP]",
        "reference": "def _string_concat ( * strings ) : pass",
        "Output": "def _string_concat ( * strings ) : pass",
        "Var_Maps": [
            {
                "_string_concat": "var_0",
                "strings": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_3 with 2 arguments : var_0 and var_4 . var_2 , substitute the result for var_1 . [SEP]",
        "reference": "string_concat = lazy ( _string_concat , six . text_type )",
        "Output": "string_concat = lazy ( _string_concat , six . text_type )",
        "Var_Maps": [
            {
                "_string_concat": "var_0",
                "string_concat": "var_1",
                "text_type": "var_2",
                "lazy": "var_3",
                "six": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def get_language_info ( lang_code ) : pass",
        "Output": "def get_language_info ( lang_code ) : pass",
        "Var_Maps": [
            {
                "get_language_info": "var_0",
                "lang_code": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 . [SEP]",
        "reference": "from django . conf . locale import LANG_INFO",
        "Output": "from django . conf . locale import LANG_INFO",
        "Var_Maps": [
            {
                "django.conf.locale": "var_0",
                "LANG_INFO": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] get the value under the var_1 key of the var_0 dictionary , return it . [SEP]",
        "reference": "return LANG_INFO [ lang_code ]",
        "Output": "return LANG_INFO [ lang_code ]",
        "Var_Maps": [
            {
                "LANG_INFO": "var_0",
                "lang_code": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Key Error : pass",
        "Output": "try : pass except Key Error : pass",
        "Var_Maps": [
            {
                "KeyError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if character str_0 is not contained in var_0 , [SEP]",
        "reference": "if ` - ` not in lang_code : pass",
        "Output": "if ` - ` not in lang_code : pass",
        "Var_Maps": [
            {
                "-": "var_1",
                "lang_code": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] raise an var_2 with an argument str_0 , where %s is replaced with var_1 . [SEP]",
        "reference": "raise Key Error ( ` Unknown language code % s . ` % lang_code )",
        "Output": "raise Key Error ( ` Unknown language code % s . ` % lang_code )",
        "Var_Maps": [
            {
                "Unknown language code %s.": "var_0",
                "lang_code": "var_1",
                "KeyError": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 var_1 by character str_0 , substitute the first element of the result for var_0 . [SEP]",
        "reference": "generic_lang_code = lang_code . split ( ` - ` ) [ 0 ]",
        "Output": "generic_lang_code = lang_code . split ( ` - ` ) [ 0 ]",
        "Var_Maps": [
            {
                "-": "var_3",
                "generic_lang_code": "var_0",
                "lang_code": "var_1",
                "split": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] get the var_1 dictionary value under the var_0 key , return the result . [SEP]",
        "reference": "return LANG_INFO [ generic_lang_code ]",
        "Output": "return LANG_INFO [ generic_lang_code ]",
        "Var_Maps": [
            {
                "generic_lang_code": "var_0",
                "LANG_INFO": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Key Error : pass",
        "Output": "try : pass except Key Error : pass",
        "Var_Maps": [
            {
                "KeyError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] raise an var_3 with an argument string str_0 , where %s is replaced with var_2 , [SEP]",
        "reference": "raise Key Error ( ` Unknown language code % s and % s . ` % ( lang_code , generic_lang_code ) )",
        "Output": "raise Key Error ( ` Unknown language code % s and % s . ` % ( lang_code , var_4 ( generic_lang_code ) ) )",
        "Var_Maps": [
            {
                "Unknown language code %s and %s.": "var_0",
                "generic_lang_code": "var_1",
                "lang_code": "var_2",
                "KeyError": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] and generic _ lang _ code . call the function var_3 . var_1 with an argument string str_0 , substitute the var_3 sul ##t for var_0 . [SEP]",
        "reference": "trim_whitespace_re = re . compile ( ` \\ \\ s * \\ n \\ \\ s * ` )",
        "Output": "trim_whitespace_re = re . compile ( ` \\ s * \\ s * ` )",
        "Var_Maps": [
            {
                "\\s*\\n\\s*": "str_0",
                "trim_whitespace_re": "var_0",
                "compile": "var_1",
                "\\s*\n\\s*": "var_2",
                "re": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def trim_whitespace ( s ) : pass",
        "Output": "def trim_whitespace ( s ) : pass",
        "Var_Maps": [
            {
                "trim_whitespace": "var_0",
                "s": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call var_3 var_1 var_3 var_4 var_3 of var_3 the var_3 var_4 ur ##rou ##nding var_3 white var_4 pace var_4 , var_3 var_2 var_4 ti ##tute var_3 every var_3 occurrence var_3 of var_3 the var_3 white var_4 pace var_3 in var_3 the var_3 var_0 var_3 with var_3 pre ##vio ##u var_4 var_3 re var_4 ul ##t , var_3 return var_3 the var_3 re var_4 ul ##t . [SEP]",
        "reference": "return trim_whitespace_re . sub ( ` ` , s . strip ( ) )",
        "Output": "return strip . ( ` trim_whitespace_re ` ) . sub ( )",
        "Var_Maps": [
            {
                "trim_whitespace_re": "var_0",
                "strip": "var_1",
                "sub": "var_2",
                " ": "var_3",
                "s": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . conf import settings",
        "Output": "from django . conf import settings",
        "Var_Maps": [
            {
                "django.conf": "var_0",
                "settings": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . utils . encoding import force_text",
        "Output": "from django . utils . encoding import force_text",
        "Var_Maps": [
            {
                "django.utils.encoding": "var_0",
                "force_text": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 and var_2 into default name space . [SEP]",
        "reference": "from django . utils . safestring import mark_safe , Safe Data",
        "Output": "from django . utils . safestring import mark_safe , Safe Data",
        "Var_Maps": [
            {
                "django.utils.safestring": "var_0",
                "mark_safe": "var_1",
                "SafeData": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 3 arguments : var_1 , var_2 and var_3 . [SEP]",
        "reference": "def ngettext ( singular , plural , number ) : pass",
        "Output": "def ngettext ( singular , plural , number ) : pass",
        "Var_Maps": [
            {
                "ngettext": "var_0",
                "singular": "var_1",
                "plural": "var_2",
                "number": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 equals integer 1 , [SEP]",
        "reference": "if number = = 1 : pass",
        "Output": "if number = = 1 : pass",
        "Var_Maps": [
            {
                "number": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return singular",
        "Output": "return singular",
        "Var_Maps": [
            {
                "singular": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return plural",
        "Output": "return plural",
        "Var_Maps": [
            {
                "plural": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "ngettext_lazy = ngettext",
        "Output": "ngettext_lazy = ngettext",
        "Var_Maps": [
            {
                "ngettext_lazy": "var_0",
                "ngettext": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 3 arguments : var_1 , var_2 and var_3 . [SEP]",
        "reference": "def ungettext ( singular , plural , number ) : pass",
        "Output": "def ungettext ( singular , plural , number ) : pass",
        "Var_Maps": [
            {
                "ungettext": "var_0",
                "singular": "var_1",
                "plural": "var_2",
                "number": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 with 3 arguments : var_2 , var_3 and var_4 , use the result as an argument for the call to the var_0 , [SEP]",
        "reference": "return force_text ( ngettext ( singular , plural , number ) )",
        "Output": "return force_text ( ngettext ( singular , plural , number ) )",
        "Var_Maps": [
            {
                "force_text": "var_0",
                "ngettext": "var_1",
                "singular": "var_2",
                "plural": "var_3",
                "number": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] return the result . define the function var_0 with 2 arguments : var_1 and var_2 . [SEP]",
        "reference": "def pgettext ( context , message ) : pass",
        "Output": "def pgettext ( context , message ) : pass",
        "Var_Maps": [
            {
                "pgettext": "var_0",
                "context": "var_1",
                "message": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_1 . [SEP]",
        "reference": "return ugettext ( message )",
        "Output": "ugettext ( message )",
        "Var_Maps": [
            {
                "ugettext": "var_0",
                "message": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function ng ##ette ##xt with 4 arguments : var_2 , var_1 , var_3 and var_4 . [SEP]",
        "reference": "def npgettext ( context , singular , plural , number ) : pass",
        "Output": "def npgettext ( context , singular , plural , number ) : pass",
        "Var_Maps": [
            {
                "npgettext": "var_0",
                "singular": "var_1",
                "context": "var_2",
                "plural": "var_3",
                "number": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with 3 arguments : var_1 , var_2 and var_3 , return the result . [SEP]",
        "reference": "return ungettext ( singular , plural , number )",
        "Output": "return ungettext ( singular , plural , number )",
        "Var_Maps": [
            {
                "ungettext": "var_0",
                "singular": "var_1",
                "plural": "var_2",
                "number": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a lambda function which returns none for any argument var_1 . [SEP]",
        "reference": "activate = lambda x : None",
        "Output": "activate = lambda x = None : x",
        "Var_Maps": [
            {
                "activate": "var_0",
                "x": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 and var_0 are lambda functions returning none . [SEP]",
        "reference": "deactivate = deactivate_all = lambda : None",
        "Output": "deactivate = deactivate_all = lambda var_2 = None : var_3",
        "Var_Maps": [
            {
                "deactivate_all": "var_0",
                "deactivate": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 is a lambda function returning var_2 . var_0 . [SEP]",
        "reference": "get_language = lambda : settings . LANGUAGE_CODE",
        "Output": "get_language = lambda settings : settings . LANGUAGE_CODE",
        "Var_Maps": [
            {
                "LANGUAGE_CODE": "var_0",
                "get_language": "var_1",
                "settings": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is lambda function returning boo ##lean true if var_3 . var_2 is contained in var_3 . var_1 . [SEP]",
        "reference": "get_language_bidi = lambda : settings . LANGUAGE_CODE in settings . LANGUAGES_BIDI",
        "Output": "get_language_bidi = lambda settings : settings . LANGUAGES_BIDI",
        "Var_Maps": [
            {
                "get_language_bidi": "var_0",
                "LANGUAGES_BIDI": "var_1",
                "LANGUAGE_CODE": "var_2",
                "settings": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is lambda function that returns boo ##lean true for every argument var_1 . [SEP]",
        "reference": "check_for_language = lambda x : True",
        "Output": "check_for_language = lambda x : x",
        "Var_Maps": [
            {
                "check_for_language": "var_0",
                "x": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def gettext ( message ) : pass",
        "Output": "def gettext ( message ) : pass",
        "Var_Maps": [
            {
                "gettext": "var_0",
                "message": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 is an instance of var_1 . [SEP]",
        "reference": "if isinstance ( message , Safe Data ) : pass",
        "Output": "if isinstance ( message , Safe Data ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "SafeData": "var_1",
                "message": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_1 , return the result . [SEP]",
        "reference": "return mark_safe ( message )",
        "Output": "return mark_safe ( message )",
        "Var_Maps": [
            {
                "mark_safe": "var_0",
                "message": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return message",
        "Output": "return message",
        "Var_Maps": [
            {
                "message": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def ugettext ( message ) : pass",
        "Output": "def ugettext ( message ) : pass",
        "Var_Maps": [
            {
                "ugettext": "var_0",
                "message": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 with an argument var_2 , use the result as an argument for the call to the var_0 function , return the result . [SEP]",
        "reference": "return force_text ( gettext ( message ) )",
        "Output": "return force_text ( gettext ( message ) )",
        "Var_Maps": [
            {
                "force_text": "var_0",
                "gettext": "var_1",
                "message": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var var_3 2 for var var_3 0 , var var_3 1 and var_3 . [SEP]",
        "reference": "gettext_noop = gettext_lazy = _ = gettext",
        "Output": "gettext_noop , gettext_lazy , _ = ` gettext `",
        "Var_Maps": [
            {
                "gettext_noop": "var_0",
                "gettext_lazy": "var_1",
                "gettext": "var_2",
                "_": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def to_locale ( language ) : pass",
        "Output": "def to_locale ( language ) : pass",
        "Var_Maps": [
            {
                "to_locale": "var_0",
                "language": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 var_2 os ##ition of str_0 in the index of the var_0 , substitute the result for var_2 . [SEP]",
        "reference": "p = language . find ( ` - ` )",
        "Output": "p = language [ ` - ` ] . find ( ` - ` )",
        "Var_Maps": [
            {
                "-": "var_3",
                "language": "var_0",
                "find": "var_1",
                "p": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is greater or equal to integer 0 , [SEP]",
        "reference": "if p > = 0 : pass",
        "Output": "if p > = 0 : pass",
        "Var_Maps": [
            {
                "p": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] ava ##r var_5 4 ##var var_5 4 ##end st ##r var_5 0 to string created from first var var_5 4 elements of var var_5 0 ##s converted to var var_5 2 ##case , [SEP]",
        "reference": "return language [ : p ] . lower ( ) + ` _ ` + language [ p + 1 : ] . upper ( )",
        "Output": "lower [ 0 ] = ` _ ` . var_4 ( var_0 . lower ( ` _ ` ) . upper ( ) )",
        "Var_Maps": [
            {
                "_": "var_5",
                "language": "var_1",
                "lower": "var_2",
                "upper": "var_3",
                "p": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] convert slice of language string from ( p + 1 ) - th index to the end to upper ##case , app ##end it to the previous result , return the resulting string . if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] convert var_0 to var_1 case and return it . [SEP]",
        "reference": "return language . lower ( )",
        "Output": "return language . lower ( )",
        "Var_Maps": [
            {
                "language": "var_0",
                "lower": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 2 arguments : var_2 and var_1 set to boo ##lean false . [SEP]",
        "reference": "def get_language_from_request ( request , check_path = False ) : pass",
        "Output": "def get_language_from_request ( request , check_path = ` False ` ) : pass",
        "Var_Maps": [
            {
                "get_language_from_request": "var_0",
                "check_path": "var_1",
                "request": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_1 . var_0 . [SEP]",
        "reference": "return settings . LANGUAGE_CODE",
        "Output": "return settings . LANGUAGE_CODE",
        "Var_Maps": [
            {
                "LANGUAGE_CODE": "var_0",
                "settings": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def get_language_from_path ( request ) : pass",
        "Output": "def get_language_from_path ( request ) : pass",
        "Var_Maps": [
            {
                "get_language_from_path": "var_0",
                "request": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return none . [SEP]",
        "reference": "return None",
        "Output": "return None",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] from var_1 import var_0 into default name space . [SEP]",
        "reference": "from __future__ import unicode_literals",
        "Output": "from __future__ import unicode_literals",
        "Var_Maps": [
            {
                "unicode_literals": "var_0",
                "__future__": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from collections import Ordered Dict",
        "Output": "from collections import Ordered Dict",
        "Var_Maps": [
            {
                "collections": "var_0",
                "OrderedDict": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_0 . [SEP]",
        "reference": "import os",
        "Output": "import os",
        "Var_Maps": [
            {
                "os": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_0 . [SEP]",
        "reference": "import re",
        "Output": "import re",
        "Var_Maps": [
            {
                "re": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_0 . [SEP]",
        "reference": "import sys",
        "Output": "import sys",
        "Var_Maps": [
            {
                "sys": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_1 as var_0 . [SEP]",
        "reference": "import gettext as gettext_module",
        "Output": "import gettext as gettext_module",
        "Var_Maps": [
            {
                "gettext_module": "var_0",
                "gettext": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from threading import local",
        "Output": "from threading import local",
        "Var_Maps": [
            {
                "threading": "var_0",
                "local": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_0 . [SEP]",
        "reference": "import warnings",
        "Output": "import warnings",
        "Var_Maps": [
            {
                "warnings": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . apps import apps",
        "Output": "from django . apps import apps",
        "Var_Maps": [
            {
                "django.apps": "var_0",
                "apps": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . conf import settings",
        "Output": "from django . conf import settings",
        "Var_Maps": [
            {
                "django.conf": "var_0",
                "settings": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . core . exceptions import App Registry Not Ready",
        "Output": "from django . core . exceptions import App Registry Not Ready",
        "Var_Maps": [
            {
                "django.core.exceptions": "var_0",
                "AppRegistryNotReady": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . dispatch import receiver",
        "Output": "from django . dispatch import receiver",
        "Var_Maps": [
            {
                "django.dispatch": "var_0",
                "receiver": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . test . signals import setting_changed",
        "Output": "from django . test . signals import setting_changed",
        "Var_Maps": [
            {
                "django.test.signals": "var_0",
                "setting_changed": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . utils . deprecation import Removed In Django19Warning",
        "Output": "from django . utils . deprecation import Removed In Django19Warning",
        "Var_Maps": [
            {
                "django.utils.deprecation": "var_0",
                "RemovedInDjango19Warning": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . utils . encoding import force_text",
        "Output": "from django . utils . encoding import force_text",
        "Var_Maps": [
            {
                "django.utils.encoding": "var_0",
                "force_text": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . utils . _os import upath",
        "Output": "from django . utils . _os import upath",
        "Var_Maps": [
            {
                "django.utils._os": "var_0",
                "upath": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 and var_2 into default name space . [SEP]",
        "reference": "from django . utils . safestring import mark_safe , Safe Data",
        "Output": "from django . utils . safestring import mark_safe , Safe Data",
        "Var_Maps": [
            {
                "django.utils.safestring": "var_0",
                "mark_safe": "var_1",
                "SafeData": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_2 and var_1 into default name space . [SEP]",
        "reference": "from django . utils import six , lru_cache",
        "Output": "from django . utils import six , lru_cache",
        "Var_Maps": [
            {
                "django.utils": "var_0",
                "lru_cache": "var_1",
                "six": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . utils . six import String IO",
        "Output": "from django . utils . six import String IO",
        "Var_Maps": [
            {
                "django.utils.six": "var_0",
                "StringIO": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 , var_3 and var_2 into default name space . [SEP]",
        "reference": "from django . utils . translation import Translator Comment Warning , trim_whitespace , LANGUAGE_SESSION_KEY",
        "Output": "from django . utils . translation import Translator Comment Warning , trim_whitespace , LANGUAGE_SESSION_KEY",
        "Var_Maps": [
            {
                "django.utils.translation": "var_0",
                "TranslatorCommentWarning": "var_1",
                "LANGUAGE_SESSION_KEY": "var_2",
                "trim_whitespace": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an empty dictionary . [SEP]",
        "reference": "_translations = { }",
        "Output": "_translations = { }",
        "Var_Maps": [
            {
                "_translations": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 , substitute the result for var_0 . [SEP]",
        "reference": "_active = local ( )",
        "Output": "_active = local ( )",
        "Var_Maps": [
            {
                "_active": "var_0",
                "local": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is none . [SEP]",
        "reference": "_default = None",
        "Output": "_default = None",
        "Var_Maps": [
            {
                "_default": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is none . [SEP]",
        "reference": "_supported = None",
        "Output": "_supported = None",
        "Var_Maps": [
            {
                "_supported": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "CONTEXT_SEPARATOR = ` \\ x04 `",
        "Output": "CONTEXT_SEPARATOR = ` \u0004 `",
        "Var_Maps": [
            {
                "\\x04": "str_0",
                "CONTEXT_SEPARATOR": "var_0",
                "\u0004": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] and var_4 . verb ##ose , substitute the var_4 sul ##t for accept _ language _ var_4 . call the function var_4 . var_3 with 2 arguments : raw string str_0 and var_4 . var_2 , [SEP]",
        "reference": "language_code_re = re . compile ( ` ^ [ a - z ] { 1 , 8 } ( ? : - [ a - z0 - 9 ] { 1 , 8 } ) * $ ` , re . IGNORECASE )",
        "Output": "re . language_code_re = re . compile ( ` ^ [ a - z ] { 1 , 8 } ( ? : - [ a - z0 - 9 ] { 1 , 8 } ) * $ ` , re . IGNORECASE )",
        "Var_Maps": [
            {
                "^[a-z]{1,8}(?:-[a-z0-9]{1,8})*$": "var_0",
                "language_code_re": "var_1",
                "IGNORECASE": "var_2",
                "compile": "var_3",
                "re": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] substitute the var_3 sul ##t for language _ code _ var_3 . call the function var_3 . var_2 with an argument raw string str_0 , substitute the var_3 sul ##t for var_0 . [SEP]",
        "reference": "language_code_prefix_re = re . compile ( ` ^ / ( [ \\ \\ w - ] + ) ( / | $ ) ` )",
        "Output": "language_code_prefix_re = re . compile ( ` ^ / ( [ \\ w - ] + ) ( / | $ ) ` )",
        "Var_Maps": [
            {
                "^/([\\w-]+)(/|$)": "var_1",
                "language_code_prefix_re": "var_0",
                "compile": "var_2",
                "re": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an dictionary with 2 initial entries : str_0 for str_1 and str_2 for str_3 . [SEP]",
        "reference": "_BROWSERS_DEPRECATED_LOCALES = { ` zh - cn ` : ` zh - hans ` , ` zh - tw ` : ` zh - hant ` }",
        "Output": "_BROWSERS_DEPRECATED_LOCALES = { ` zh - cn ` : ` zh - hans ` , ` zh - tw ` : ` zh - hant ` }",
        "Var_Maps": [
            {
                "zh-hans": "var_1",
                "zh-cn": "var_3",
                "zh-hant": "var_2",
                "zh-tw": "var_4",
                "_BROWSERS_DEPRECATED_LOCALES": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_1 . [SEP]",
        "reference": "_DJANGO_DEPRECATED_LOCALES = _BROWSERS_DEPRECATED_LOCALES",
        "Output": "_DJANGO_DEPRECATED_LOCALES = _BROWSERS_DEPRECATED_LOCALES",
        "Var_Maps": [
            {
                "_BROWSERS_DEPRECATED_LOCALES": "var_0",
                "_DJANGO_DEPRECATED_LOCALES": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] decor ##ator function var_1 with an argument var_0 , [SEP]",
        "reference": "@ receiver ( setting_changed ) def dummy ( ) : pass",
        "Output": "@ receiver ( setting_changed ) def setting_changed ( ) : pass",
        "Var_Maps": [
            {
                "setting_changed": "var_0",
                "receiver": "var_1",
                "dummy": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument un ##pack ##ed dictionary var_1 . [SEP]",
        "reference": "def reset_cache ( * * kwargs ) : pass",
        "Output": "def reset_cache ( * * kwargs ) : pass",
        "Var_Maps": [
            {
                "reset_cache": "var_0",
                "kwargs": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if value under the str_0 key of the var_3 dictionary is equal to string str_1 or st ##rn ##ig str_2 , [SEP]",
        "reference": "if kwargs [ ` setting ` ] in ( ` LANGUAGES ` , ` LANGUAGE_CODE ` ) : pass",
        "Output": "if kwargs [ ` LANGUAGES ` ] in ( ` setting ` , ` LANGUAGE_CODE ` ) : pass",
        "Var_Maps": [
            {
                "setting": "var_2",
                "LANGUAGES": "var_1",
                "LANGUAGE_CODE": "var_0",
                "kwargs": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] use global variable var_0 . [SEP]",
        "reference": "global _supported",
        "Output": "",
        "Var_Maps": [
            {
                "_supported": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is none . [SEP]",
        "reference": "_supported = None",
        "Output": "_supported = None",
        "Var_Maps": [
            {
                "_supported": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_1 . [SEP]",
        "reference": "check_for_language . cache_clear ( )",
        "Output": "check_for_language . cache_clear ( )",
        "Var_Maps": [
            {
                "check_for_language": "var_0",
                "cache_clear": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_1 . [SEP]",
        "reference": "get_supported_language_variant . cache_clear ( )",
        "Output": "get_supported_language_variant . cache_clear ( )",
        "Var_Maps": [
            {
                "get_supported_language_variant": "var_0",
                "cache_clear": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 2 arguments var_1 and var_2 set to boo ##lean false . [SEP]",
        "reference": "def to_locale ( language , to_lower = False ) : pass",
        "Output": "def to_locale ( language , to_lower = ` False ` ) : pass",
        "Var_Maps": [
            {
                "to_locale": "var_0",
                "language": "var_1",
                "to_lower": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 first index of occurrence of character str_0 in var_0 , substitute it for var_2 . [SEP]",
        "reference": "p = language . find ( ` - ` )",
        "Output": "p = language . find ( ` - ` )",
        "Var_Maps": [
            {
                "-": "var_3",
                "language": "var_0",
                "find": "var_1",
                "p": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is greater or equal to integer 0 , [SEP]",
        "reference": "if p > = 0 : pass",
        "Output": "if p > = 0 : pass",
        "Var_Maps": [
            {
                "p": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if to_lower : pass",
        "Output": "if to_lower : pass",
        "Var_Maps": [
            {
                "to_lower": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] convert fist var var_5 4 elements of var var_5 0 to var var_5 2 ##case , ava ##r var_5 4 ##var var_5 4 ##end st ##r var_5 0 to it , [SEP]",
        "reference": "return language [ : p ] . lower ( ) + ` _ ` + language [ p + 1 : ] . lower ( )",
        "Output": "var_2 = var_4 . language ( var_2 [ : ] ) . lower ( )",
        "Var_Maps": [
            {
                "_": "var_5",
                "language": "var_1",
                "lower": "var_3",
                "p": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] covert to lower ##case language elements from ( p + 1 ) - th index to the end , app ##end it to the previous result , return it . if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] slice var_0 from ( var_2 + 1 ) - th index to the end , calculate the var_1 gt ##h of the obtained segment , if it is greater than integer 2 , [SEP]",
        "reference": "if len ( language [ p + 1 : ] ) > 2 : pass",
        "Output": "language = len ( language [ 1 : ] )",
        "Var_Maps": [
            {
                "language": "var_0",
                "len": "var_1",
                "p": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] convert fist var ##var _ 76 elements of var ##var _ 70 to var ##var _ 73 ##case , ava ##rva ##r _ 76 ##var ##var _ 76 ##end st ##rva ##r _ 70 to it , [SEP]",
        "reference": "return language [ : p ] . lower ( ) + ` _ ` + language [ p + 1 ] . upper ( ) + language [ p + 2 : ] . lower ( )",
        "Output": "language = var_6 . var_3 ( ) . var_0 ( var_1 )",
        "Var_Maps": [
            {
                "_": "var_7",
                "language": "var_2",
                "lower": "var_5",
                "upper": "var_4",
                "p": "var_9"
            }
        ]
    },
    {
        "intent": "[CLS] covert to var var_5 2 ##case var var_5 0 element at ( var var_5 4 + 1 ) - th index , ava ##r var_5 4 ##var var_5 4 ##end it to the var var_5 4 ##re ##vious result , covert to var var_5 2 ##case var var_5 0 elements from ( var var_5 4 + 2 ) - th index to the end , ava ##r var_5 4 ##var var_5 4 ##end it to the var var_5 4 ##re ##vious result , return it . convert fist var var_5 4 elements of var var_5 0 to var var_5 2 ##case , ava ##r var_5 4 ##var var_5 4 ##end st ##r var_5 0 to it , [SEP]",
        "reference": "return language [ : p ] . lower ( ) + ` _ ` + language [ p + 1 : ] . upper ( )",
        "Output": "return var_0 ( lower [ ` _ ` ] ) . upper ( ) + language4 [ 1 : ]",
        "Var_Maps": [
            {
                "_": "var_5",
                "language": "var_1",
                "lower": "var_2",
                "upper": "var_3",
                "p": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] covert to upper ##case language elements from ( p + 1 ) - th index to the end , app ##end it to the previous result , return it . if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] convert var_0 to var_1 case , return it . [SEP]",
        "reference": "return language . lower ( )",
        "Output": "return language . lower ( )",
        "Var_Maps": [
            {
                "language": "var_0",
                "lower": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def to_language ( locale ) : pass",
        "Output": "def to_language ( locale ) : pass",
        "Var_Maps": [
            {
                "to_language": "var_0",
                "locale": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var var_3 1 first index of occurrence of character st ##r var_3 0 in var var_3 0 , substitute it for var var_3 2 . [SEP]",
        "reference": "p = locale . find ( ` _ ` )",
        "Output": "p = find . p ( ` _ ` , ` locale ` )",
        "Var_Maps": [
            {
                "-": "str_0",
                "locale": "var_0",
                "find": "var_1",
                "p": "var_2",
                "_": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is greater or equal to integer 0 , [SEP]",
        "reference": "if p > = 0 : pass",
        "Output": "if p > = 0 : pass",
        "Var_Maps": [
            {
                "p": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] convert fist var_4 elements of var_0 to var_2 case , a var_4 var_4 end str_0 to it , [SEP]",
        "reference": "return locale [ : p ] . lower ( ) + ` - ` + locale [ p + 1 : ] . lower ( )",
        "Output": "lower . var_2 ( ) . locale ( ` var_7 ` )",
        "Var_Maps": [
            {
                "_": "str_0",
                "locale": "var_1",
                "lower": "var_3",
                "p": "var_6",
                "-": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] covert to lower ##case local ##e elements from ( p + 1 ) - th index to the end , app ##end it to the previous result , return it . if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] convert var_0 to var_1 case and return it . [SEP]",
        "reference": "return locale . lower ( )",
        "Output": "return locale . lower ( )",
        "Var_Maps": [
            {
                "locale": "var_0",
                "lower": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] derive the class var_0 from var_2 . var_1 base class . [SEP]",
        "reference": "class Django Translation ( gettext_module . GNUTranslations ) : pass",
        "Output": "class Django Translation ( gettext_module . GNUTranslations ) : pass",
        "Var_Maps": [
            {
                "DjangoTranslation": "var_0",
                "GNUTranslations": "var_1",
                "gettext_module": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments : var_2 and var_1 . [SEP]",
        "reference": "def __init__ ( self , language ) : pass",
        "Output": "def __init__ ( self , language ) : pass",
        "Var_Maps": [
            {
                "__init__": "var_0",
                "language": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_0 . var_2 with an argument var_3 . [SEP]",
        "reference": "gettext_module . GNUTranslations . __init__ ( self )",
        "Output": "gettext_module . GNUTranslations . __init__ ( self )",
        "Var_Maps": [
            {
                "GNUTranslations": "var_0",
                "gettext_module": "var_1",
                "__init__": "var_2",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_2 . var_0 . [SEP]",
        "reference": "self . __language = language",
        "Output": "self . __language = language",
        "Var_Maps": [
            {
                "__language": "var_0",
                "language": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 with an argument var_2 , substitute it for var_3 . var_0 . [SEP]",
        "reference": "self . __to_language = to_language ( language )",
        "Output": "self . __to_language = to_language ( language )",
        "Var_Maps": [
            {
                "__to_language": "var_0",
                "to_language": "var_1",
                "language": "var_2",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_2 , substitute it for var_3 . var_1 . [SEP]",
        "reference": "self . __locale = to_locale ( language )",
        "Output": "self . __locale = to_locale ( language )",
        "Var_Maps": [
            {
                "to_locale": "var_0",
                "__locale": "var_1",
                "language": "var_2",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 . var_0 is a var_3 lambda fu var_3 ct ##io var_3 with a var_3 ar ##gum ##e var_3 t var_3 , which re ##tur var_3 s result of boo ##lea var_3 express ##io var_3 var_3 var_3 ot equal to var_2 e ##ger 1 , [SEP]",
        "reference": "self . plural = lambda n : int ( n ! = 1 )",
        "Output": "self . plural = lambda var_6 = var_3 ( int ) : self = = 1",
        "Var_Maps": [
            {
                "plural": "var_0",
                "self": "var_1",
                "int": "var_2",
                "n": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] converted to an integer . call the method var_1 . var_0 . [SEP]",
        "reference": "self . _init_translation_catalog ( )",
        "Output": "self . _init_translation_catalog ( )",
        "Var_Maps": [
            {
                "_init_translation_catalog": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_0 . [SEP]",
        "reference": "self . _add_installed_apps_translations ( )",
        "Output": "self . _add_installed_apps_translations ( )",
        "Var_Maps": [
            {
                "_add_installed_apps_translations": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_0 . [SEP]",
        "reference": "self . _add_local_translations ( )",
        "Output": "self . _add_local_translations ( )",
        "Var_Maps": [
            {
                "_add_local_translations": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_0 . [SEP]",
        "reference": "self . _add_fallback ( )",
        "Output": "self . _add_fallback ( )",
        "Var_Maps": [
            {
                "_add_fallback": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def __repr__ ( self ) : pass",
        "Output": "def __repr__ ( self ) : pass",
        "Var_Maps": [
            {
                "__repr__": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return a string str_0 , where %s is replaced with var_2 . var_1 . [SEP]",
        "reference": "return ` < Django Translation lang : % s > ` % self . __language",
        "Output": "return ` < Django Translation lang : % s > ` % self . __language",
        "Var_Maps": [
            {
                "<DjangoTranslation lang:%s>": "var_0",
                "__language": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_1 with 3 arguments : var_3 , var_2 and var_0 set to boo ##lean true . [SEP]",
        "reference": "def _new_gnu_trans ( self , localedir , use_null_fallback = True ) : pass",
        "Output": "def _new_gnu_trans ( self , localedir , use_null_fallback = ` True ` ) : pass",
        "Var_Maps": [
            {
                "use_null_fallback": "var_0",
                "_new_gnu_trans": "var_1",
                "localedir": "var_2",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_2 with 5 arguments : var_1 0 set to string str_0 , var_4 set to var_4 , [SEP]",
        "reference": "translation = gettext_module . translation ( domain = ` django ` , localedir = localedir , languages = [ self . __locale ] , codeset = ` utf - 8 ` , fallback = use_null_fallback )",
        "Output": "gettext_module . var_2 ( gettext_module0 = ` translation ` , localedir = ` fallback ` , localedir = ` use_null_fallback ` )",
        "Var_Maps": [
            {
                "django": "var_11",
                "use_null_fallback": "var_0",
                "gettext_module": "var_1",
                "translation": "var_3",
                "localedir": "var_5",
                "languages": "var_6",
                "__locale": "var_7",
                "fallback": "var_8",
                "codeset": "var_9",
                "domain": "var_10",
                "utf-8": "var_12",
                "self": "var_13"
            }
        ]
    },
    {
        "intent": "[CLS] languages set to a list with an element self . _ _ local ##e , codes ##et set to a string str_0 and fall ##back set to use _ null _ fall ##back , substitute the result for var_0 . if var_0 has an attribute str_1 , [SEP]",
        "reference": "if not hasattr ( translation , ` _catalog ` ) : pass",
        "Output": "if _catalog ( translation , ` hasattr ` ) : pass",
        "Var_Maps": [
            {
                "utf-8": "str_0",
                "_catalog": "var_1",
                "translation": "var_0",
                "hasattr": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 . var_1 is an empty dictionary . [SEP]",
        "reference": "translation . _catalog = { }",
        "Output": "translation . _catalog = { }",
        "Var_Maps": [
            {
                "translation": "var_0",
                "_catalog": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 . var_1 is an empty dictionary . [SEP]",
        "reference": "translation . _info = { }",
        "Output": "translation . _info = { }",
        "Var_Maps": [
            {
                "translation": "var_0",
                "_info": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return translation",
        "Output": "return translation",
        "Var_Maps": [
            {
                "translation": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def _init_translation_catalog ( self ) : pass",
        "Output": "def _init_translation_catalog ( self ) : pass",
        "Var_Maps": [
            {
                "_init_translation_catalog": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] get the value under the var_2 . var_1 key of the var_6 . var_4 dictionary , [SEP]",
        "reference": "settingsfile = upath ( sys . modules [ settings . __module__ ] . __file__ )",
        "Output": "sys . modules [ sys . __module__ ] = settings . modules [ settings . __module__ ]",
        "Var_Maps": [
            {
                "settingsfile": "var_0",
                "__module__": "var_1",
                "settings": "var_2",
                "__file__": "var_3",
                "modules": "var_4",
                "upath": "var_5",
                "sys": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] use its _ _ file _ _ field as an argument for the call to the function u var_4 , substitute the result for var_0 . call the function var _ 7 . var_4 . var_2 with an argument var_0 , var_5 the result an string str_0 into a file var_4 , [SEP]",
        "reference": "localedir = os . path . join ( os . path . dirname ( settingsfile ) , ` locale ` )",
        "Output": "localedir = var_7 . join . dirname ( var_7 . join . join ( localedir ) , ` locale ` )",
        "Var_Maps": [
            {
                "locale": "var_3",
                "settingsfile": "var_0",
                "localedir": "var_1",
                "dirname": "var_2",
                "path": "var_6",
                "join": "var_5",
                "os": "var_8"
            }
        ]
    },
    {
        "intent": "[CLS] substitute it for local ##ed ##ir . var_0 is boo ##lean true . [SEP]",
        "reference": "use_null_fallback = True",
        "Output": "use_null_fallback = ` True `",
        "Var_Maps": [
            {
                "use_null_fallback": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_3 . var_1 equals var_2 . var_0 , [SEP]",
        "reference": "if self . __language = = settings . LANGUAGE_CODE : pass",
        "Output": "if self . __language = = settings . LANGUAGE_CODE : pass",
        "Var_Maps": [
            {
                "LANGUAGE_CODE": "var_0",
                "__language": "var_1",
                "settings": "var_2",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is boo ##lean false . [SEP]",
        "reference": "use_null_fallback = False",
        "Output": "use_null_fallback = ` False `",
        "Var_Maps": [
            {
                "use_null_fallback": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_4 . var_1 with 2 arguments : var_3 and var_0 , substitute the result for var_2 . [SEP]",
        "reference": "translation = self . _new_gnu_trans ( localedir , use_null_fallback )",
        "Output": "translation = self . _new_gnu_trans ( localedir , use_null_fallback )",
        "Var_Maps": [
            {
                "use_null_fallback": "var_0",
                "_new_gnu_trans": "var_1",
                "translation": "var_2",
                "localedir": "var_3",
                "self": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_1 . var_4 , substitute the result for var_3 . var_1 . [SEP]",
        "reference": "self . _info = translation . _info . copy ( )",
        "Output": "self . _info = translation . _info . copy ( )",
        "Var_Maps": [
            {
                "translation": "var_0",
                "_info": "var_2",
                "self": "var_3",
                "copy": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_1 . var_4 , substitute the result for var_3 . var_1 . [SEP]",
        "reference": "self . _catalog = translation . _catalog . copy ( )",
        "Output": "self . _catalog = translation . _catalog . copy ( )",
        "Var_Maps": [
            {
                "translation": "var_0",
                "_catalog": "var_2",
                "self": "var_3",
                "copy": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def _add_installed_apps_translations ( self ) : pass",
        "Output": "def _add_installed_apps_translations ( self ) : pass",
        "Var_Maps": [
            {
                "_add_installed_apps_translations": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the method var_4 . var_0 , convert the result in a var_3 , reverse the order of elements , substitute the result for var_1 . [SEP]",
        "reference": "app_configs = reversed ( list ( apps . get_app_configs ( ) ) )",
        "Output": "app_configs = list ( apps . get_app_configs ( ) )",
        "Var_Maps": [
            {
                "get_app_configs": "var_0",
                "app_configs": "var_1",
                "reversed": "var_2",
                "list": "var_3",
                "apps": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except App Registry Not Ready : pass",
        "Output": "try : pass except App Registry Not Ready : pass",
        "Var_Maps": [
            {
                "AppRegistryNotReady": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] rai ##s an var_1 exception with an argument string str_0 [SEP]",
        "reference": "raise App Registry Not Ready ( ` The translation infrastructure cannot be initialized before the apps registry is ready . Check that you don ` t make non - lazy gettext calls at import time . ` )",
        "Output": "raise App Registry Not Ready ( ` The translation infrastructure cannot be initialized before the apps registry is ready . Check that you don ` t make non - lazy gettext calls at import time . ` % var_2 )",
        "Var_Maps": [
            {
                "The translation infrastructure cannot be initialized before the ": "str_0",
                "The translation infrastructure cannot be initialized before the apps registry is ready. Check that you don't make non-lazy gettext calls at import time.": "var_0",
                "AppRegistryNotReady": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] str_0 . for every var_1 in var_0 , [SEP]",
        "reference": "for app_config in app_configs : pass",
        "Output": "for app_config in app_configs : pass",
        "Var_Maps": [
            {
                "apps registry is ready. Check that you don't make non-lazy gettext calls at import time.": "str_0",
                "app_configs": "var_0",
                "app_config": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_4 var_0 . var_3 and string str_0 into a file var_3 , substitute it for var_1 . [SEP]",
        "reference": "localedir = os . path . join ( app_config . path , ` locale ` )",
        "Output": "localedir = os . path . join ( app_config . path , ` locale ` )",
        "Var_Maps": [
            {
                "locale": "var_2",
                "app_config": "var_0",
                "localedir": "var_1",
                "path": "var_5",
                "join": "var_4",
                "os": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_3 . var_0 with an argument var_2 , substitute the result for var_1 . [SEP]",
        "reference": "translation = self . _new_gnu_trans ( localedir )",
        "Output": "translation = self . _new_gnu_trans ( localedir )",
        "Var_Maps": [
            {
                "_new_gnu_trans": "var_0",
                "translation": "var_1",
                "localedir": "var_2",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_1 with an argument var_0 . [SEP]",
        "reference": "self . merge ( translation )",
        "Output": "self . merge ( translation )",
        "Var_Maps": [
            {
                "translation": "var_0",
                "merge": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def _add_local_translations ( self ) : pass",
        "Output": "def _add_local_translations ( self ) : pass",
        "Var_Maps": [
            {
                "_add_local_translations": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] reverse var_3 . var_0 element order , for every var_1 in the result , [SEP]",
        "reference": "for localedir in reversed ( settings . LOCALE_PATHS ) : pass",
        "Output": "for localedir in reversed ( settings . LOCALE_PATHS ) : pass",
        "Var_Maps": [
            {
                "LOCALE_PATHS": "var_0",
                "localedir": "var_1",
                "reversed": "var_2",
                "settings": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_3 . var_0 with an argument var_2 , substitute the result for var_1 . [SEP]",
        "reference": "translation = self . _new_gnu_trans ( localedir )",
        "Output": "translation = self . _new_gnu_trans ( localedir )",
        "Var_Maps": [
            {
                "_new_gnu_trans": "var_0",
                "translation": "var_1",
                "localedir": "var_2",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_1 with an argument var_0 . [SEP]",
        "reference": "self . merge ( translation )",
        "Output": "self . merge ( translation )",
        "Var_Maps": [
            {
                "translation": "var_0",
                "merge": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def _add_fallback ( self ) : pass",
        "Output": "def _add_fallback ( self ) : pass",
        "Var_Maps": [
            {
                "_add_fallback": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_5 . var_1 equals var_3 . var_0 or var_5 . var_1 equals a string str_0 , [SEP]",
        "reference": "if self . __language = = settings . LANGUAGE_CODE or self . __language = = ` en - us ` : pass",
        "Output": "if var_7 . __language = = settings . LANGUAGE_CODE or var_7 . __language = = ` en - us ` : pass",
        "Var_Maps": [
            {
                "en-us": "var_4",
                "LANGUAGE_CODE": "var_0",
                "__language": "var_2",
                "settings": "var_3",
                "self": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] return . [SEP]",
        "reference": "return",
        "Output": "return",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the function var_2 with an argument var_3 . var_1 , substitute the result for var_0 . [SEP]",
        "reference": "default_translation = translation ( settings . LANGUAGE_CODE )",
        "Output": "default_translation = translation ( settings . LANGUAGE_CODE )",
        "Var_Maps": [
            {
                "default_translation": "var_0",
                "LANGUAGE_CODE": "var_1",
                "translation": "var_2",
                "settings": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_1 with an argument var_0 . [SEP]",
        "reference": "self . add_fallback ( default_translation )",
        "Output": "self . add_fallback ( default_translation )",
        "Var_Maps": [
            {
                "default_translation": "var_0",
                "add_fallback": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments var_2 and var_1 . [SEP]",
        "reference": "def merge ( self , other ) : pass",
        "Output": "def merge ( self , other ) : pass",
        "Var_Maps": [
            {
                "merge": "var_0",
                "other": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 the var_4 . var_0 dictionary with var_3 . var_0 . [SEP]",
        "reference": "self . _catalog . update ( other . _catalog )",
        "Output": "self . _catalog . update ( other . _catalog )",
        "Var_Maps": [
            {
                "_catalog": "var_1",
                "update": "var_2",
                "other": "var_3",
                "self": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def language ( self ) : pass",
        "Output": "def language ( self ) : pass",
        "Var_Maps": [
            {
                "language": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return var_1 . var_0 . [SEP]",
        "reference": "return self . __language",
        "Output": "return self . __language",
        "Var_Maps": [
            {
                "__language": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def to_language ( self ) : pass",
        "Output": "def to_language ( self ) : pass",
        "Var_Maps": [
            {
                "to_language": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return var_1 . var_0 . [SEP]",
        "reference": "return self . __to_language",
        "Output": "return self . __to_language",
        "Var_Maps": [
            {
                "__to_language": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def translation ( language ) : pass",
        "Output": "def translation ( language ) : pass",
        "Var_Maps": [
            {
                "translation": "var_0",
                "language": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] use global variable var_0 . [SEP]",
        "reference": "global _translations",
        "Output": "",
        "Var_Maps": [
            {
                "_translations": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 is not contained in var_0 , [SEP]",
        "reference": "if language not in _translations : pass",
        "Output": "if language not in _translations : pass",
        "Var_Maps": [
            {
                "_translations": "var_0",
                "language": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 dictionary value , under the var_2 key is an instance of var_0 class , created with an argument var_2 . [SEP]",
        "reference": "_translations [ language ] = Django Translation ( language )",
        "Output": "_translations [ language ] = Django Translation ( language )",
        "Var_Maps": [
            {
                "DjangoTranslation": "var_0",
                "_translations": "var_1",
                "language": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 dictionary value , under the var_1 key . [SEP]",
        "reference": "return _translations [ language ]",
        "Output": "return _translations [ language ]",
        "Var_Maps": [
            {
                "_translations": "var_0",
                "language": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def activate ( language ) : pass",
        "Output": "def activate ( language ) : pass",
        "Var_Maps": [
            {
                "activate": "var_0",
                "language": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 is contained in var_0 , [SEP]",
        "reference": "if language in _DJANGO_DEPRECATED_LOCALES : pass",
        "Output": "if language in _DJANGO_DEPRECATED_LOCALES : pass",
        "Var_Maps": [
            {
                "_DJANGO_DEPRECATED_LOCALES": "var_0",
                "language": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 is a string str_0 . [SEP]",
        "reference": "msg = ( ` The use of the language code ` % s ` is deprecated . Please use the ` % s ` translation instead . ` )",
        "Output": "msg = ` The use of the language code ` % s ` is deprecated . Please use the ` % s ` translation instead . `",
        "Var_Maps": [
            {
                "The use of the language code '%s' is deprecated. Please use the '%s' translation instead.": "var_0",
                "msg": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method call the function var_3 . var_6 with 3 arguments : var _ 7 format ##ted with var_4 and value under the var_4 key , [SEP]",
        "reference": "warnings . warn ( msg % ( language , _DJANGO_DEPRECATED_LOCALES [ language ] ) , Removed In Django19Warning , stacklevel = 2 )",
        "Output": "warnings . warn ( msg % language . warn ( language , stacklevel [ ` _DJANGO_DEPRECATED_LOCALES ` ] ) )",
        "Var_Maps": [
            {
                "_DJANGO_DEPRECATED_LOCALES": "var_0",
                "RemovedInDjango19Warning": "var_1",
                "stacklevel": "var_2",
                "warnings": "var_3",
                "language": "var_5",
                "warn": "var_6",
                "msg": "var_7"
            }
        ]
    },
    {
        "intent": "[CLS] of the _ dj ##ango _ de ##pre ##cated _ local ##es dictionary , removed ##ind ##jan ##go ##19 ##war ##ning and stack ##lev ##el set to integer 2 . call the function var_0 with an argument var_1 , substitute the result for var_2 . var_3 . [SEP]",
        "reference": "_active . value = translation ( language )",
        "Output": "_active . value = translation ( language )",
        "Var_Maps": [
            {
                "translation": "var_0",
                "language": "var_1",
                "_active": "var_2",
                "value": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 . [SEP]",
        "reference": "def deactivate ( ) : pass",
        "Output": "def deactivate ( ) : pass",
        "Var_Maps": [
            {
                "deactivate": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 has an attribute str_0 , [SEP]",
        "reference": "if hasattr ( _active , ` value ` ) : pass",
        "Output": "if hasattr ( _active , ` value ` ) : pass",
        "Var_Maps": [
            {
                "value": "var_2",
                "hasattr": "var_0",
                "_active": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] del ##ete var_0 . var_1 . [SEP]",
        "reference": "del _active . value",
        "Output": "del _active . value",
        "Var_Maps": [
            {
                "_active": "var_0",
                "value": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 . [SEP]",
        "reference": "def deactivate_all ( ) : pass",
        "Output": "def deactivate_all ( ) : pass",
        "Var_Maps": [
            {
                "deactivate_all": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_0 , substitute the result for var_2 . var_3 . [SEP]",
        "reference": "_active . value = gettext_module . Null Translations ( )",
        "Output": "_active . value = gettext_module . Null Translations ( )",
        "Var_Maps": [
            {
                "NullTranslations": "var_0",
                "gettext_module": "var_1",
                "_active": "var_2",
                "value": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 . [SEP]",
        "reference": "def get_language ( ) : pass",
        "Output": "def get_language ( ) : pass",
        "Var_Maps": [
            {
                "get_language": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] ge var_3 s var_3 r _ 0 a var_3 var_3 rib ##u var_3 e of var_3 he var_1 ob ##je ##c var_3 , if i var_3 ex ##is var_3 s sub ##s var_3 i var_3 u var_3 e i var_3 for var_3 , if no var_3 var_3 is none . [SEP]",
        "reference": "t = getattr ( _active , ` value ` , None )",
        "Output": "t = _active ( getattr )",
        "Var_Maps": [
            {
                "value": "var_2",
                "getattr": "var_0",
                "_active": "var_1",
                "t": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is no var_0 none , [SEP]",
        "reference": "if t is not None : pass",
        "Output": "if t is None : pass",
        "Var_Maps": [
            {
                "t": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call var_1 he me var_1 ho ##d var_1 . var_0 , re var_1 ur ##n var_1 he res ##ul var_1 . [SEP]",
        "reference": "return t . to_language ( )",
        "Output": "return t . to_language ( )",
        "Var_Maps": [
            {
                "to_language": "var_0",
                "t": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Attribute Error : pass",
        "Output": "try : pass except Attribute Error : pass",
        "Var_Maps": [
            {
                "AttributeError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] do nothing . [SEP]",
        "reference": "pass",
        "Output": "pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] return var_1 . var_0 . [SEP]",
        "reference": "return settings . LANGUAGE_CODE",
        "Output": "return settings . LANGUAGE_CODE",
        "Var_Maps": [
            {
                "LANGUAGE_CODE": "var_0",
                "settings": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 . [SEP]",
        "reference": "def get_language_bidi ( ) : pass",
        "Output": "def get_language_bidi ( ) : pass",
        "Var_Maps": [
            {
                "get_language_bidi": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 , var_2 the result by str_0 , substitute the first element of the result for var_1 . [SEP]",
        "reference": "base_lang = get_language ( ) . split ( ` - ` ) [ 0 ]",
        "Output": "base_lang = get_language ( ) . split ( ` - ` ) [ 0 ]",
        "Var_Maps": [
            {
                "-": "var_3",
                "get_language": "var_0",
                "base_lang": "var_1",
                "split": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 is contained in var_2 . var_0 , return boo ##lean true , if not , return boo ##lean false . [SEP]",
        "reference": "return base_lang in settings . LANGUAGES_BIDI",
        "Output": "return base_lang in settings . LANGUAGES_BIDI",
        "Var_Maps": [
            {
                "LANGUAGES_BIDI": "var_0",
                "base_lang": "var_1",
                "settings": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 . [SEP]",
        "reference": "def catalog ( ) : pass",
        "Output": "def catalog ( ) : pass",
        "Var_Maps": [
            {
                "catalog": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] use global variable var_0 . [SEP]",
        "reference": "global _default",
        "Output": "",
        "Var_Maps": [
            {
                "_default": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] ge var_3 s var_3 r _ 0 a var_3 var_3 rib ##u var_3 e of var_3 he var_1 ob ##je ##c var_3 , if i var_3 ex ##is var_3 s sub ##s var_3 i var_3 u var_3 e i var_3 for var_3 , if no var_3 var_3 is none . [SEP]",
        "reference": "t = getattr ( _active , ` value ` , None )",
        "Output": "t = _active ( getattr )",
        "Var_Maps": [
            {
                "value": "var_2",
                "getattr": "var_0",
                "_active": "var_1",
                "t": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is no var_0 none [SEP]",
        "reference": "if t is not None : pass",
        "Output": "if t is None : pass",
        "Var_Maps": [
            {
                "t": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] re var_0 ur ##n var_0 . [SEP]",
        "reference": "return t",
        "Output": "return t",
        "Var_Maps": [
            {
                "t": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none [SEP]",
        "reference": "if _default is None : pass",
        "Output": "if _default is None : pass",
        "Var_Maps": [
            {
                "_default": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 with an argument var_3 . var_0 , substitute the result for var_2 . [SEP]",
        "reference": "_default = translation ( settings . LANGUAGE_CODE )",
        "Output": "_default = translation ( settings . LANGUAGE_CODE )",
        "Var_Maps": [
            {
                "LANGUAGE_CODE": "var_0",
                "translation": "var_1",
                "_default": "var_2",
                "settings": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return _default",
        "Output": "return _default",
        "Var_Maps": [
            {
                "_default": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_1 with 2 arguments : var_2 and var_0 . [SEP]",
        "reference": "def do_translate ( message , translation_function ) : pass",
        "Output": "def do_translate ( message , translation_function ) : pass",
        "Var_Maps": [
            {
                "translation_function": "var_0",
                "do_translate": "var_1",
                "message": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] use global variable var_0 . [SEP]",
        "reference": "global _default",
        "Output": "",
        "Var_Maps": [
            {
                "_default": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 every occurrence of var_4 ing var_4 _ 0 in var_1 with var_4 _ 1 , var_2 every occurrence of var_4 ing var_4 _ 2 , [SEP]",
        "reference": "eol_message = message . replace ( str ( ` \\ r \\ n ` ) , str ( ` \\ n ` ) ) . replace ( str ( ` \\ r ` ) , str ( ` \\ n ` ) )",
        "Output": "return message ( message . eol_message ( var_2 ) )",
        "Var_Maps": [
            {
                "\\r\\n": "str_0",
                "\\n": "str_1",
                "\\r": "str_2",
                "eol_message": "var_0",
                "message": "var_1",
                "replace": "var_3",
                "str": "var_7",
                "\r\n": "var_8",
                "\n": "var_11",
                "\r": "var_10"
            }
        ]
    },
    {
        "intent": "[CLS] in var_3 he previous res ##ul var_3 for wi var_3 h s var_3 ring s var_3 r _ 0 , sub ##s var_3 i var_3 u var_3 e var_3 he res ##ul var_3 for e ##ol _ message . ge var_3 s var_3 r _ 1 a var_3 var_3 rib ##u var_3 e of var_3 he var_1 ob ##je ##c var_3 , if i var_3 ex ##is var_3 s sub ##s var_3 i var_3 u var_3 e i var_3 for var_3 , if no var_3 var_3 is none . [SEP]",
        "reference": "t = getattr ( _active , ` value ` , None )",
        "Output": "t = _active ( getattr )",
        "Var_Maps": [
            {
                "\\n": "str_0",
                "value": "var_2",
                "getattr": "var_0",
                "_active": "var_1",
                "t": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is no var_0 none , [SEP]",
        "reference": "if t is not None : pass",
        "Output": "if t is None : pass",
        "Var_Maps": [
            {
                "t": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] ge var_4 var_0 a var_4 var_4 rib ##u var_4 e of var_4 he ob ##je ##c var_4 var_4 , call var_4 he var_3 wi var_4 h an ar ##gum ##en var_4 var_1 , sub ##s var_4 i var_4 u var_4 e var_4 he var_3 for var_3 . [SEP]",
        "reference": "result = getattr ( t , translation_function ) ( eol_message )",
        "Output": "result = t ( translation_function , eol_message ( t ) )",
        "Var_Maps": [
            {
                "translation_function": "var_0",
                "eol_message": "var_1",
                "getattr": "var_2",
                "result": "var_3",
                "t": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if _default is None : pass",
        "Output": "if _default is None : pass",
        "Var_Maps": [
            {
                "_default": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 with an argument var_3 . var_0 , substitute the result for var_2 . [SEP]",
        "reference": "_default = translation ( settings . LANGUAGE_CODE )",
        "Output": "_default = translation ( settings . LANGUAGE_CODE )",
        "Var_Maps": [
            {
                "LANGUAGE_CODE": "var_0",
                "translation": "var_1",
                "_default": "var_2",
                "settings": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] get var_0 attribute of the object var_2 , call the var_4 with an argument var_1 , substitute the var_4 for var_4 . [SEP]",
        "reference": "result = getattr ( _default , translation_function ) ( eol_message )",
        "Output": "var_5 = getattr ( _default , translation_function ) ( eol_message )",
        "Var_Maps": [
            {
                "translation_function": "var_0",
                "eol_message": "var_1",
                "_default": "var_2",
                "getattr": "var_3",
                "result": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 is an instance of var_1 , [SEP]",
        "reference": "if isinstance ( message , Safe Data ) : pass",
        "Output": "if isinstance ( message , Safe Data ) : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "SafeData": "var_1",
                "message": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_1 , return it . [SEP]",
        "reference": "return mark_safe ( result )",
        "Output": "return mark_safe ( result )",
        "Var_Maps": [
            {
                "mark_safe": "var_0",
                "result": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return result",
        "Output": "return result",
        "Var_Maps": [
            {
                "result": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def gettext ( message ) : pass",
        "Output": "def gettext ( message ) : pass",
        "Var_Maps": [
            {
                "gettext": "var_0",
                "message": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with 2 arguments : var_1 and string str_0 , return the result . [SEP]",
        "reference": "return do_translate ( message , ` gettext ` )",
        "Output": "return do_translate ( message , ` gettext ` )",
        "Var_Maps": [
            {
                "gettext": "var_2",
                "do_translate": "var_0",
                "message": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 . var_1 is true , [SEP]",
        "reference": "if six . PY3 : pass",
        "Output": "if six . PY3 : pass",
        "Var_Maps": [
            {
                "six": "var_0",
                "PY3": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "ugettext = gettext",
        "Output": "ugettext = gettext",
        "Var_Maps": [
            {
                "ugettext": "var_0",
                "gettext": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def ugettext ( message ) : pass",
        "Output": "def ugettext ( message ) : pass",
        "Var_Maps": [
            {
                "ugettext": "var_0",
                "message": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with 2 arguments : var_2 and string str_0 , return the result . [SEP]",
        "reference": "return do_translate ( message , ` ugettext ` )",
        "Output": "return do_translate ( message , ` ugettext ` )",
        "Var_Maps": [
            {
                "ugettext": "var_1",
                "do_translate": "var_0",
                "message": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 2 arguments : var_1 and var_2 . [SEP]",
        "reference": "def pgettext ( context , message ) : pass",
        "Output": "def pgettext ( context , message ) : pass",
        "Var_Maps": [
            {
                "pgettext": "var_0",
                "context": "var_1",
                "message": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] convert to strings and con ##cate ##nate var_2 , var_0 and var_3 , substitute the result for var_1 . [SEP]",
        "reference": "msg_with_ctxt = ` % s % s % s ` % ( context , CONTEXT_SEPARATOR , message )",
        "Output": "msg_with_ctxt = ` % s % s % s ` + ` context ` % ( context , CONTEXT_SEPARATOR , message )",
        "Var_Maps": [
            {
                "CONTEXT_SEPARATOR": "var_0",
                "msg_with_ctxt": "var_1",
                "context": "var_2",
                "message": "var_3",
                "%s%s%s": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 with an argument var_0 , substitute the var_2 for var_2 . [SEP]",
        "reference": "result = ugettext ( msg_with_ctxt )",
        "Output": "result = ugettext ( msg_with_ctxt )",
        "Var_Maps": [
            {
                "msg_with_ctxt": "var_0",
                "ugettext": "var_1",
                "result": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is contained in var_1 , [SEP]",
        "reference": "if CONTEXT_SEPARATOR in result : pass",
        "Output": "if CONTEXT_SEPARATOR in result : pass",
        "Var_Maps": [
            {
                "CONTEXT_SEPARATOR": "var_0",
                "result": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_1 , return the var_2 . [SEP]",
        "reference": "result = force_text ( message )",
        "Output": "return force_text ( message )",
        "Var_Maps": [
            {
                "force_text": "var_0",
                "message": "var_1",
                "result": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return result",
        "Output": "return result",
        "Var_Maps": [
            {
                "result": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function local ##e with an argument local ##e . [SEP]",
        "reference": "def gettext_noop ( message ) : pass",
        "Output": "def gettext_noop ( message ) : pass",
        "Var_Maps": [
            {
                "gettext_noop": "var_0",
                "message": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return message",
        "Output": "return message",
        "Var_Maps": [
            {
                "message": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_1 with 4 arguments : var_2 , var_3 , var_4 and var_0 . [SEP]",
        "reference": "def do_ntranslate ( singular , plural , number , translation_function ) : pass",
        "Output": "def do_ntranslate ( singular , plural , number , translation_function ) : pass",
        "Var_Maps": [
            {
                "translation_function": "var_0",
                "do_ntranslate": "var_1",
                "singular": "var_2",
                "plural": "var_3",
                "number": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] use global variable var_0 . [SEP]",
        "reference": "global _default",
        "Output": "",
        "Var_Maps": [
            {
                "_default": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] ge var_3 s var_3 r _ 0 a var_3 var_3 rib ##u var_3 e of var_3 he var_1 ob ##je ##c var_3 , if i var_3 ex ##is var_3 s sub ##s var_3 i var_3 u var_3 e i var_3 for var_3 , if no var_3 var_3 is none . [SEP]",
        "reference": "t = getattr ( _active , ` value ` , None )",
        "Output": "t = _active ( getattr )",
        "Var_Maps": [
            {
                "value": "var_2",
                "getattr": "var_0",
                "_active": "var_1",
                "t": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is no var_0 none , [SEP]",
        "reference": "if t is not None : pass",
        "Output": "if t is None : pass",
        "Var_Maps": [
            {
                "t": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] ge var_5 var_0 a var_5 var_5 rib ##u var_5 e of var_5 he var_5 ob ##je ##c var_5 , call var_5 he res ##ul var_5 wi var_5 h 3 ar ##gum ##en var_5 s : var_1 , var_3 and var_4 , re var_5 ur ##n var_5 he res ##ul var_5 . [SEP]",
        "reference": "return getattr ( t , translation_function ) ( singular , plural , number )",
        "Output": "return t ( translation_function ( singular , plural , number ) )",
        "Var_Maps": [
            {
                "translation_function": "var_0",
                "singular": "var_1",
                "getattr": "var_2",
                "plural": "var_3",
                "number": "var_4",
                "t": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if _default is None : pass",
        "Output": "if _default is None : pass",
        "Var_Maps": [
            {
                "_default": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 with an argument var_3 . var_0 , substitute the result for var_2 . [SEP]",
        "reference": "_default = translation ( settings . LANGUAGE_CODE )",
        "Output": "_default = translation ( settings . LANGUAGE_CODE )",
        "Var_Maps": [
            {
                "LANGUAGE_CODE": "var_0",
                "translation": "var_1",
                "_default": "var_2",
                "settings": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] get var_0 attribute of the var_1 object , call the result with 3 arguments : var_2 , var_4 and var_5 , return the result . [SEP]",
        "reference": "return getattr ( _default , translation_function ) ( singular , plural , number )",
        "Output": "return _default ( _default , translation_function , plural ) ( getattr )",
        "Var_Maps": [
            {
                "translation_function": "var_0",
                "_default": "var_1",
                "singular": "var_2",
                "getattr": "var_3",
                "plural": "var_4",
                "number": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 3 arguments : var_1 , var_2 and var_3 . [SEP]",
        "reference": "def ngettext ( singular , plural , number ) : pass",
        "Output": "def ngettext ( singular , plural , number ) : pass",
        "Var_Maps": [
            {
                "ngettext": "var_0",
                "singular": "var_1",
                "plural": "var_2",
                "number": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with 3 arguments : var_1 , var_3 , var_4 and string str_0 , return the result . [SEP]",
        "reference": "return do_ntranslate ( singular , plural , number , ` ngettext ` )",
        "Output": "return do_ntranslate ( singular , plural , number , ` ngettext ` )",
        "Var_Maps": [
            {
                "ngettext": "var_2",
                "do_ntranslate": "var_0",
                "singular": "var_1",
                "plural": "var_3",
                "number": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 . var_1 is true , [SEP]",
        "reference": "if six . PY3 : pass",
        "Output": "if six . PY3 : pass",
        "Var_Maps": [
            {
                "six": "var_0",
                "PY3": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "ungettext = ngettext",
        "Output": "ungettext = ngettext",
        "Var_Maps": [
            {
                "ungettext": "var_0",
                "ngettext": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 3 arguments : var_1 , var_2 and var_3 . [SEP]",
        "reference": "def ungettext ( singular , plural , number ) : pass",
        "Output": "def ungettext ( singular , plural , number ) : pass",
        "Var_Maps": [
            {
                "ungettext": "var_0",
                "singular": "var_1",
                "plural": "var_2",
                "number": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with 3 arguments : var_2 , var_3 , var_4 and string str_0 , return the result . [SEP]",
        "reference": "return do_ntranslate ( singular , plural , number , ` ungettext ` )",
        "Output": "return do_ntranslate ( singular , plural , number , ` ungettext ` )",
        "Var_Maps": [
            {
                "ngettext": "str_0",
                "do_ntranslate": "var_0",
                "ungettext": "var_1",
                "singular": "var_2",
                "plural": "var_3",
                "number": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 4 arguments : var_2 , var_1 , var_3 and var_4 . [SEP]",
        "reference": "def npgettext ( context , singular , plural , number ) : pass",
        "Output": "def npgettext ( context , singular , plural , number ) : pass",
        "Var_Maps": [
            {
                "npgettext": "var_0",
                "singular": "var_1",
                "context": "var_2",
                "plural": "var_3",
                "number": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 is a tu ##ple containing 2 elements : string created by con ##cate ##nat ##ing var_4 , var_0 and var_3 , [SEP]",
        "reference": "msgs_with_ctxt = ` % s % s % s ` % ( context , CONTEXT_SEPARATOR , singular ) , ` % s % s % s ` % ( context , CONTEXT_SEPARATOR , plural ) , number",
        "Output": "msgs_with_ctxt = ` CONTEXT_SEPARATOR ` % ( var_4 , var_0 , singular ) ,",
        "Var_Maps": [
            {
                "CONTEXT_SEPARATOR": "var_1",
                "msgs_with_ctxt": "var_2",
                "singular": "var_3",
                "context": "var_5",
                "%s%s%s": "var_7",
                "plural": "var_8",
                "number": "var_9"
            }
        ]
    },
    {
        "intent": "[CLS] string created by con ##cate ##nat ##ing context , context _ sep ##arat ##or and plural and number . call the function var_1 with un ##pack ##ed dictionary var_0 , substitute the var_2 for var_2 . [SEP]",
        "reference": "result = ungettext ( * msgs_with_ctxt )",
        "Output": "result = ungettext ( * * msgs_with_ctxt )",
        "Var_Maps": [
            {
                "msgs_with_ctxt": "var_0",
                "ungettext": "var_1",
                "result": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is contained in var_1 , [SEP]",
        "reference": "if CONTEXT_SEPARATOR in result : pass",
        "Output": "if CONTEXT_SEPARATOR in result : pass",
        "Var_Maps": [
            {
                "CONTEXT_SEPARATOR": "var_0",
                "result": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with 3 arguments : var_1 , var_3 and var_4 , substitute the var_2 for var_2 . [SEP]",
        "reference": "result = ungettext ( singular , plural , number )",
        "Output": "result = ungettext ( singular , plural , number )",
        "Var_Maps": [
            {
                "ungettext": "var_0",
                "singular": "var_1",
                "result": "var_2",
                "plural": "var_3",
                "number": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return result",
        "Output": "return result",
        "Var_Maps": [
            {
                "result": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 . [SEP]",
        "reference": "def all_locale_paths ( ) : pass",
        "Output": "def all_locale_paths ( ) : pass",
        "Var_Maps": [
            {
                "all_locale_paths": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] get the value under the var_2 . var_1 key of the var_1 1 . var_5 dictionary , use its var_3 field as an argument , [SEP]",
        "reference": "globalpath = os . path . join ( os . path . dirname ( upath ( sys . modules [ settings . __module__ ] . __file__ ) ) , ` locale ` )",
        "Output": "__module__1 . modules [ settings . __module__ ] = dirname . globalpath",
        "Var_Maps": [
            {
                "globalpath": "var_0",
                "__module__": "var_1",
                "settings": "var_2",
                "__file__": "var_3",
                "dirname": "var_4",
                "modules": "var_5",
                "locale": "var_6",
                "upath": "var_7",
                "path": "var_10",
                "join": "var_9",
                "sys": "var_11",
                "os": "var_13"
            }
        ]
    },
    {
        "intent": "[CLS] for the call to the function up ##ath , get the directory name of the resulting system path , join the result and string str_0 , into a valid file path , substitute it for var_1 . app ##end var_2 . var_0 converted into a var_3 to a var_3 containing an element var_1 , return it . [SEP]",
        "reference": "return [ globalpath ] + list ( settings . LOCALE_PATHS )",
        "Output": "return var_4 ( settings . LOCALE_PATHS ) + list ( settings . LOCALE_PATHS )",
        "Var_Maps": [
            {
                "locale": "str_0",
                "LOCALE_PATHS": "var_0",
                "globalpath": "var_1",
                "settings": "var_2",
                "list": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] decor ##ator function var_0 . var_0 with an argument var_2 set to integer 1000 . [SEP]",
        "reference": "@ lru_cache . lru_cache ( maxsize = 1000 ) def dummy ( ) : pass",
        "Output": "@ lru_cache . lru_cache ( maxsize = 1000 ) def dummy ( ) : pass",
        "Var_Maps": [
            {
                "lru_cache": "var_1",
                "maxsize": "var_2",
                "dummy": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def check_for_language ( lang_code ) : pass",
        "Output": "def check_for_language ( lang_code ) : pass",
        "Var_Maps": [
            {
                "check_for_language": "var_0",
                "lang_code": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_2 with an argument var_1 , if it evaluate ##s to false , [SEP]",
        "reference": "if not language_code_re . search ( lang_code ) : pass",
        "Output": "if not language_code_re . search ( lang_code ) : pass",
        "Var_Maps": [
            {
                "language_code_re": "var_0",
                "lang_code": "var_1",
                "search": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return boo ##lean false . [SEP]",
        "reference": "return False",
        "Output": "return ` False `",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the function var_0 , for every var_1 is the result , [SEP]",
        "reference": "for path in all_locale_paths ( ) : pass",
        "Output": "for path in all_locale_paths ( ) : pass",
        "Var_Maps": [
            {
                "all_locale_paths": "var_0",
                "path": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_4 with 3 arguments : string str_0 , var_5 and list with an element : result of the function , [SEP]",
        "reference": "if gettext_module . find ( ` django ` , path , [ to_locale ( lang_code ) ] ) is not None : pass",
        "Output": "gettext_module . find ( ` to_locale ` , django ( path ) , lang_code . django ( ) [ 1 ] )",
        "Var_Maps": [
            {
                "django": "var_3",
                "gettext_module": "var_0",
                "to_locale": "var_1",
                "lang_code": "var_2",
                "find": "var_4",
                "path": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] to _ local ##e called with an argument lang _ code , if the result is not none , return boo ##lean true . [SEP]",
        "reference": "return True",
        "Output": "return var_0 . var_1 ( ) is not None",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] return boo ##lean false . [SEP]",
        "reference": "return False",
        "Output": "return ` False `",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] decor ##ator function var_0 . var_0 with an argument var_2 set to integer 1000 . [SEP]",
        "reference": "@ lru_cache . lru_cache ( maxsize = 1000 ) def dummy ( ) : pass",
        "Output": "@ lru_cache . lru_cache ( maxsize = 1000 ) def dummy ( ) : pass",
        "Var_Maps": [
            {
                "lru_cache": "var_1",
                "maxsize": "var_2",
                "dummy": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 2 arguments : var_1 and var_2 set to boo ##lean false . [SEP]",
        "reference": "def get_supported_language_variant ( lang_code , strict = False ) : pass",
        "Output": "def get_supported_language_variant ( lang_code , strict = ` False ` ) : pass",
        "Var_Maps": [
            {
                "get_supported_language_variant": "var_0",
                "lang_code": "var_1",
                "strict": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] use global variable var_0 . [SEP]",
        "reference": "global _supported",
        "Output": "",
        "Var_Maps": [
            {
                "_supported": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if _supported is None : pass",
        "Output": "if _supported is None : pass",
        "Var_Maps": [
            {
                "_supported": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 is an instance of var_0 class , created with an argument var_3 . var_2 . [SEP]",
        "reference": "_supported = Ordered Dict ( settings . LANGUAGES )",
        "Output": "_supported = Ordered Dict ( settings . LANGUAGES )",
        "Var_Maps": [
            {
                "OrderedDict": "var_0",
                "_supported": "var_1",
                "LANGUAGES": "var_2",
                "settings": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if lang_code : pass",
        "Output": "if lang_code : pass",
        "Var_Maps": [
            {
                "lang_code": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_3 the value under the var_2 key of the var_0 dictionary , substitute it for var_1 . [SEP]",
        "reference": "replacement = _BROWSERS_DEPRECATED_LOCALES . get ( lang_code )",
        "Output": "replacement = _BROWSERS_DEPRECATED_LOCALES . get ( lang_code )",
        "Var_Maps": [
            {
                "_BROWSERS_DEPRECATED_LOCALES": "var_0",
                "replacement": "var_1",
                "lang_code": "var_2",
                "get": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_3 is not contained in var_1 and var_0 is contained in var_1 , [SEP]",
        "reference": "if lang_code not in _supported and replacement in _supported : pass",
        "Output": "if lang_code not in _supported and replacement in _supported : pass",
        "Var_Maps": [
            {
                "replacement": "var_0",
                "_supported": "var_2",
                "lang_code": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return replacement",
        "Output": "return replacement",
        "Var_Maps": [
            {
                "replacement": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 var_1 by str_0 , substitute the first element of the result for var_0 . [SEP]",
        "reference": "generic_lang_code = lang_code . split ( ` - ` ) [ 0 ]",
        "Output": "generic_lang_code = lang_code . split ( ` - ` ) [ 0 ]",
        "Var_Maps": [
            {
                "-": "var_3",
                "generic_lang_code": "var_0",
                "lang_code": "var_1",
                "split": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_2 in tu ##ple with 2 elements : var_1 and var_0 , [SEP]",
        "reference": "for code in ( lang_code , generic_lang_code ) : pass",
        "Output": "for code in ( lang_code , generic_lang_code ) : pass",
        "Var_Maps": [
            {
                "generic_lang_code": "var_0",
                "lang_code": "var_1",
                "code": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 is contained in var_1 and call to the function var_0 with an argument var_2 evaluate ##s to true , [SEP]",
        "reference": "if code in _supported and check_for_language ( code ) : pass",
        "Output": "if code in _supported and check_for_language ( code ) : pass",
        "Var_Maps": [
            {
                "check_for_language": "var_0",
                "_supported": "var_1",
                "code": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return code",
        "Output": "return code",
        "Var_Maps": [
            {
                "code": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is false , [SEP]",
        "reference": "if not strict : pass",
        "Output": "if not strict : pass",
        "Var_Maps": [
            {
                "strict": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_0 in var_1 , [SEP]",
        "reference": "for supported_code in _supported : pass",
        "Output": "for supported_code in _supported : pass",
        "Var_Maps": [
            {
                "supported_code": "var_0",
                "_supported": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] app ##end str_0 to var_0 , if var_1 starts with it , [SEP]",
        "reference": "if supported_code . startswith ( generic_lang_code + ` - ` ) : pass",
        "Output": "if supported_code . generic_lang_code ( startswith . - ( ` var_4 ` ) ) : pass",
        "Var_Maps": [
            {
                "-": "var_3",
                "generic_lang_code": "var_0",
                "supported_code": "var_1",
                "startswith": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return supported_code",
        "Output": "return supported_code",
        "Var_Maps": [
            {
                "supported_code": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] raise an var_0 with an argument var_1 . [SEP]",
        "reference": "raise Lookup Error ( lang_code )",
        "Output": "raise Lookup Error ( lang_code )",
        "Var_Maps": [
            {
                "LookupError": "var_0",
                "lang_code": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 2 arguments : var_2 and var_1 set to boo ##lean false . [SEP]",
        "reference": "def get_language_from_path ( path , strict = False ) : pass",
        "Output": "def get_language_from_path ( path , strict = ` False ` ) : pass",
        "Var_Maps": [
            {
                "get_language_from_path": "var_0",
                "strict": "var_1",
                "path": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 . var_2 with an argument var_3 , substitute it for var_1 . [SEP]",
        "reference": "regex_match = language_code_prefix_re . match ( path )",
        "Output": "regex_match = language_code_prefix_re . match ( path )",
        "Var_Maps": [
            {
                "language_code_prefix_re": "var_0",
                "regex_match": "var_1",
                "match": "var_2",
                "path": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is false , [SEP]",
        "reference": "if not regex_match : pass",
        "Output": "if not regex_match : pass",
        "Var_Maps": [
            {
                "regex_match": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] return none . [SEP]",
        "reference": "return None",
        "Output": "return None",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_2 with an argument integer 1 , substitute the result for var_1 . [SEP]",
        "reference": "lang_code = regex_match . group ( 1 )",
        "Output": "lang_code = regex_match . group ( 1 )",
        "Var_Maps": [
            {
                "regex_match": "var_0",
                "lang_code": "var_1",
                "group": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with 2 arguments : var_1 and var_2 set to var_2 , return the result . [SEP]",
        "reference": "return get_supported_language_variant ( lang_code , strict = strict )",
        "Output": "return get_supported_language_variant ( lang_code , strict = strict )",
        "Var_Maps": [
            {
                "get_supported_language_variant": "var_0",
                "lang_code": "var_1",
                "strict": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Lookup Error : pass",
        "Output": "try : pass except Lookup Error : pass",
        "Var_Maps": [
            {
                "LookupError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] return none . [SEP]",
        "reference": "return None",
        "Output": "return None",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 2 arguments : var_2 and var_1 set to boo ##lean false . [SEP]",
        "reference": "def get_language_from_request ( request , check_path = False ) : pass",
        "Output": "def get_language_from_request ( request , check_path = ` False ` ) : pass",
        "Var_Maps": [
            {
                "get_language_from_request": "var_0",
                "check_path": "var_1",
                "request": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] use global variable var_0 . [SEP]",
        "reference": "global _supported",
        "Output": "",
        "Var_Maps": [
            {
                "_supported": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if _supported is None : pass",
        "Output": "if _supported is None : pass",
        "Var_Maps": [
            {
                "_supported": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 is an instance of var_0 class , created with an argument var_3 . var_2 . [SEP]",
        "reference": "_supported = Ordered Dict ( settings . LANGUAGES )",
        "Output": "_supported = Ordered Dict ( settings . LANGUAGES )",
        "Var_Maps": [
            {
                "OrderedDict": "var_0",
                "_supported": "var_1",
                "LANGUAGES": "var_2",
                "settings": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if check_path : pass",
        "Output": "if check_path : pass",
        "Var_Maps": [
            {
                "check_path": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_3 . var_2 , substitute it for var_1 . [SEP]",
        "reference": "lang_code = get_language_from_path ( request . path_info )",
        "Output": "lang_code = get_language_from_path ( request . path_info )",
        "Var_Maps": [
            {
                "get_language_from_path": "var_0",
                "lang_code": "var_1",
                "path_info": "var_2",
                "request": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is not none , [SEP]",
        "reference": "if lang_code is not None : pass",
        "Output": "if lang_code is not None : pass",
        "Var_Maps": [
            {
                "lang_code": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return lang_code",
        "Output": "return lang_code",
        "Var_Maps": [
            {
                "lang_code": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 has an attribute str_0 , [SEP]",
        "reference": "if hasattr ( request , ` session ` ) : pass",
        "Output": "if hasattr ( request , ` session ` ) : pass",
        "Var_Maps": [
            {
                "session": "var_2",
                "hasattr": "var_0",
                "request": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_4 the value under the var_0 key of the var_2 . var_3 dictionary , substitute it for var_1 . [SEP]",
        "reference": "lang_code = request . session . get ( LANGUAGE_SESSION_KEY )",
        "Output": "lang_code = request . session . get ( LANGUAGE_SESSION_KEY )",
        "Var_Maps": [
            {
                "LANGUAGE_SESSION_KEY": "var_0",
                "lang_code": "var_1",
                "request": "var_2",
                "session": "var_3",
                "get": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 is contained in var_1 and var_2 is not none and result of the function var_0 , [SEP]",
        "reference": "if lang_code in _supported and lang_code is not None and check_for_language ( lang_code ) : pass",
        "Output": "if var_3 in _supported and var_3 is not None : pass",
        "Var_Maps": [
            {
                "check_for_language": "var_0",
                "_supported": "var_1",
                "lang_code": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] called with an argument var_0 is true , return var_0 . [SEP]",
        "reference": "return lang_code",
        "Output": "return lang_code",
        "Var_Maps": [
            {
                "lang_code": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_5 the value under the var_2 . var_0 key of the var_3 . var_4 dictionary , substitute it for var_1 . [SEP]",
        "reference": "lang_code = request . COOKIES . get ( settings . LANGUAGE_COOKIE_NAME )",
        "Output": "lang_code = request . COOKIES . get ( settings . LANGUAGE_COOKIE_NAME )",
        "Var_Maps": [
            {
                "LANGUAGE_COOKIE_NAME": "var_0",
                "lang_code": "var_1",
                "settings": "var_2",
                "request": "var_3",
                "COOKIES": "var_4",
                "get": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_1 , return the result . [SEP]",
        "reference": "return get_supported_language_variant ( lang_code )",
        "Output": "return get_supported_language_variant ( lang_code )",
        "Var_Maps": [
            {
                "get_supported_language_variant": "var_0",
                "lang_code": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Lookup Error : pass",
        "Output": "try : pass except Lookup Error : pass",
        "Var_Maps": [
            {
                "LookupError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] do nothing . [SEP]",
        "reference": "pass",
        "Output": "pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] if not var_3 is an empty string . call the function var_0 with an argument var_3 , for every var_1 and var_2 in the result , [SEP]",
        "reference": "for accept_lang , unused in parse_accept_lang_header ( accept ) : pass",
        "Output": "for accept_lang , unused in parse_accept_lang_header ( accept ) : pass",
        "Var_Maps": [
            {
                "parse_accept_lang_header": "var_0",
                "accept_lang": "var_1",
                "unused": "var_2",
                "accept": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 equals str_0 , [SEP]",
        "reference": "if accept_lang = = ` * ` : pass",
        "Output": "if accept_lang = = ` * ` : pass",
        "Var_Maps": [
            {
                "*": "var_1",
                "accept_lang": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] break from the loop execution . [SEP]",
        "reference": "break",
        "Output": "break",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_2 with an argument var_1 , if it evaluate ##s to false , [SEP]",
        "reference": "if not language_code_re . search ( accept_lang ) : pass",
        "Output": "if not language_code_re . search ( accept_lang ) : pass",
        "Var_Maps": [
            {
                "language_code_re": "var_0",
                "accept_lang": "var_1",
                "search": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] skip this loop iteration . [SEP]",
        "reference": "continue",
        "Output": "continue",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_1 , return the result . [SEP]",
        "reference": "return get_supported_language_variant ( accept_lang )",
        "Output": "return get_supported_language_variant ( accept_lang )",
        "Var_Maps": [
            {
                "get_supported_language_variant": "var_0",
                "accept_lang": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Lookup Error : pass",
        "Output": "try : pass except Lookup Error : pass",
        "Var_Maps": [
            {
                "LookupError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] skip this loop iteration . [SEP]",
        "reference": "continue",
        "Output": "continue",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_2 . var_1 , return the result . [SEP]",
        "reference": "return get_supported_language_variant ( settings . LANGUAGE_CODE )",
        "Output": "return get_supported_language_variant ( settings . LANGUAGE_CODE )",
        "Var_Maps": [
            {
                "get_supported_language_variant": "var_0",
                "LANGUAGE_CODE": "var_1",
                "settings": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Lookup Error : pass",
        "Output": "try : pass except Lookup Error : pass",
        "Var_Maps": [
            {
                "LookupError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] return var_1 . var_0 . [SEP]",
        "reference": "return settings . LANGUAGE_CODE",
        "Output": "return settings . LANGUAGE_CODE",
        "Var_Maps": [
            {
                "LANGUAGE_CODE": "var_0",
                "settings": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_2 . var_0 with an argument raw string str_0 , substitute it for var_1 . [SEP]",
        "reference": "dot_re = re . compile ( ` \\ \\ S ` )",
        "Output": "dot_re = re . compile ( ` \\ S ` )",
        "Var_Maps": [
            {
                "\\S": "var_3",
                "compile": "var_0",
                "dot_re": "var_1",
                "re": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 2 arguments : var_2 and var_1 . [SEP]",
        "reference": "def blankout ( src , char ) : pass",
        "Output": "def blankout ( src , char ) : pass",
        "Var_Maps": [
            {
                "blankout": "var_0",
                "char": "var_1",
                "src": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_2 with 2 arguments : var_1 and var_3 , return the result . [SEP]",
        "reference": "return dot_re . sub ( char , src )",
        "Output": "return dot_re . sub ( char , src )",
        "Var_Maps": [
            {
                "dot_re": "var_0",
                "char": "var_1",
                "sub": "var_2",
                "src": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_3 . var_2 with an argument raw string str_0 [ ^ str_1 ) | ( ? : str_2 ] * ? ' ) ) \\ s * \" , substitute the var_3 sul ##t for var_1 . [SEP]",
        "reference": "context_re = re . compile ( ` ^ \\ \\ s + . * context \\ \\ s + ( ( ? : ` [ ^ ` ] * ? ` ) | ( ? : \\ ` [ ^ \\ ` ] * ? \\ ` ) ) \\ \\ s * ` )",
        "Output": "context_re = re . compile ( ` ^ \\ s + . * context \\ s + ( ( ? : ` [ ^ ` ] * ? ` ) | ( ? : ` [ ^ ` ] * ? ` ) ) \\ s * ` , var_4 . context_re )",
        "Var_Maps": [
            {
                "^\\s+.*context\\s+((?:": "str_0",
                "]*?": "str_1",
                "[^": "str_2",
                "^\\s+.*context\\s+((?:\"[^\"]*?\")|(?:'[^']*?'))\\s*": "var_0",
                "context_re": "var_1",
                "compile": "var_2",
                "re": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_3 . var_2 with an argument string str_0 [ ^ str_1 ) | ( ? : str_2 ] * ? ' ) ) ( \\ s + . * context \\ s + ( ( ? : \" [ ^ str_1 ) | ( ? : str_2 ] * ? ' ) ) ) ? \\ s * \" , substitute the var_3 sul ##t for var_1 . [SEP]",
        "reference": "inline_re = re . compile ( ` ^ \\ \\ s * trans \\ \\ s + ( ( ? : ` [ ^ ` ] * ? ` ) | ( ? : \\ ` [ ^ \\ ` ] * ? \\ ` ) ) ( \\ \\ s + . * context \\ \\ s + ( ( ? : ` [ ^ ` ] * ? ` ) | ( ? : \\ ` [ ^ \\ ` ] * ? \\ ` ) ) ) ? \\ \\ s * ` )",
        "Output": "inline_re = var_4 . compile ( ` ^ \\ s * trans \\ s + ( ( ? : ` [ ^ ` ] * ? ` ) | ( ? : ` [ ^ ` ] * ? ` ) ) ( \\ s + . * context \\ s + ( ( ? : ` [ ^ ` ] * ? ` ) | ( ? : ` [ ^ ` ] * ? ` ) ) ) ? \\ s * ` , ` var_4 ` )",
        "Var_Maps": [
            {
                "^\\s*trans\\s+((?:": "str_0",
                "]*?": "str_1",
                "[^": "str_2",
                "))(\\s+.*context\\s+((?:\"[^\"]*?\")|(?:": "str_3",
                "^\\s*trans\\s+((?:\"[^\"]*?\")|(?:'[^']*?'))(\\s+.*context\\s+((?:\"[^\"]*?\")|(?:'[^']*?')))?\\s*": "var_0",
                "inline_re": "var_1",
                "compile": "var_2",
                "re": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_3 . var_2 with an argument raw string str_0 [ ^ str_1 ) | ( ? : str_2 ] * ? ' ) ) ) ? ( ? : \\ s + | $ ) \" , [SEP]",
        "reference": "block_re = re . compile ( ` ^ \\ \\ s * blocktrans ( \\ \\ s + . * context \\ \\ s + ( ( ? : ` [ ^ ` ] * ? ` ) | ( ? : \\ ` [ ^ \\ ` ] * ? \\ ` ) ) ) ? ( ? : \\ \\ s + | $ ) ` )",
        "Output": "block_re = var_4 . compile ( ` ^ \\ s * blocktrans ( \\ s + . * context \\ s + ( ( ? : ` [ ^ ` ] * ? ` ) | ( ? : ` [ ^ ` ] * ? ` ) ) ) ? ( ? : \\ s + | $ ) ` , var_5 . block_re )",
        "Var_Maps": [
            {
                "^\\s*blocktrans(\\s+.*context\\s+((?:": "str_0",
                "]*?": "str_1",
                "[^": "str_2",
                "^\\s*blocktrans(\\s+.*context\\s+((?:\"[^\"]*?\")|(?:'[^']*?')))?(?:\\s+|$)": "var_0",
                "block_re": "var_1",
                "compile": "var_2",
                "re": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] substitute the var_3 sul ##t for block _ var_3 . call the function var_3 . var_2 with an argument raw string str_0 , substitute the var_3 sul ##t for var_1 . [SEP]",
        "reference": "endblock_re = re . compile ( ` ^ \\ \\ s * endblocktrans $ ` )",
        "Output": "endblock_re = re . compile ( ` ^ \\ s * endblocktrans $ ` )",
        "Var_Maps": [
            {
                "^\\s*endblocktrans$": "var_0",
                "endblock_re": "var_1",
                "compile": "var_2",
                "re": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_3 . var_2 with an argument raw string str_0 , substitute the var_3 sul ##t for var_1 . [SEP]",
        "reference": "plural_re = re . compile ( ` ^ \\ \\ s * plural $ ` )",
        "Output": "plural_re = re . compile ( ` ^ \\ s * plural $ ` )",
        "Var_Maps": [
            {
                "^\\s*plural$": "var_0",
                "plural_re": "var_1",
                "compile": "var_2",
                "re": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_3 . var_2 with an argument raw string str_0 . * ? str_1 , substitute the var_3 sul ##t for var_1 . [SEP]",
        "reference": "constant_re = re . compile ( ` _ \\ \\ ( ( ( ? : ` . * ? ` ) | ( ? : \\ ` . * ? \\ ` ) ) \\ \\ ) ` )",
        "Output": "constant_re = re . compile ( ` _ \\ ( ( ( ? : ` . * ? ` ) | ( ? : ` . * ? ` ) ) \\ ) ` )",
        "Var_Maps": [
            {
                "_\\(((?:": "str_0",
                ")|(?:'.*?'))\\)": "str_1",
                "_\\(((?:\".*?\")|(?:'.*?'))\\)": "var_0",
                "constant_re": "var_1",
                "compile": "var_2",
                "re": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_3 . var_2 with an argument raw string str_0 , substitute the var_3 sul ##t for var_0 . [SEP]",
        "reference": "one_percent_re = re . compile ( ` ( ? < ! % ) % ( ? ! % ) ` )",
        "Output": "one_percent_re = re . compile ( ` ( ? < ! % ) % ( ? ! % ) ` )",
        "Var_Maps": [
            {
                "(?<!%)%(?!%)": "var_1",
                "one_percent_re": "var_0",
                "compile": "var_2",
                "re": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 2 arguments : var_2 and var_1 set to none . [SEP]",
        "reference": "def templatize ( src , origin = None ) : pass",
        "Output": "def templatize ( src , origin = None ) : pass",
        "Var_Maps": [
            {
                "templatize": "var_0",
                "origin": "var_1",
                "src": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] from var_1 import var_6 , var_4 , var_5 , var_3 , var_2 and var_0 . [SEP]",
        "reference": "from django . template import Lexer , TOKEN_TEXT , TOKEN_VAR , TOKEN_BLOCK , TOKEN_COMMENT , TRANSLATOR_COMMENT_MARK",
        "Output": "from django . template import Lexer , TOKEN_TEXT , TOKEN_VAR , TOKEN_BLOCK , TOKEN_COMMENT , TRANSLATOR_COMMENT_MARK",
        "Var_Maps": [
            {
                "TRANSLATOR_COMMENT_MARK": "var_0",
                "django.template": "var_1",
                "TOKEN_COMMENT": "var_2",
                "TOKEN_BLOCK": "var_3",
                "TOKEN_TEXT": "var_4",
                "TOKEN_VAR": "var_5",
                "Lexer": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_1 with 2 arguments : var_3 and var_2 . var_0 . [SEP]",
        "reference": "src = force_text ( src , settings . FILE_CHARSET )",
        "Output": "force_text ( var_3 , settings . FILE_CHARSET )",
        "Var_Maps": [
            {
                "FILE_CHARSET": "var_0",
                "force_text": "var_1",
                "settings": "var_2",
                "src": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is none . [SEP]",
        "reference": "message_context = None",
        "Output": "message_context = None",
        "Var_Maps": [
            {
                "message_context": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is boo ##lean false . [SEP]",
        "reference": "intrans = False",
        "Output": "intrans = ` False `",
        "Var_Maps": [
            {
                "intrans": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is boo ##lean false . [SEP]",
        "reference": "inplural = False",
        "Output": "inplural = ` False `",
        "Var_Maps": [
            {
                "inplural": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is boo ##lean false . [SEP]",
        "reference": "trimmed = False",
        "Output": "trimmed = ` False `",
        "Var_Maps": [
            {
                "trimmed": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an empty list . [SEP]",
        "reference": "singular = [ ]",
        "Output": "singular = [ ]",
        "Var_Maps": [
            {
                "singular": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an empty list . [SEP]",
        "reference": "plural = [ ]",
        "Output": "plural = [ ]",
        "Var_Maps": [
            {
                "plural": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is boo ##lean false . [SEP]",
        "reference": "incomment = False",
        "Output": "incomment = ` False `",
        "Var_Maps": [
            {
                "incomment": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an empty list . [SEP]",
        "reference": "comment = [ ]",
        "Output": "comment = [ ]",
        "Var_Maps": [
            {
                "comment": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an dictionary . [SEP]",
        "reference": "lineno_comment_map = { }",
        "Output": "lineno_comment_map = { }",
        "Var_Maps": [
            {
                "lineno_comment_map": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is none . [SEP]",
        "reference": "comment_lineno_cache = None",
        "Output": "comment_lineno_cache = None",
        "Var_Maps": [
            {
                "comment_lineno_cache": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with 2 arguments : var_1 and var_2 set to boo ##lean false . [SEP]",
        "reference": "def join_tokens ( tokens , trim = False ) : pass",
        "Output": "def join_tokens ( tokens , trim = ` False ` ) : pass",
        "Var_Maps": [
            {
                "join_tokens": "var_0",
                "tokens": "var_1",
                "trim": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_3 v var_3 a var_3 r var_3 _ var_3 2 var_3 var_3 v var_3 a var_3 r var_3 _ var_3 1 var_3 var_3 e var_3 l var_3 e var_3 m var_3 e var_3 n var_3 t var_3 s var_3 var_3 i var_3 n var_3 t var_3 o var_3 var_3 a var_3 var_3 s var_3 t var_3 r var_3 i var_3 n var_3 g var_3 , var_3 var_3 s var_3 u var_3 b var_3 s var_3 t var_3 i var_3 t var_3 u var_3 t var_3 e var_3 var_3 i var_3 t var_3 var_3 f var_3 o var_3 r var_3 var_3 v var_3 a var_3 r var_3 _ var_3 0 var_3 . var_3 [SEP]",
        "reference": "message = ` ` . join ( tokens )",
        "Output": "def message ( join , tokens = ` ` ) : pass",
        "Var_Maps": [
            {
                "message": "var_0",
                "tokens": "var_1",
                "join": "var_2",
                "": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if trim : pass",
        "Output": "if trim : pass",
        "Var_Maps": [
            {
                "trim": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_1 , substitute the result for var_1 . [SEP]",
        "reference": "message = trim_whitespace ( message )",
        "Output": "message = trim_whitespace ( message )",
        "Var_Maps": [
            {
                "trim_whitespace": "var_0",
                "message": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return message",
        "Output": "return message",
        "Var_Maps": [
            {
                "message": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] ins var_4 an var_4 ia var_4 e var_2 class wi var_4 h 2 ar ##gum ##e var_4 s var_3 and var_1 , call var_4 he me var_4 ho ##d var_0 from i var_4 , for every var_4 in var_4 he res ##ul var_4 , [SEP]",
        "reference": "for t in Lexer ( src , origin ) . tokenize ( ) : pass",
        "Output": "var_5 = Lexer ( ) . tokenize ( src , origin )",
        "Var_Maps": [
            {
                "tokenize": "var_0",
                "origin": "var_1",
                "Lexer": "var_2",
                "src": "var_3",
                "t": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if incomment : pass",
        "Output": "if incomment : pass",
        "Var_Maps": [
            {
                "incomment": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_4 . var_1 equals var_0 and var_4 . var_3 equals s var_4 r _ 0 , [SEP]",
        "reference": "if t . token_type = = TOKEN_BLOCK and t . contents = = ` endcomment ` : pass",
        "Output": "if t . token_type = = TOKEN_BLOCK and t . contents = = ` endcomment ` : pass",
        "Var_Maps": [
            {
                "endcomment": "var_2",
                "TOKEN_BLOCK": "var_0",
                "token_type": "var_1",
                "contents": "var_3",
                "t": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] var_3 v var_3 a var_3 r var_3 _ var_3 2 var_3 var_3 v var_3 a var_3 r var_3 _ var_3 1 var_3 var_3 e var_3 l var_3 e var_3 m var_3 e var_3 n var_3 t var_3 s var_3 var_3 i var_3 n var_3 t var_3 o var_3 var_3 a var_3 var_3 s var_3 t var_3 r var_3 i var_3 n var_3 g var_3 , var_3 var_3 s var_3 u var_3 b var_3 s var_3 t var_3 i var_3 t var_3 u var_3 t var_3 e var_3 var_3 i var_3 t var_3 var_3 f var_3 o var_3 r var_3 var_3 v var_3 a var_3 r var_3 _ var_3 0 var_3 . var_3 [SEP]",
        "reference": "content = ` ` . join ( comment )",
        "Output": "def content ( join , comment = ` ` ) : pass",
        "Var_Maps": [
            {
                "content": "var_0",
                "comment": "var_1",
                "join": "var_2",
                "": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is none . [SEP]",
        "reference": "translators_comment_start = None",
        "Output": "translators_comment_start = None",
        "Var_Maps": [
            {
                "translators_comment_start": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_3 and var_4 is var_1 d result of the method var_2 . var_0 , called with an argument boo ##lean true , [SEP]",
        "reference": "for lineno , line in enumerate ( content . splitlines ( True ) ) : pass",
        "Output": "for lineno , line in enumerate ( content . splitlines ( ) ) : pass",
        "Var_Maps": [
            {
                "splitlines": "var_0",
                "enumerate": "var_1",
                "content": "var_2",
                "lineno": "var_3",
                "line": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_3 . var_2 , if the result starts with var_0 , [SEP]",
        "reference": "if line . lstrip ( ) . startswith ( TRANSLATOR_COMMENT_MARK ) : pass",
        "Output": "if var_4 . lstrip ( TRANSLATOR_COMMENT_MARK ) : pass",
        "Var_Maps": [
            {
                "TRANSLATOR_COMMENT_MARK": "var_0",
                "startswith": "var_1",
                "lstrip": "var_2",
                "line": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . [SEP]",
        "reference": "translators_comment_start = lineno",
        "Output": "translators_comment_start = lineno",
        "Var_Maps": [
            {
                "translators_comment_start": "var_0",
                "lineno": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_3 and var_4 is var_1 d result of the method var_2 . var_0 , called with an argument boo ##lean true , [SEP]",
        "reference": "for lineno , line in enumerate ( content . splitlines ( True ) ) : pass",
        "Output": "for lineno , line in enumerate ( content . splitlines ( ) ) : pass",
        "Var_Maps": [
            {
                "splitlines": "var_0",
                "enumerate": "var_1",
                "content": "var_2",
                "lineno": "var_3",
                "line": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is not none and var_2 is greater than or equal to var_0 , [SEP]",
        "reference": "if translators_comment_start is not None and lineno > = translators_comment_start : pass",
        "Output": "if translators_comment_start is not None and lineno > = translators_comment_start : pass",
        "Var_Maps": [
            {
                "translators_comment_start": "var_1",
                "lineno": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute %s in string str_0 with var_2 , var_0 it to var_3 file . [SEP]",
        "reference": "out . write ( ` # % s ` % line )",
        "Output": "out . write ( ` # % s ` % line )",
        "Var_Maps": [
            {
                " # %s": "var_1",
                "write": "var_0",
                "line": "var_2",
                "out": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] var_0 string str_0 to var_1 file . [SEP]",
        "reference": "out . write ( ` # \\ n ` )",
        "Output": "out . write ( ` # ` )",
        "Var_Maps": [
            {
                " #\\n": "str_0",
                "write": "var_0",
                "out": "var_1",
                " #\n": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is boo ##lean false . [SEP]",
        "reference": "incomment = False",
        "Output": "incomment = ` False `",
        "Var_Maps": [
            {
                "incomment": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an empty list . [SEP]",
        "reference": "comment = [ ]",
        "Output": "comment = [ ]",
        "Var_Maps": [
            {
                "comment": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] var_2 var_3 . var_0 var_3 o var_1 . [SEP]",
        "reference": "comment . append ( t . contents )",
        "Output": "comment . append ( t . contents )",
        "Var_Maps": [
            {
                "contents": "var_0",
                "comment": "var_1",
                "append": "var_2",
                "t": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] otherwise if var_0 is true , [SEP]",
        "reference": "if True : pass elif intrans : pass",
        "Output": "if ` True ` : pass elif intrans : pass",
        "Var_Maps": [
            {
                "intrans": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 . var_1 equals var_0 , [SEP]",
        "reference": "if t . token_type = = TOKEN_BLOCK : pass",
        "Output": "if t . token_type = = TOKEN_BLOCK : pass",
        "Var_Maps": [
            {
                "TOKEN_BLOCK": "var_0",
                "token_type": "var_1",
                "t": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call var_4 he fun ##c var_4 ion var_0 . var_3 wi var_4 h an ar ##gum ##en var_4 var_4 . var_2 , sub ##s var_4 i var_4 u var_4 e var_4 he res ##ul var_4 for var_1 . [SEP]",
        "reference": "endbmatch = endblock_re . match ( t . contents )",
        "Output": "endbmatch = endblock_re . match ( t . contents )",
        "Var_Maps": [
            {
                "endblock_re": "var_0",
                "endbmatch": "var_1",
                "contents": "var_2",
                "match": "var_3",
                "t": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] call var_4 he fun ##c var_4 ion var_1 . var_3 wi var_4 h an ar ##gum ##en var_4 var_4 . var_2 , sub ##s var_4 i var_4 u var_4 e var_4 he res ##ul var_4 for var_0 . [SEP]",
        "reference": "pluralmatch = plural_re . match ( t . contents )",
        "Output": "pluralmatch = plural_re . match ( t . contents )",
        "Var_Maps": [
            {
                "pluralmatch": "var_0",
                "plural_re": "var_1",
                "contents": "var_2",
                "match": "var_3",
                "t": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if endbmatch : pass",
        "Output": "if endbmatch : pass",
        "Var_Maps": [
            {
                "endbmatch": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if inplural : pass",
        "Output": "if inplural : pass",
        "Var_Maps": [
            {
                "inplural": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if message_context : pass",
        "Output": "if message_context : pass",
        "Var_Maps": [
            {
                "message_context": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute str_0 in string str_1 with var_1 , result of the function var_2 , [SEP]",
        "reference": "out . write ( ` npgettext ( % r , % r , % r , count ) ` % ( message_context , join_tokens ( singular , trimmed ) , join_tokens ( plural , trimmed ) ) )",
        "Output": "npgettext ( % r , % r , % r , count ) . singular ( ` npgettext ( % r , % r , % r , count ) ` % ( message_context , var_2 ( join_tokens ) ) )",
        "Var_Maps": [
            {
                "%r": "str_0",
                " npgettext(%r, %r, %r,count) ": "var_0",
                "message_context": "var_1",
                "join_tokens": "var_3",
                "singular": "var_4",
                "trimmed": "var_6",
                "plural": "var_7",
                "write": "var_8",
                "out": "var_9"
            }
        ]
    },
    {
        "intent": "[CLS] called with 2 arguments : singular and trimmed and result of the function join _ token ##s called with 2 arguments : plural and trimmed , write the result to out . if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] substitute str_0 in string str_1 with result of the function var_1 , called with 2 arguments : var_3 , [SEP]",
        "reference": "out . write ( ` ngettext ( % r , % r , count ) ` % ( join_tokens ( singular , trimmed ) , join_tokens ( plural , trimmed ) ) )",
        "Output": "var_4 . join_tokens ( ` ngettext ( % r , % r , count ) ` % var_1 ( singular ) )",
        "Var_Maps": [
            {
                "%r": "str_0",
                " ngettext(%r, %r, count) ": "var_0",
                "join_tokens": "var_2",
                "singular": "var_3",
                "trimmed": "var_5",
                "plural": "var_6",
                "write": "var_7",
                "out": "var_8"
            }
        ]
    },
    {
        "intent": "[CLS] and trimmed and result of the function join _ token ##s called with 2 arguments : plural and trimmed , write the result to out . for every var_1 in var_0 , [SEP]",
        "reference": "for part in singular : pass",
        "Output": "for part in singular : pass",
        "Var_Maps": [
            {
                "singular": "var_0",
                "part": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 with 2 arguments : var_2 and str_0 , var_1 the result to var_3 . [SEP]",
        "reference": "out . write ( blankout ( part , ` S ` ) )",
        "Output": "out . write ( blankout ( part , ` S ` ) )",
        "Var_Maps": [
            {
                "S": "var_4",
                "blankout": "var_0",
                "write": "var_1",
                "part": "var_2",
                "out": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_1 in var_0 , [SEP]",
        "reference": "for part in plural : pass",
        "Output": "for part in plural : pass",
        "Var_Maps": [
            {
                "plural": "var_0",
                "part": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 with 2 arguments : var_2 and str_0 , var_1 the result to var_3 . [SEP]",
        "reference": "out . write ( blankout ( part , ` P ` ) )",
        "Output": "out . write ( blankout ( part , ` P ` ) )",
        "Var_Maps": [
            {
                "P": "var_4",
                "blankout": "var_0",
                "write": "var_1",
                "part": "var_2",
                "out": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if message_context : pass",
        "Output": "if message_context : pass",
        "Var_Maps": [
            {
                "message_context": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] substitute str_0 in string str_1 with var_1 and result of the function var_2 , [SEP]",
        "reference": "out . write ( ` pgettext ( % r , % r ) ` % ( message_context , join_tokens ( singular , trimmed ) ) )",
        "Output": "pgettext ( % r , % r ) . singular ( ` pgettext ( % r , % r ) ` % ( message_context , write . singular ( ) ) )",
        "Var_Maps": [
            {
                "%r": "str_0",
                " pgettext(%r, %r) ": "var_0",
                "message_context": "var_1",
                "join_tokens": "var_2",
                "singular": "var_3",
                "trimmed": "var_4",
                "write": "var_5",
                "out": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] called with 2 arguments : singular and trimmed , write the result to out . if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] substitute str_0 in string str_1 with result of the function var_1 , called with 2 arguments : var_2 , [SEP]",
        "reference": "out . write ( ` gettext ( % r ) ` % join_tokens ( singular , trimmed ) )",
        "Output": "gettext ( % r ) . write ( ` gettext ( % r ) ` % join_tokens ( singular ) )",
        "Var_Maps": [
            {
                "%r": "str_0",
                " gettext(%r) ": "var_0",
                "join_tokens": "var_1",
                "singular": "var_2",
                "trimmed": "var_3",
                "write": "var_4",
                "out": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] and trimmed , write the result to out . for every var_1 in var_0 , [SEP]",
        "reference": "for part in singular : pass",
        "Output": "for part in singular : pass",
        "Var_Maps": [
            {
                "singular": "var_0",
                "part": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 with 2 arguments : var_2 and str_0 , var_1 the result to var_3 . [SEP]",
        "reference": "out . write ( blankout ( part , ` S ` ) )",
        "Output": "out . write ( blankout ( part , ` S ` ) )",
        "Var_Maps": [
            {
                "S": "var_4",
                "blankout": "var_0",
                "write": "var_1",
                "part": "var_2",
                "out": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is none . [SEP]",
        "reference": "message_context = None",
        "Output": "message_context = None",
        "Var_Maps": [
            {
                "message_context": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is boo ##lean false . [SEP]",
        "reference": "intrans = False",
        "Output": "intrans = ` False `",
        "Var_Maps": [
            {
                "intrans": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is boo ##lean false . [SEP]",
        "reference": "inplural = False",
        "Output": "inplural = ` False `",
        "Var_Maps": [
            {
                "inplural": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an empty list . [SEP]",
        "reference": "singular = [ ]",
        "Output": "singular = [ ]",
        "Var_Maps": [
            {
                "singular": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an empty list . [SEP]",
        "reference": "plural = [ ]",
        "Output": "plural = [ ]",
        "Var_Maps": [
            {
                "plural": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] otherwise if var_0 is true , [SEP]",
        "reference": "if True : pass elif pluralmatch : pass",
        "Output": "if ` True ` : pass elif pluralmatch : pass",
        "Var_Maps": [
            {
                "pluralmatch": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is boo ##lean true . [SEP]",
        "reference": "inplural = True",
        "Output": "inplural = ` True `",
        "Var_Maps": [
            {
                "inplural": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] var_1 v var_1 a var_1 r var_1 _ var_1 0 var_1 var_1 i var_1 s var_1 var_1 a var_1 n var_1 var_1 e var_1 m var_1 p var_1 t var_1 y var_1 var_1 s var_1 t var_1 r var_1 i var_1 n var_1 g var_1 . var_1 [SEP]",
        "reference": "filemsg = ` `",
        "Output": "filemsg = ` `",
        "Var_Maps": [
            {
                "filemsg": "var_0",
                "": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if origin : pass",
        "Output": "if origin : pass",
        "Var_Maps": [
            {
                "origin": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 is a string str_0 , where %s is replaced with var_2 . [SEP]",
        "reference": "filemsg = ` file % s , ` % origin",
        "Output": "filemsg = ` file % s , ` % origin",
        "Var_Maps": [
            {
                "file %s, ": "var_0",
                "filemsg": "var_1",
                "origin": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] raise an var_1 wi var_5 h an ar ##gum ##en var_5 s var_5 ring s var_5 r _ 0 , [SEP]",
        "reference": "raise Syntax Error ( ` Translation blocks must not include other block tags : % s ( % sline % d ) ` % ( t . contents , filemsg , t . lineno ) )",
        "Output": "raise Syntax Error ( ` Translation blocks must not include other block tags : % s ( % sline % d ) ` % filemsg [ ` contents ` ] )",
        "Var_Maps": [
            {
                "Translation blocks must not include other block tags: %s (%sline %d)": "var_0",
                "SyntaxError": "var_1",
                "contents": "var_2",
                "filemsg": "var_3",
                "lineno": "var_4",
                "t": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] form ##a var_2 ed wi var_2 h var_2 . con var_2 en var_2 s , file ##ms ##g and var_2 . linen ##o . o var_2 her ##wise if var_2 . var_0 equals var_1 , [SEP]",
        "reference": "if True : pass elif t . token_type = = TOKEN_VAR : pass",
        "Output": "if t . token_type = = TOKEN_VAR : pass",
        "Var_Maps": [
            {
                "token_type": "var_0",
                "TOKEN_VAR": "var_1",
                "t": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if inplural : pass",
        "Output": "if inplural : pass",
        "Var_Maps": [
            {
                "inplural": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_3 s var_4 ring s var_4 r _ 0 var_4 o var_2 , where %s is replaced wi var_4 h var_4 . var_0 . [SEP]",
        "reference": "plural . append ( ` % % ( % s ) s ` % t . contents )",
        "Output": "append = plural ( ` % % ( % s ) s ` % t . contents )",
        "Var_Maps": [
            {
                "%%(%s)s": "var_1",
                "contents": "var_0",
                "plural": "var_2",
                "append": "var_3",
                "t": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] var_3 s var_4 ring s var_4 r _ 0 var_4 o var_0 , where %s is replaced wi var_4 h var_4 . var_1 . [SEP]",
        "reference": "singular . append ( ` % % ( % s ) s ` % t . contents )",
        "Output": "t . append = singular ( % % ( % s ) s )",
        "Var_Maps": [
            {
                "%%(%s)s": "var_2",
                "singular": "var_0",
                "contents": "var_1",
                "append": "var_3",
                "t": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 . var_0 = = var_1 : [SEP]",
        "reference": "if True : pass elif t . token_type = = TOKEN_TEXT : pass",
        "Output": "if t . token_type = = TOKEN_TEXT : pass",
        "Var_Maps": [
            {
                "token_type": "var_0",
                "TOKEN_TEXT": "var_1",
                "t": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call var_5 he me var_5 ho ##d var_0 . var_3 wi var_5 h 2 ar ##gum ##en var_5 s : s var_5 ring s var_5 r _ 0 and var_5 . var_1 , var_3 s var_5 i var_5 u var_5 e var_5 he res ##ul var_5 for var_1 . [SEP]",
        "reference": "contents = one_percent_re . sub ( ` % % ` , t . contents )",
        "Output": "contents = one_percent_re . sub ( ` var_1 ` , t . contents )",
        "Var_Maps": [
            {
                "%%": "var_4",
                "one_percent_re": "var_0",
                "contents": "var_2",
                "sub": "var_3",
                "t": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if inplural : pass",
        "Output": "if inplural : pass",
        "Var_Maps": [
            {
                "inplural": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 var_0 to var_1 . [SEP]",
        "reference": "plural . append ( contents )",
        "Output": "plural . append ( contents )",
        "Var_Maps": [
            {
                "contents": "var_0",
                "plural": "var_1",
                "append": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] var_2 var_1 to var_0 . [SEP]",
        "reference": "singular . append ( contents )",
        "Output": "singular . append ( contents )",
        "Var_Maps": [
            {
                "singular": "var_0",
                "contents": "var_1",
                "append": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] if var_0 is not none , [SEP]",
        "reference": "if comment_lineno_cache is not None : pass",
        "Output": "if comment_lineno_cache is not None : pass",
        "Var_Maps": [
            {
                "comment_lineno_cache": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_3 occurrences of s var_4 r _ 0 in var_4 . var_1 , add var_4 he res ##ul var_4 var_4 o var_4 . var_2 , sub ##s var_4 i var_4 u var_4 e var_4 he res ##ul var_4 for var_0 . [SEP]",
        "reference": "cur_lineno = t . lineno + t . contents . count ( ` \\ n ` )",
        "Output": "cur_lineno = var_4 . count ( ` cur_lineno ` ) + var_4 . lineno",
        "Var_Maps": [
            {
                "\\n": "str_0",
                "cur_lineno": "var_0",
                "contents": "var_1",
                "lineno": "var_2",
                "count": "var_3",
                "t": "var_5",
                "\n": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 equals var_1 . [SEP]",
        "reference": "if comment_lineno_cache = = cur_lineno : pass",
        "Output": "if comment_lineno_cache = = cur_lineno : pass",
        "Var_Maps": [
            {
                "comment_lineno_cache": "var_0",
                "cur_lineno": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 . var_1 is no var_2 equal var_2 o var_0 , [SEP]",
        "reference": "if t . token_type ! = TOKEN_COMMENT : pass",
        "Output": "if t . token_type ! = TOKEN_COMMENT : pass",
        "Var_Maps": [
            {
                "TOKEN_COMMENT": "var_0",
                "token_type": "var_1",
                "t": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_2 in var_1 di var_2 ti ##ona ##ry value under the var_0 key , [SEP]",
        "reference": "for c in lineno_comment_map [ comment_lineno_cache ] : pass",
        "Output": "for c in lineno_comment_map ( lineno_comment_map [ comment_lineno_cache ] ) : pass",
        "Var_Maps": [
            {
                "comment_lineno_cache": "var_0",
                "lineno_comment_map": "var_1",
                "c": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 v var_1 a var_1 r var_1 _ var_1 0 var_1 var_1 i var_1 s var_1 var_1 a var_1 n var_1 var_1 e var_1 m var_1 p var_1 t var_1 y var_1 var_1 s var_1 t var_1 r var_1 i var_1 n var_1 g var_1 . var_1 [SEP]",
        "reference": "filemsg = ` `",
        "Output": "filemsg = ` `",
        "Var_Maps": [
            {
                "filemsg": "var_0",
                "": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if origin : pass",
        "Output": "if origin : pass",
        "Var_Maps": [
            {
                "origin": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 is a string str_0 , where %s is replaced with var_2 . [SEP]",
        "reference": "filemsg = ` file % s , ` % origin",
        "Output": "filemsg = ` file % s , ` % origin",
        "Var_Maps": [
            {
                "file %s, ": "var_0",
                "filemsg": "var_1",
                "origin": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 is a string str_0 , [SEP]",
        "reference": "warn_msg = ( ` The translator - targeted comment ` % s ` ( % sline % d ) was ignored , because it wasn ` t the last item on the line . ` % ( c , filemsg , comment_lineno_cache ) )",
        "Output": "warn_msg = ` The translator - targeted comment ` % s ` ( % sline % d ) was ignored , because it wasn ` t the last item on the line . ` % ( comment_lineno_cache , filemsg )",
        "Var_Maps": [
            {
                "The translator-targeted comment '%s' (%sline %d) was ignored, because it wasn't the last item on the line.": "var_0",
                "comment_lineno_cache": "var_1",
                "warn_msg": "var_2",
                "filemsg": "var_3",
                "c": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] format ##ed with c , file ##ms ##g and comment _ linen ##o _ cache . call the function var_1 . var_3 with 2 arguments : var_2 and var_0 . [SEP]",
        "reference": "warnings . warn ( warn_msg , Translator Comment Warning )",
        "Output": "warnings . warn ( warn_msg , Translator Comment Warning )",
        "Var_Maps": [
            {
                "TranslatorCommentWarning": "var_0",
                "warnings": "var_1",
                "warn_msg": "var_2",
                "warn": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] value under the var_0 key of the var_1 dictionary is an empty string . [SEP]",
        "reference": "lineno_comment_map [ comment_lineno_cache ] = [ ]",
        "Output": "lineno_comment_map [ comment_lineno_cache ] = ` b ` ` `",
        "Var_Maps": [
            {
                "comment_lineno_cache": "var_0",
                "lineno_comment_map": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] var_4 var_1 dictionary value under the var_0 key into a string , separated with str_0 , [SEP]",
        "reference": "out . write ( ` # % s ` % ` | ` . join ( lineno_comment_map [ comment_lineno_cache ] ) )",
        "Output": "return ` # % s ` . join ( lineno_comment_map [ ` write ` ] , comment_lineno_cache )",
        "Var_Maps": [
            {
                " | ": "var_6",
                "comment_lineno_cache": "var_0",
                "lineno_comment_map": "var_1",
                "write": "var_2",
                "# %s": "var_3",
                "join": "var_4",
                "out": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] format with it a string str_0 , write it to out . var_0 is none , [SEP]",
        "reference": "comment_lineno_cache = None",
        "Output": "comment_lineno_cache = None",
        "Var_Maps": [
            {
                "# %s": "str_0",
                "comment_lineno_cache": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 . var_1 equals var_0 , [SEP]",
        "reference": "if t . token_type = = TOKEN_BLOCK : pass",
        "Output": "if t . token_type = = TOKEN_BLOCK : pass",
        "Var_Maps": [
            {
                "TOKEN_BLOCK": "var_0",
                "token_type": "var_1",
                "t": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call var_4 he fun ##c var_4 ion var_0 . var_3 wi var_4 h an ar ##gum ##en var_4 var_4 . var_1 , sub ##s var_4 i var_4 u var_4 e var_4 he res ##ul var_4 for var_2 . [SEP]",
        "reference": "imatch = inline_re . match ( t . contents )",
        "Output": "imatch = inline_re . match ( t . contents )",
        "Var_Maps": [
            {
                "inline_re": "var_0",
                "contents": "var_1",
                "imatch": "var_2",
                "match": "var_3",
                "t": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] call var_4 he fun ##c var_4 ion var_0 . var_3 wi var_4 h an ar ##gum ##en var_4 var_4 . var_1 , sub ##s var_4 i var_4 u var_4 e var_4 he res ##ul var_4 for var_2 . [SEP]",
        "reference": "bmatch = block_re . match ( t . contents )",
        "Output": "bmatch = block_re . match ( t . contents )",
        "Var_Maps": [
            {
                "block_re": "var_0",
                "contents": "var_1",
                "bmatch": "var_2",
                "match": "var_3",
                "t": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] call var_4 he fun ##c var_4 ion var_0 . var_3 wi var_4 h an ar ##gum ##en var_4 var_4 . var_2 , sub ##s var_4 i var_4 u var_4 e var_4 he res ##ul var_4 for var_1 . [SEP]",
        "reference": "cmatches = constant_re . findall ( t . contents )",
        "Output": "cmatches = constant_re . findall ( t . contents )",
        "Var_Maps": [
            {
                "constant_re": "var_0",
                "cmatches": "var_1",
                "contents": "var_2",
                "findall": "var_3",
                "t": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if imatch : pass",
        "Output": "if imatch : pass",
        "Var_Maps": [
            {
                "imatch": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_1 with an ar var_2 um ##ent int ##e var_2 er 1 , substitute the result for var_2 . [SEP]",
        "reference": "g = imatch . group ( 1 )",
        "Output": "g = imatch . group ( )",
        "Var_Maps": [
            {
                "imatch": "var_0",
                "group": "var_1",
                "g": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if first element of var_0 equals a st ##rin var_0 str_0 , [SEP]",
        "reference": "if g [ 0 ] = = ` ` ` : pass",
        "Output": "if g [ 0 ] = = ` ` ` : pass",
        "Var_Maps": [
            {
                "\"": "var_1",
                "g": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 var_1 of str_0 from both ends , [SEP]",
        "reference": "g = g . strip ( ` ` ` )",
        "Output": "var_1 . strip ( ` g ` )",
        "Var_Maps": [
            {
                "\"": "var_3",
                "strip": "var_0",
                "g": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] otherwise if first element of var_0 equals a st ##rin var_0 str_0 , [SEP]",
        "reference": "if True : pass elif g [ 0 ] = = ` ` ` : pass",
        "Output": "if ` True ` : pass elif g [ 0 ] = = ` ` ` : pass",
        "Var_Maps": [
            {
                "'": "var_1",
                "g": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 var_1 of str_0 from both ends , [SEP]",
        "reference": "g = g . strip ( ` ` ` )",
        "Output": "var_1 . strip ( ` g ` )",
        "Var_Maps": [
            {
                "'": "var_3",
                "strip": "var_0",
                "g": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_1 with 2 ar var_3 um ##ents : st ##rin var_3 str_0 and var_3 , var_1 st ##it ##ute the result for . [SEP]",
        "reference": "g = one_percent_re . sub ( ` % % ` , g )",
        "Output": "% % = one_percent_re . % % ( ` g ` , var_3 )",
        "Var_Maps": [
            {
                "%%": "var_2",
                "one_percent_re": "var_0",
                "sub": "var_1",
                "g": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_1 with an argument integer 1 , if it evaluate ##s to true , [SEP]",
        "reference": "if imatch . group ( 2 ) : pass",
        "Output": "if imatch . group ( 1 ) : pass",
        "Var_Maps": [
            {
                "imatch": "var_0",
                "group": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_4 with an argument integer 2 , use the result as an argument for the call to the method var_1 . var_3 , [SEP]",
        "reference": "context_match = context_re . match ( imatch . group ( 2 ) )",
        "Output": "return context_match ( context_re . match ( 2 ) )",
        "Var_Maps": [
            {
                "context_match": "var_0",
                "context_re": "var_1",
                "imatch": "var_2",
                "match": "var_3",
                "group": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] substitute the result for var_1 . call the method var_1 . var_2 with an argument integer 1 , substitute the result for var_0 . [SEP]",
        "reference": "message_context = context_match . group ( 1 )",
        "Output": "message_context = context_match . group ( 1 )",
        "Var_Maps": [
            {
                "message_context": "var_0",
                "context_match": "var_1",
                "group": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if first element of var_0 equals to character str_0 , [SEP]",
        "reference": "if message_context [ 0 ] = = ` ` ` : pass",
        "Output": "if message_context [ 0 ] = = ` ` ` : pass",
        "Var_Maps": [
            {
                "\"": "var_1",
                "message_context": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 var_0 of str_0 characters from both ends , substitute the result for var_0 . [SEP]",
        "reference": "message_context = message_context . strip ( ` ` ` )",
        "Output": "message_context = message_context . strip ( ` ` ` )",
        "Var_Maps": [
            {
                "\"": "var_3",
                "message_context": "var_1",
                "strip": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] otherwise if , first element of var_0 is equal to str_0 , [SEP]",
        "reference": "if True : pass elif message_context [ 0 ] = = ` ` ` : pass",
        "Output": "if ` True ` : pass elif message_context [ 0 ] = = ` ` ` : pass",
        "Var_Maps": [
            {
                "'": "var_1",
                "message_context": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 var_0 of str_0 characters from both ends , substitute the result for var_0 . [SEP]",
        "reference": "message_context = message_context . strip ( ` ` ` )",
        "Output": "message_context = message_context . strip ( ` ` ` )",
        "Var_Maps": [
            {
                "'": "var_3",
                "message_context": "var_1",
                "strip": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] format st ##rin var_4 str_0 with var_1 and var_4 , var_2 it to var_3 . [SEP]",
        "reference": "out . write ( ` pgettext ( % r , % r ) ` % ( message_context , g ) )",
        "Output": "out . write ( ` pgettext ( % r , % r ) ` % ( message_context , g ) )",
        "Var_Maps": [
            {
                " pgettext(%r, %r) ": "var_0",
                "message_context": "var_1",
                "write": "var_2",
                "out": "var_3",
                "g": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is none . [SEP]",
        "reference": "message_context = None",
        "Output": "message_context = None",
        "Var_Maps": [
            {
                "message_context": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] format st ##rin var_3 str_0 with var_3 , var_1 it to var_2 . [SEP]",
        "reference": "out . write ( ` gettext ( % r ) ` % g )",
        "Output": "out . write ( ` gettext ( % r ) ` % g )",
        "Var_Maps": [
            {
                " gettext(%r) ": "var_0",
                "write": "var_1",
                "out": "var_2",
                "g": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] otherwise if var_0 is true , [SEP]",
        "reference": "if True : pass elif bmatch : pass",
        "Output": "if ` True ` : pass elif bmatch : pass",
        "Var_Maps": [
            {
                "bmatch": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call var_4 he me var_4 ho ##d var_0 . var_2 wi var_4 h an ar ##gum ##en var_4 var_4 . var_1 , for every var_3 in var_4 he res ##ul var_4 , [SEP]",
        "reference": "for fmatch in constant_re . findall ( t . contents ) : pass",
        "Output": "for fmatch in constant_re . findall ( var_5 . contents ) : pass",
        "Var_Maps": [
            {
                "constant_re": "var_0",
                "contents": "var_1",
                "findall": "var_2",
                "fmatch": "var_3",
                "t": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] format string str_0 , with var_1 , var_2 it to var_3 . [SEP]",
        "reference": "out . write ( ` _ ( % s ) ` % fmatch )",
        "Output": "out . write ( ` _ ( % s ) ` % fmatch )",
        "Var_Maps": [
            {
                " _(%s) ": "var_0",
                "fmatch": "var_1",
                "write": "var_2",
                "out": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_1 with an argument integer 1 , if it evaluate ##s to true , [SEP]",
        "reference": "if bmatch . group ( 1 ) : pass",
        "Output": "if bmatch . group ( 1 ) : pass",
        "Var_Maps": [
            {
                "bmatch": "var_0",
                "group": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_4 with an argument integer 1 , use the result as an argument for the call to the function var_1 . var_3 , [SEP]",
        "reference": "context_match = context_re . match ( bmatch . group ( 1 ) )",
        "Output": "return var_5 ( context_re . match ( bmatch . group ( 1 ) ) )",
        "Var_Maps": [
            {
                "context_match": "var_0",
                "context_re": "var_1",
                "bmatch": "var_2",
                "match": "var_3",
                "group": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] substitute the result for var_1 . call the method var_1 . var_2 with an argument integer 1 , substitute the result for var_0 . [SEP]",
        "reference": "message_context = context_match . group ( 1 )",
        "Output": "message_context = context_match . group ( 1 )",
        "Var_Maps": [
            {
                "message_context": "var_0",
                "context_match": "var_1",
                "group": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if first element of var_0 equals to character str_0 , [SEP]",
        "reference": "if message_context [ 0 ] = = ` ` ` : pass",
        "Output": "if message_context [ 0 ] = = ` ` ` : pass",
        "Var_Maps": [
            {
                "\"": "var_1",
                "message_context": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 var_0 of str_0 characters from both ends , substitute the result for var_0 . [SEP]",
        "reference": "message_context = message_context . strip ( ` ` ` )",
        "Output": "message_context = message_context . strip ( ` ` ` )",
        "Var_Maps": [
            {
                "\"": "var_3",
                "message_context": "var_1",
                "strip": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] otherwise if first element of var_0 equals to character str_0 , [SEP]",
        "reference": "if True : pass elif message_context [ 0 ] = = ` ` ` : pass",
        "Output": "if ` True ` : pass elif message_context [ 0 ] = = ` ` ` : pass",
        "Var_Maps": [
            {
                "'": "var_1",
                "message_context": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 var_0 of str_0 characters from both ends , substitute the result for var_0 . [SEP]",
        "reference": "message_context = message_context . strip ( ` ` ` )",
        "Output": "message_context = message_context . strip ( ` ` ` )",
        "Var_Maps": [
            {
                "'": "var_3",
                "message_context": "var_1",
                "strip": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is boo ##lean true . [SEP]",
        "reference": "intrans = True",
        "Output": "intrans = ` True `",
        "Var_Maps": [
            {
                "intrans": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is boo ##lean false . [SEP]",
        "reference": "inplural = False",
        "Output": "inplural = ` False `",
        "Var_Maps": [
            {
                "inplural": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if s var_3 ring s var_3 r _ 0 is con var_3 ain ##ed in res ##ul var_3 of var_3 he me var_3 ho ##d var_3 . var_0 , var_1 is boo ##lean true , o var_3 her ##wise is boo ##lean false . [SEP]",
        "reference": "trimmed = ` trimmed ` in t . split_contents ( )",
        "Output": "var_1 = ` trimmed ` in t . split_contents ( )",
        "Var_Maps": [
            {
                "trimmed": "var_2",
                "split_contents": "var_0",
                "t": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an empty list . [SEP]",
        "reference": "singular = [ ]",
        "Output": "singular = [ ]",
        "Var_Maps": [
            {
                "singular": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an empty list . [SEP]",
        "reference": "plural = [ ]",
        "Output": "plural = [ ]",
        "Var_Maps": [
            {
                "plural": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] otherwise if var_0 is true , [SEP]",
        "reference": "if True : pass elif cmatches : pass",
        "Output": "if ` True ` : pass elif cmatches : pass",
        "Var_Maps": [
            {
                "cmatches": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_1 in var_0 , [SEP]",
        "reference": "for cmatch in cmatches : pass",
        "Output": "for cmatch in cmatches : pass",
        "Var_Maps": [
            {
                "cmatches": "var_0",
                "cmatch": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] format string str_0 , with fm ##at ##ch , var_2 it to var_3 . [SEP]",
        "reference": "out . write ( ` _ ( % s ) ` % cmatch )",
        "Output": "out . write ( ` cmatch ` % _ ( % s ) )",
        "Var_Maps": [
            {
                " _(%s) ": "var_0",
                "cmatch": "var_1",
                "write": "var_2",
                "out": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] o var_2 her ##wise if var_2 . var_0 equals a s var_2 ring s var_2 r _ 0 , [SEP]",
        "reference": "if True : pass elif t . contents = = ` comment ` : pass",
        "Output": "if ` True ` : pass elif t . contents = = ` comment ` : pass",
        "Var_Maps": [
            {
                "comment": "var_1",
                "contents": "var_0",
                "t": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is boo ##lean true . [SEP]",
        "reference": "incomment = True",
        "Output": "incomment = ` True `",
        "Var_Maps": [
            {
                "incomment": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call var_4 he fun ##c var_4 ion var_0 wi var_4 h 2 ar ##gum ##en var_4 s : var_4 . var_1 and s var_4 r _ 0 , var_2 var_4 he res ##ul var_4 var_4 o var_3 . [SEP]",
        "reference": "out . write ( blankout ( t . contents , ` B ` ) )",
        "Output": "out = blankout ( t . contents , ` write ` )",
        "Var_Maps": [
            {
                "B": "var_5",
                "blankout": "var_0",
                "contents": "var_1",
                "write": "var_2",
                "out": "var_3",
                "t": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] o var_2 her ##wise if var_2 . var_0 equals var_1 , [SEP]",
        "reference": "if True : pass elif t . token_type = = TOKEN_VAR : pass",
        "Output": "if ` True ` : pass elif t . token_type = = TOKEN_VAR : pass",
        "Var_Maps": [
            {
                "token_type": "var_0",
                "TOKEN_VAR": "var_1",
                "t": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 var_3 . var_0 by s var_3 r _ 0 symbol , sub ##s var_3 i var_3 u var_3 e var_3 he res ##ul var_3 for var_1 , [SEP]",
        "reference": "parts = t . contents . split ( ` | ` )",
        "Output": "parts , parts = t . split ( ` | ` )",
        "Var_Maps": [
            {
                "|": "var_4",
                "contents": "var_0",
                "parts": "var_1",
                "split": "var_2",
                "t": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_0 . var_2 with first element of var_3 as an argument , substitute the result for var_1 . [SEP]",
        "reference": "cmatch = constant_re . match ( parts [ 0 ] )",
        "Output": "cmatch = constant_re . match ( parts [ 0 ] )",
        "Var_Maps": [
            {
                "constant_re": "var_0",
                "cmatch": "var_1",
                "match": "var_2",
                "parts": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if cmatch : pass",
        "Output": "if cmatch : pass",
        "Var_Maps": [
            {
                "cmatch": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_3 with an argument integer 1 , format with the result string str_0 , var_2 it to var_4 . [SEP]",
        "reference": "out . write ( ` _ ( % s ) ` % cmatch . group ( 1 ) )",
        "Output": "out . write ( cmatch . group ( 1 , ` _ ( % s ) ` ) )",
        "Var_Maps": [
            {
                " _(%s) ": "var_0",
                "cmatch": "var_1",
                "write": "var_2",
                "group": "var_3",
                "out": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] for every var_1 in var_0 without the first element , [SEP]",
        "reference": "for p in parts [ 1 : ] : pass",
        "Output": "for p in parts [ 1 : ] : pass",
        "Var_Maps": [
            {
                "parts": "var_0",
                "p": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 index of the occurrence of string str_0 in var_2 , if its greater or equal to integer 0 , [SEP]",
        "reference": "if p . find ( ` : _ ( ` ) > = 0 : pass",
        "Output": "if p . find ( ` var_3 ` ) > = 0 : pass",
        "Var_Maps": [
            {
                ":_(": "var_1",
                "find": "var_0",
                "p": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 var_4 into two var_4 arts at the first str_0 , use the second element of the result to format string str_1 , var_0 it to var_3 . [SEP]",
        "reference": "out . write ( ` % s ` % p . split ( ` : ` , 1 ) [ 1 ] )",
        "Output": "out . write ( p . split ( ` % s ` , 1 ) [ 1 ] . out ( ) )",
        "Var_Maps": [
            {
                ":": "var_5",
                " _(%s) ": "str_1",
                "write": "var_0",
                "split": "var_1",
                " %s ": "var_2",
                "out": "var_3",
                "p": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with 2 arguments : var_3 and str_0 , var_1 the result to var_2 . [SEP]",
        "reference": "out . write ( blankout ( p , ` F ` ) )",
        "Output": "out . write ( blankout ( p , ` F ` ) )",
        "Var_Maps": [
            {
                "F": "var_4",
                "blankout": "var_0",
                "write": "var_1",
                "out": "var_2",
                "p": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] o var_2 her ##wise if var_2 . var_1 equals var_0 , [SEP]",
        "reference": "if True : pass elif t . token_type = = TOKEN_COMMENT : pass",
        "Output": "if ` True ` : pass elif t . token_type = = TOKEN_COMMENT : pass",
        "Var_Maps": [
            {
                "TOKEN_COMMENT": "var_0",
                "token_type": "var_1",
                "t": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] s var_4 rip var_4 . var_2 from var_4 he le ##f var_4 side of w ##hi var_4 es ##pace ##s , if var_4 he res ##ul var_4 s var_4 ar var_4 s wi var_4 h var_0 , [SEP]",
        "reference": "if t . contents . lstrip ( ) . startswith ( TRANSLATOR_COMMENT_MARK ) : pass",
        "Output": "if startswith [ var_5 ] . startswith ( ) in var_5 . lstrip : pass",
        "Var_Maps": [
            {
                "TRANSLATOR_COMMENT_MARK": "var_0",
                "startswith": "var_1",
                "contents": "var_2",
                "lstrip": "var_3",
                "t": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] call var_5 he me var_5 ho ##d var_0 . var_1 wi var_5 h 2 ar ##gum ##en var_5 s : var_5 . var_3 and an em ##p var_5 y li ##s var_5 , var_4 var_5 . var_2 var_5 o var_5 he res ##ul var_5 . [SEP]",
        "reference": "lineno_comment_map . setdefault ( t . lineno , [ ] ) . append ( t . contents )",
        "Output": "lineno_comment_map . setdefault ( var_5 . lineno , ` contents ` )",
        "Var_Maps": [
            {
                "lineno_comment_map": "var_0",
                "setdefault": "var_1",
                "contents": "var_2",
                "lineno": "var_3",
                "append": "var_4",
                "t": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] sub ##s var_2 i var_2 u var_2 e var_2 . var_1 for var_0 . [SEP]",
        "reference": "comment_lineno_cache = t . lineno",
        "Output": "comment_lineno_cache = t . lineno",
        "Var_Maps": [
            {
                "comment_lineno_cache": "var_0",
                "lineno": "var_1",
                "t": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call var_4 he fun ##c var_4 ion var_0 wi var_4 h 2 ar ##gum ##en var_4 s : var_4 . var_1 and s var_4 r _ 0 , var_2 var_4 he res ##ul var_4 var_4 o var_3 . [SEP]",
        "reference": "out . write ( blankout ( t . contents , ` X ` ) )",
        "Output": "out = blankout ( t . contents , ` write ` )",
        "Var_Maps": [
            {
                "X": "var_5",
                "blankout": "var_0",
                "contents": "var_1",
                "write": "var_2",
                "out": "var_3",
                "t": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_0 , return the result . [SEP]",
        "reference": "return out . getvalue ( )",
        "Output": "return out . getvalue ( )",
        "Var_Maps": [
            {
                "getvalue": "var_0",
                "out": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 . [SEP]",
        "reference": "def parse_accept_lang_header ( lang_string ) : pass",
        "Output": "def parse_accept_lang_header ( lang_string ) : pass",
        "Var_Maps": [
            {
                "parse_accept_lang_header": "var_0",
                "lang_string": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an empty list . [SEP]",
        "reference": "result = [ ]",
        "Output": "result = [ ]",
        "Var_Maps": [
            {
                "result": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] convert var_1 to var_4 case , var_3 by the result string var_0 , substitute the result for var_2 . [SEP]",
        "reference": "pieces = accept_language_re . split ( lang_string . lower ( ) )",
        "Output": "pieces = lang_string . lower ( )",
        "Var_Maps": [
            {
                "accept_language_re": "var_0",
                "lang_string": "var_1",
                "pieces": "var_2",
                "split": "var_3",
                "lower": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if last element of var_0 is true , [SEP]",
        "reference": "if pieces [ - 1 ] : pass",
        "Output": "if pieces [ - 1 ] : pass",
        "Var_Maps": [
            {
                "pieces": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] return an empty list . [SEP]",
        "reference": "return [ ]",
        "Output": "return [ ]",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] for every var_3 var_3 n var_1 of var_3 nt ##eger ##s from var_3 nt ##eger 0 to the var_2 gt ##h of var_0 dec ##rem ##ented by one , w var_3 th step of var_3 nt ##eger 3 , [SEP]",
        "reference": "for i in range ( 0 , len ( pieces ) - 1 , 3 ) : pass",
        "Output": "",
        "Var_Maps": [
            {
                "pieces": "var_0",
                "range": "var_1",
                "len": "var_2",
                "i": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] sub ##st var_4 tu ##te 3 success var_4 ve elements start var_4 ng from the var_4 - th var_4 n ##de ##x of var_1 for var_2 , var_3 and var_0 , respect var_4 ve ##ly . [SEP]",
        "reference": "first , lang , priority = pieces [ i : i + 3 ]",
        "Output": "first , lang , priority = pieces [ : pieces [ var_4 ] ]",
        "Var_Maps": [
            {
                "priority": "var_0",
                "pieces": "var_1",
                "first": "var_2",
                "lang": "var_3",
                "i": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if first : pass",
        "Output": "if first : pass",
        "Var_Maps": [
            {
                "first": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] return an empty list . [SEP]",
        "reference": "return [ ]",
        "Output": "return [ ]",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if priority : pass",
        "Output": "if priority : pass",
        "Var_Maps": [
            {
                "priority": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] convert var_0 into a var_2 ing point integer , substitute it for var_0 . [SEP]",
        "reference": "priority = float ( priority )",
        "Output": "priority = float ( priority )",
        "Var_Maps": [
            {
                "priority": "var_1",
                "float": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Value Error : pass",
        "Output": "try : pass except Value Error : pass",
        "Var_Maps": [
            {
                "ValueError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] return an empty list . [SEP]",
        "reference": "return [ ]",
        "Output": "return [ ]",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] if var_0 is false , [SEP]",
        "reference": "if not priority : pass",
        "Output": "if not priority : pass",
        "Var_Maps": [
            {
                "priority": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is floating point number var_1 . [SEP]",
        "reference": "priority = 1 . 0",
        "Output": "",
        "Var_Maps": [
            {
                "priority": "var_0",
                "1.0": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 a tu ##ple with 2 entries var_3 and var_0 to var_1 . [SEP]",
        "reference": "result . append ( ( lang , priority ) )",
        "Output": "result . append ( ( lang , priority ) )",
        "Var_Maps": [
            {
                "priority": "var_0",
                "result": "var_1",
                "append": "var_2",
                "lang": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 var_1 in var_0 d order by the var_3 as lambda function with an argument var_4 and re ##et ##urn value second element of var_4 . [SEP]",
        "reference": "result . sort ( key = lambda k : k [ 1 ] , reverse = True )",
        "Output": "result . sort ( k )",
        "Var_Maps": [
            {
                "reverse": "var_0",
                "result": "var_1",
                "sort": "var_2",
                "key": "var_3",
                "k": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return result",
        "Output": "return result",
        "Var_Maps": [
            {
                "result": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_0 . [SEP]",
        "reference": "import copy",
        "Output": "import copy",
        "Var_Maps": [
            {
                "copy": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] derive the class var_1 from var_0 base class . [SEP]",
        "reference": "class Node ( object ) : pass",
        "Output": "class Node ( object ) : pass",
        "Var_Maps": [
            {
                "object": "var_0",
                "Node": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is a string str_0 . [SEP]",
        "reference": "default = ` DEFAULT `",
        "Output": "default = ` DEFAULT `",
        "Var_Maps": [
            {
                "DEFAULT": "var_1",
                "default": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_1 with 4 arguments : var_4 , var_2 set to none , var_0 set to none and var_3 set to boo ##lean false . [SEP]",
        "reference": "def __init__ ( self , children = None , connector = None , negated = False ) : pass",
        "Output": "def __init__ ( self , children = None , connector = None , negated = ` False ` ) : pass",
        "Var_Maps": [
            {
                "connector": "var_0",
                "__init__": "var_1",
                "children": "var_2",
                "negated": "var_3",
                "self": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , copy var_0 list to var_3 . var_0 , otherwise var_3 . var_0 is an empty list . [SEP]",
        "reference": "self . children = children [ : ] if children else [ ]",
        "Output": "var_4 . children = children or [ ]",
        "Var_Maps": [
            {
                "children": "var_2",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , substitute it for var_3 . var_0 , otherwise substitute var_3 . var_2 for var_3 . var_0 . [SEP]",
        "reference": "self . connector = connector or self . default",
        "Output": "self . connector = connector or self . default",
        "Var_Maps": [
            {
                "connector": "var_1",
                "default": "var_2",
                "self": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_0 for var_2 . var_0 . [SEP]",
        "reference": "self . negated = negated",
        "Output": "self . negated = negated",
        "Var_Maps": [
            {
                "negated": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] decor ##ator var_0 , [SEP]",
        "reference": "@ classmethod def dummy ( ) : pass",
        "Output": "@ classmethod def dummy ( ) : pass",
        "Var_Maps": [
            {
                "classmethod": "var_0",
                "dummy": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 4 arguments : ( var_4 , var_2 set to none , var_1 set to none and var_3 set to boo ##lean false . [SEP]",
        "reference": "def _new_instance ( cls , children = None , connector = None , negated = False ) : pass",
        "Output": "def _new_instance ( cls , children = None , connector = None , negated = ` False ` ) : pass",
        "Var_Maps": [
            {
                "_new_instance": "var_0",
                "connector": "var_1",
                "children": "var_2",
                "negated": "var_3",
                "cls": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] var_4 is an instance of var_3 class , created with 3 arguments : var_1 , var_0 and var_2 . [SEP]",
        "reference": "obj = Node ( children , connector , negated )",
        "Output": "obj = Node ( children , connector , negated )",
        "Var_Maps": [
            {
                "connector": "var_0",
                "children": "var_1",
                "negated": "var_2",
                "Node": "var_3",
                "obj": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_2 for var_1 . var_0 . [SEP]",
        "reference": "obj . __class__ = cls",
        "Output": "obj . __class__ = cls",
        "Var_Maps": [
            {
                "__class__": "var_0",
                "obj": "var_1",
                "cls": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return obj",
        "Output": "return obj",
        "Var_Maps": [
            {
                "obj": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def __str__ ( self ) : pass",
        "Output": "def __str__ ( self ) : pass",
        "Var_Maps": [
            {
                "__str__": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 . var_0 , [SEP]",
        "reference": "if self . negated : pass",
        "Output": "if self . negated : pass",
        "Var_Maps": [
            {
                "negated": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return var_6 ing var_6 _ 0 ##var _ 7 ##form ##ated with var_3 . var_1 and var_6 ing var _ 8 ##reate ##d by var_4 ing var _ 8 into a var_6 ing ##var _ 7 ##se ##para ##ted by var_6 _ 1 , [SEP]",
        "reference": "return ` ( NOT ( % s : % s ) ) ` % ( self . connector , ` , ` . join ( [ str ( c ) for c in self . children ] ) )",
        "Output": "return str ( var_3 . connector ) . str ( c . ( NOT ( % s : % s ) ) . children ( ) )",
        "Var_Maps": [
            {
                "(NOT (%s: %s))": "var_0",
                ", ": "var_7",
                "connector": "var_1",
                "children": "var_2",
                "self": "var_5",
                "join": "var_4",
                "str": "var_6",
                "c": "var_9"
            }
        ]
    },
    {
        "intent": "[CLS] for every var _ 8 in var_3 . var_2 . return var_6 ing var_6 _ 0 ##var _ 7 ##form ##ated with var_3 . var_0 and var_6 ing var _ 8 ##reate ##d by var_4 ing var _ 8 into a var_6 ing ##var _ 7 ##se ##para ##ted by var_6 _ 1 , [SEP]",
        "reference": "return ` ( % s : % s ) ` % ( self . connector , ` , ` . join ( [ str ( c ) for c in self . children ] ) )",
        "Output": "return c . ( % s : % s ) ( , + join ( self . connector ) for var_8 in self . children )",
        "Var_Maps": [
            {
                "(%s: %s)": "var_1",
                ", ": "var_7",
                "connector": "var_0",
                "children": "var_2",
                "self": "var_5",
                "join": "var_4",
                "str": "var_6",
                "c": "var_9"
            }
        ]
    },
    {
        "intent": "[CLS] for every c in var_1 . children . define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def __repr__ ( self ) : pass",
        "Output": "def __repr__ ( self ) : pass",
        "Var_Maps": [
            {
                "__repr__": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return string str_0 , format ##ed with var_3 . var_0 . var_2 and var_3 . [SEP]",
        "reference": "return ` < % s : % s > ` % ( self . __class__ . __name__ , self )",
        "Output": "return ` < % s : % s > ` % ( self . __class__ . __name__ , self )",
        "Var_Maps": [
            {
                "<%s: %s>": "var_1",
                "__class__": "var_0",
                "__name__": "var_2",
                "self": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments : var_2 and var_1 . [SEP]",
        "reference": "def __deepcopy__ ( self , memodict ) : pass",
        "Output": "def __deepcopy__ ( self , memodict ) : pass",
        "Var_Maps": [
            {
                "__deepcopy__": "var_0",
                "memodict": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var _ 7 is an instance of var_4 class , created with 2 arguments : var_0 set to var_5 . var_0 and var_2 set to var_5 . var_2 . [SEP]",
        "reference": "obj = Node ( connector = self . connector , negated = self . negated )",
        "Output": "obj = Node ( connector = self . connector , negated = self . negated )",
        "Var_Maps": [
            {
                "connector": "var_1",
                "negated": "var_3",
                "Node": "var_4",
                "self": "var_6",
                "obj": "var_7"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_2 . var_0 for var_3 . var_0 . [SEP]",
        "reference": "obj . __class__ = self . __class__",
        "Output": "obj . __class__ = self . __class__",
        "Var_Maps": [
            {
                "__class__": "var_1",
                "self": "var_2",
                "obj": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_4 . var_1 with 2 arguments : var_5 . var_0 and var_3 , substitute the result for var_6 . var_0 . [SEP]",
        "reference": "obj . children = copy . deepcopy ( self . children , memodict )",
        "Output": "obj . children = copy . deepcopy ( self . children , memodict )",
        "Var_Maps": [
            {
                "children": "var_2",
                "deepcopy": "var_1",
                "memodict": "var_3",
                "copy": "var_4",
                "self": "var_5",
                "obj": "var_6"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return obj",
        "Output": "return obj",
        "Var_Maps": [
            {
                "obj": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def __len__ ( self ) : pass",
        "Output": "def __len__ ( self ) : pass",
        "Var_Maps": [
            {
                "__len__": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return the var_2 gt ##h of var_1 . var_0 . [SEP]",
        "reference": "return len ( self . children )",
        "Output": "return len ( self . children )",
        "Var_Maps": [
            {
                "children": "var_0",
                "self": "var_1",
                "len": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def __bool__ ( self ) : pass",
        "Output": "def __bool__ ( self ) : pass",
        "Var_Maps": [
            {
                "__bool__": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] convert var_2 . var_0 into an var_1 ea ##n , return it . [SEP]",
        "reference": "return bool ( self . children )",
        "Output": "return bool ( self . children )",
        "Var_Maps": [
            {
                "children": "var_0",
                "bool": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def __nonzero__ ( self ) : pass",
        "Output": "def __nonzero__ ( self ) : pass",
        "Var_Maps": [
            {
                "__nonzero__": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] get the var_1 of the var_2 object , on the result call the var_0 method with an argument var_2 , return the result . [SEP]",
        "reference": "return type ( self ) . __bool__ ( self )",
        "Output": "return type ( self ) . __bool__ ( self )",
        "Var_Maps": [
            {
                "__bool__": "var_0",
                "type": "var_1",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments : var_2 and var_1 . [SEP]",
        "reference": "def __contains__ ( self , other ) : pass",
        "Output": "def __contains__ ( self , other ) : pass",
        "Var_Maps": [
            {
                "__contains__": "var_0",
                "other": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 is contained in var_2 . var_0 , return boo ##lean true , var_1 wise return boo ##lean false . [SEP]",
        "reference": "return other in self . children",
        "Output": "return other in self . children",
        "Var_Maps": [
            {
                "children": "var_0",
                "other": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments : var_1 and var_2 . [SEP]",
        "reference": "def _prepare_data ( self , data ) : pass",
        "Output": "def _prepare_data ( self , data ) : pass",
        "Var_Maps": [
            {
                "_prepare_data": "var_0",
                "self": "var_1",
                "data": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return data",
        "Output": "return data",
        "Var_Maps": [
            {
                "data": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_4 with 4 arguments : var_2 , var_3 , var_0 and var_1 set to boo ##lean true . [SEP]",
        "reference": "def add ( self , data , conn_type , squash = True ) : pass",
        "Output": "def add ( self , data , conn_type , squash = ` True ` ) : pass",
        "Var_Maps": [
            {
                "conn_type": "var_0",
                "squash": "var_1",
                "self": "var_2",
                "data": "var_3",
                "add": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 is contained in var_2 . var_0 , [SEP]",
        "reference": "if data in self . children : pass",
        "Output": "if data in self . children : pass",
        "Var_Maps": [
            {
                "children": "var_0",
                "data": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return data",
        "Output": "return data",
        "Var_Maps": [
            {
                "data": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 with an argument var_1 , substitute the result for var_1 . [SEP]",
        "reference": "data = self . _prepare_data ( data )",
        "Output": "data = self . _prepare_data ( data )",
        "Var_Maps": [
            {
                "_prepare_data": "var_0",
                "data": "var_3",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is false , [SEP]",
        "reference": "if not squash : pass",
        "Output": "if not squash : pass",
        "Var_Maps": [
            {
                "squash": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 var_3 to var_2 . var_0 . [SEP]",
        "reference": "self . children . append ( data )",
        "Output": "self . children . append ( data )",
        "Var_Maps": [
            {
                "children": "var_0",
                "append": "var_1",
                "self": "var_2",
                "data": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return data",
        "Output": "return data",
        "Var_Maps": [
            {
                "data": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_2 . var_0 equals var_1 , [SEP]",
        "reference": "if self . connector = = conn_type : pass",
        "Output": "if self . connector = = conn_type : pass",
        "Var_Maps": [
            {
                "connector": "var_0",
                "conn_type": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_4 is instance of var_5 and var_4 . var_3 is false , and if var_4 . var_1 equals var_2 or var _ 9 ##gt ##h of var_4 equals integer 1 , [SEP]",
        "reference": "if isinstance ( data , Node ) and not data . negated and ( data . connector = = conn_type or len ( data ) = = 1 ) : pass",
        "Output": "if not isinstance ( var_7 , var_7 . negated ) or data ( var_7 . connector ) = = 1 : pass",
        "Var_Maps": [
            {
                "isinstance": "var_0",
                "connector": "var_1",
                "conn_type": "var_2",
                "negated": "var_3",
                "data": "var_8",
                "Node": "var_5",
                "len": "var_9"
            }
        ]
    },
    {
        "intent": "[CLS] var_2 var_3 . var_0 list with var_4 . var_0 . [SEP]",
        "reference": "self . children . extend ( data . children )",
        "Output": "self . children . extend ( data . children )",
        "Var_Maps": [
            {
                "children": "var_1",
                "extend": "var_2",
                "self": "var_3",
                "data": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return self",
        "Output": "return self",
        "Var_Maps": [
            {
                "self": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] var_1 var_3 to var_2 . var_0 . [SEP]",
        "reference": "self . children . append ( data )",
        "Output": "self . children . append ( data )",
        "Var_Maps": [
            {
                "children": "var_0",
                "append": "var_1",
                "self": "var_2",
                "data": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return data",
        "Output": "return data",
        "Var_Maps": [
            {
                "data": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the method var_4 . var_0 with 3 arguments : var_4 . var_2 , var_4 . var_1 and var_4 . var_3 , substitute the result for var _ 8 . [SEP]",
        "reference": "obj = self . _new_instance ( self . children , self . connector , self . negated )",
        "Output": "self = var_6 . _new_instance ( var_6 . children , var_6 . connector , var_6 . negated )",
        "Var_Maps": [
            {
                "_new_instance": "var_0",
                "connector": "var_1",
                "children": "var_2",
                "negated": "var_3",
                "self": "var_7",
                "obj": "var_8"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_2 . var_0 . [SEP]",
        "reference": "self . connector = conn_type",
        "Output": "self . connector = conn_type",
        "Var_Maps": [
            {
                "connector": "var_0",
                "conn_type": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 . var_0 is an list with 2 elements : var_3 and var_2 . [SEP]",
        "reference": "self . children = [ obj , data ]",
        "Output": "self . children = [ obj , data ]",
        "Var_Maps": [
            {
                "children": "var_0",
                "self": "var_1",
                "data": "var_2",
                "obj": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return data",
        "Output": "return data",
        "Var_Maps": [
            {
                "data": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def negate ( self ) : pass",
        "Output": "def negate ( self ) : pass",
        "Var_Maps": [
            {
                "negate": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] in ##vert var_2 . var_0 . [SEP]",
        "reference": "self . negated = not self . negated",
        "Output": "var_2 . var_0 = not var_2 . var_0",
        "Var_Maps": [
            {
                "negated": "var_1",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] from var_1 import var_0 into default name space . [SEP]",
        "reference": "from __future__ import unicode_literals",
        "Output": "from __future__ import unicode_literals",
        "Var_Maps": [
            {
                "unicode_literals": "var_0",
                "__future__": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_1 import var_0 and var_2 into default name space . [SEP]",
        "reference": "from datetime import timedelta , tzinfo",
        "Output": "from datetime import timedelta , tzinfo",
        "Var_Maps": [
            {
                "timedelta": "var_0",
                "datetime": "var_1",
                "tzinfo": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_0 . [SEP]",
        "reference": "import time",
        "Output": "import time",
        "Var_Maps": [
            {
                "time": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_0 . [SEP]",
        "reference": "import warnings",
        "Output": "import warnings",
        "Var_Maps": [
            {
                "warnings": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . utils . deprecation import Removed In Django19Warning",
        "Output": "from django . utils . deprecation import Removed In Django19Warning",
        "Var_Maps": [
            {
                "django.utils.deprecation": "var_0",
                "RemovedInDjango19Warning": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_1 import var_3 , var_2 and var_0 into default name space . [SEP]",
        "reference": "from django . utils . encoding import force_str , force_text , DEFAULT_LOCALE_ENCODING",
        "Output": "from django . utils . encoding import force_str , force_text , DEFAULT_LOCALE_ENCODING",
        "Var_Maps": [
            {
                "DEFAULT_LOCALE_ENCODING": "var_0",
                "django.utils.encoding": "var_1",
                "force_text": "var_2",
                "force_str": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_3 . var_4 with 3 arguments : string str_0 [SEP]",
        "reference": "warnings . warn ( ` django . utils . tzinfo will be removed in Django 1 . 9 . Use django . utils . timezone instead . ` , Removed In Django19Warning , stacklevel = 2 )",
        "Output": "warnings . warn ( ` django . utils . tzinfo will be removed in Django 1 . 9 . Use django . utils . timezone instead . ` , Removed In Django19Warning , stacklevel = 2 )",
        "Var_Maps": [
            {
                "django.utils.tzinfo will be removed in Django 1.9. ": "str_0",
                "django.utils.tzinfo will be removed in Django 1.9. Use django.utils.timezone instead.": "var_0",
                "RemovedInDjango19Warning": "var_1",
                "stacklevel": "var_2",
                "warnings": "var_3",
                "warn": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] str_0 , removed ##ind ##jan ##go ##19 ##war ##ning and stack ##lev ##el set to 2 . derive the class var_0 from the var_1 base class . [SEP]",
        "reference": "class Fixed Offset ( tzinfo ) : pass",
        "Output": "class Fixed Offset ( tzinfo ) : pass",
        "Var_Maps": [
            {
                "Use django.utils.timezone instead.": "str_0",
                "FixedOffset": "var_0",
                "tzinfo": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments : var_2 and var_1 . [SEP]",
        "reference": "def __init__ ( self , offset ) : pass",
        "Output": "def __init__ ( self , offset ) : pass",
        "Var_Maps": [
            {
                "__init__": "var_0",
                "offset": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_2 . var_3 with 2 arguments : str_0 [SEP]",
        "reference": "warnings . warn ( ` django . utils . tzinfo . Fixed Offset will be removed in Django 1 . 9 . Use django . utils . timezone . get_fixed_timezone instead . ` , Removed In Django19Warning )",
        "Output": "warnings . warn ( ` Removed In Django19Warning ` )",
        "Var_Maps": [
            {
                "django.utils.tzinfo.FixedOffset will be removed in Django 1.9. ": "str_0",
                "django.utils.tzinfo.FixedOffset will be removed in Django 1.9. Use django.utils.timezone.get_fixed_timezone instead.": "var_0",
                "RemovedInDjango19Warning": "var_1",
                "warnings": "var_2",
                "warn": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] str_0 and removed ##ind ##jan ##go ##19 ##war ##ning . if var_2 is an instance of var_1 class , [SEP]",
        "reference": "if isinstance ( offset , timedelta ) : pass",
        "Output": "if isinstance ( offset , timedelta ) : pass",
        "Var_Maps": [
            {
                "Use django.utils.timezone.get_fixed_timezone instead.": "str_0",
                "isinstance": "var_0",
                "timedelta": "var_1",
                "offset": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_2 . var_0 . [SEP]",
        "reference": "self . __offset = offset",
        "Output": "self . __offset = offset",
        "Var_Maps": [
            {
                "__offset": "var_0",
                "offset": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_3 . var_0 . var_1 for var_2 . [SEP]",
        "reference": "offset = self . __offset . seconds / / 60",
        "Output": "offset = self . __offset . seconds",
        "Var_Maps": [
            {
                "__offset": "var_0",
                "seconds": "var_1",
                "offset": "var_2",
                "self": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_2 set to var_3 , substitute the result for var_4 . var_1 . [SEP]",
        "reference": "self . __offset = timedelta ( minutes = offset )",
        "Output": "self . __offset = timedelta ( minutes = offset )",
        "Var_Maps": [
            {
                "timedelta": "var_0",
                "__offset": "var_1",
                "minutes": "var_2",
                "offset": "var_3",
                "self": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is lesser than integer 0 , var_1 is set to str_0 , otherwise var_1 is str_1 , [SEP]",
        "reference": "sign = ` - ` if offset < 0 else ` + `",
        "Output": "sign = ` - ` if offset > 0 else ` + `",
        "Var_Maps": [
            {
                "-": "var_2",
                "+": "var_3",
                "offset": "var_0",
                "sign": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] var_4 . var_1 is a string str_0 , replace %s with var_5 , str_1 is replaced with var _ 7 ##ol ##ute value of var_2 divided by 60 , [SEP]",
        "reference": "self . __name = ` % s % 02d % 02d ` % ( sign , abs ( offset ) / 60 . 0 , abs ( offset ) % 60 )",
        "Output": "self . __name = ` % s % 02d % 02d ` % ( sign , offset , var_7 ( var_2 ) )",
        "Var_Maps": [
            {
                "%s%02d%02d": "var_0",
                "%02d": "str_1",
                "__name": "var_1",
                "offset": "var_3",
                "self": "var_4",
                "sign": "var_5",
                "60.0": "var_6",
                "abs": "var_8"
            }
        ]
    },
    {
        "intent": "[CLS] and placed into 2 character spaces , and str_0 is replaced with reminder of the division of absolute offset by integer 60 , and placed into 2 character spaces . define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def __repr__ ( self ) : pass",
        "Output": "def __repr__ ( self ) : pass",
        "Var_Maps": [
            {
                "%02d": "str_0",
                "__repr__": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return var_1 . var_0 . [SEP]",
        "reference": "return self . __name",
        "Output": "return self . __name",
        "Var_Maps": [
            {
                "__name": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def __getinitargs__ ( self ) : pass",
        "Output": "def __getinitargs__ ( self ) : pass",
        "Var_Maps": [
            {
                "__getinitargs__": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return a tu ##ple with an element var_1 . var_0 . [SEP]",
        "reference": "return self . __offset ,",
        "Output": "return self . __offset ,",
        "Var_Maps": [
            {
                "__offset": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments var_1 and var_2 . [SEP]",
        "reference": "def utcoffset ( self , dt ) : pass",
        "Output": "def utcoffset ( self , dt ) : pass",
        "Var_Maps": [
            {
                "utcoffset": "var_0",
                "self": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_1 . var_0 . [SEP]",
        "reference": "return self . __offset",
        "Output": "return self . __offset",
        "Var_Maps": [
            {
                "__offset": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments var_1 and var_2 . [SEP]",
        "reference": "def tzname ( self , dt ) : pass",
        "Output": "def tzname ( self , dt ) : pass",
        "Var_Maps": [
            {
                "tzname": "var_0",
                "self": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_1 . var_0 . [SEP]",
        "reference": "return self . __name",
        "Output": "return self . __name",
        "Var_Maps": [
            {
                "__name": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_1 with 2 arguments var_0 and var_2 . [SEP]",
        "reference": "def dst ( self , dt ) : pass",
        "Output": "def dst ( self , dt ) : pass",
        "Var_Maps": [
            {
                "self": "var_0",
                "dst": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument integer 0 , return the result . [SEP]",
        "reference": "return timedelta ( 0 )",
        "Output": "return timedelta ( 0 )",
        "Var_Maps": [
            {
                "timedelta": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] derive the class var_0 from the var_1 base class . [SEP]",
        "reference": "class Local Timezone ( tzinfo ) : pass",
        "Output": "class Local Timezone ( tzinfo ) : pass",
        "Var_Maps": [
            {
                "LocalTimezone": "var_0",
                "tzinfo": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments var_1 and var_2 . [SEP]",
        "reference": "def __init__ ( self , dt ) : pass",
        "Output": "def __init__ ( self , dt ) : pass",
        "Var_Maps": [
            {
                "__init__": "var_0",
                "self": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_2 . var_3 with 2 arguments : string str_0 [SEP]",
        "reference": "warnings . warn ( ` django . utils . tzinfo . Local Timezone will be removed in Django 1 . 9 . Use django . utils . timezone . get_default_timezone instead . ` , Removed In Django19Warning )",
        "Output": "warnings . warn ( ` django . utils . tzinfo . Local Timezone will be removed in Django 1 . 9 . Use django . utils . timezone . get_default_timezone instead . ` , Removed In Django19Warning )",
        "Var_Maps": [
            {
                "django.utils.tzinfo.LocalTimezone will be removed in Django 1.9. ": "str_0",
                "django.utils.tzinfo.LocalTimezone will be removed in Django 1.9. Use django.utils.timezone.get_default_timezone instead.": "var_0",
                "RemovedInDjango19Warning": "var_1",
                "warnings": "var_2",
                "warn": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] str_0 and removed ##ind ##jan ##go ##19 ##war ##ning . call the method var_1 . var_0 with an argument var_2 . [SEP]",
        "reference": "tzinfo . __init__ ( self )",
        "Output": "tzinfo . __init__ ( self )",
        "Var_Maps": [
            {
                "Use django.utils.timezone.get_default_timezone instead.": "str_0",
                "__init__": "var_0",
                "tzinfo": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_2 for var_0 . var_1 . [SEP]",
        "reference": "self . __dt = dt",
        "Output": "self . __dt = dt",
        "Var_Maps": [
            {
                "self": "var_0",
                "__dt": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_1 with an argument var_4 , substitute the result for var_2 . var_0 . [SEP]",
        "reference": "self . _tzname = self . tzname ( dt )",
        "Output": "self . _tzname = self . tzname ( dt )",
        "Var_Maps": [
            {
                "_tzname": "var_0",
                "tzname": "var_1",
                "self": "var_3",
                "dt": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def __repr__ ( self ) : pass",
        "Output": "def __repr__ ( self ) : pass",
        "Var_Maps": [
            {
                "__repr__": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_2 . var_1 , return the result . [SEP]",
        "reference": "return force_str ( self . _tzname )",
        "Output": "return force_str ( self . _tzname )",
        "Var_Maps": [
            {
                "force_str": "var_0",
                "_tzname": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with an argument var_1 . [SEP]",
        "reference": "def __getinitargs__ ( self ) : pass",
        "Output": "def __getinitargs__ ( self ) : pass",
        "Var_Maps": [
            {
                "__getinitargs__": "var_0",
                "self": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return a tu ##ple with an element var_0 . var_1 . [SEP]",
        "reference": "return self . __dt ,",
        "Output": "return self . __dt ,",
        "Var_Maps": [
            {
                "self": "var_0",
                "__dt": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments var_1 and var_2 . [SEP]",
        "reference": "def utcoffset ( self , dt ) : pass",
        "Output": "def utcoffset ( self , dt ) : pass",
        "Var_Maps": [
            {
                "utcoffset": "var_0",
                "self": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the net ##ho ##d var_1 . var_0 with an argument var_2 , if it evaluate ##s to true , [SEP]",
        "reference": "if self . _isdst ( dt ) : pass",
        "Output": "if self . _isdst ( dt ) : pass",
        "Var_Maps": [
            {
                "_isdst": "var_0",
                "self": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_1 as negative var_3 . var_2 , return the result . [SEP]",
        "reference": "return timedelta ( seconds = - time . altzone )",
        "Output": "return timedelta ( seconds = time . altzone )",
        "Var_Maps": [
            {
                "timedelta": "var_0",
                "seconds": "var_1",
                "altzone": "var_2",
                "time": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_2 as negative var_3 . var_1 , return the result . [SEP]",
        "reference": "return timedelta ( seconds = - time . timezone )",
        "Output": "return timedelta ( time . timezone )",
        "Var_Maps": [
            {
                "timedelta": "var_0",
                "timezone": "var_1",
                "seconds": "var_2",
                "time": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_1 with 2 arguments var_0 and var_2 . [SEP]",
        "reference": "def dst ( self , dt ) : pass",
        "Output": "def dst ( self , dt ) : pass",
        "Var_Maps": [
            {
                "self": "var_0",
                "dst": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the net ##ho ##d var_1 . var_0 with an argument var_2 , if it evaluate ##s to true , [SEP]",
        "reference": "if self . _isdst ( dt ) : pass",
        "Output": "if self . _isdst ( dt ) : pass",
        "Var_Maps": [
            {
                "_isdst": "var_0",
                "self": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument var_3 as negative var_6 . var_2 , sub ##tra ##ct the result from the result of the call , [SEP]",
        "reference": "return timedelta ( seconds = - time . altzone ) - timedelta ( seconds = - time . timezone )",
        "Output": "timedelta = var_0 ( altzone ) - var_0 ( timedelta ) - var_6 . timezone",
        "Var_Maps": [
            {
                "timedelta": "var_1",
                "timezone": "var_2",
                "seconds": "var_5",
                "altzone": "var_4",
                "time": "var_7"
            }
        ]
    },
    {
        "intent": "[CLS] to the function timed ##elt ##a called with an argument seconds as negative time . alt ##zone , return the result . if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the function var_0 with an argument integer 0 , return the result . [SEP]",
        "reference": "return timedelta ( 0 )",
        "Output": "return timedelta ( 0 )",
        "Var_Maps": [
            {
                "timedelta": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments var_1 and var_2 . [SEP]",
        "reference": "def tzname ( self , dt ) : pass",
        "Output": "def tzname ( self , dt ) : pass",
        "Var_Maps": [
            {
                "tzname": "var_0",
                "self": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if var_3 is none var_0 is boo ##lean false , otherwise call the method var_2 . var_1 with an argument var_3 , substitute the result for var_0 . [SEP]",
        "reference": "is_dst = False if dt is None else self . _isdst ( dt )",
        "Output": "dt = dt is None or self . _isdst ( dt )",
        "Var_Maps": [
            {
                "is_dst": "var_0",
                "_isdst": "var_1",
                "self": "var_2",
                "dt": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the function var_1 with 2 arguments : value under the var_3 key of the var_4 . var_2 and var_0 , [SEP]",
        "reference": "return force_text ( time . tzname [ is_dst ] , DEFAULT_LOCALE_ENCODING )",
        "Output": "return force_text ( time . tzname [ is_dst ] , DEFAULT_LOCALE_ENCODING )",
        "Var_Maps": [
            {
                "DEFAULT_LOCALE_ENCODING": "var_0",
                "force_text": "var_1",
                "tzname": "var_2",
                "is_dst": "var_3",
                "time": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] return the result . if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Unicode Decode Error : pass",
        "Output": "try : pass except Unicode Decode Error : pass",
        "Var_Maps": [
            {
                "UnicodeDecodeError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] return none . [SEP]",
        "reference": "return None",
        "Output": "return None",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 2 arguments var_1 and var_2 . [SEP]",
        "reference": "def _isdst ( self , dt ) : pass",
        "Output": "def _isdst ( self , dt ) : pass",
        "Var_Maps": [
            {
                "_isdst": "var_0",
                "self": "var_1",
                "dt": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var _ 7 is an tu ##ple with 9 elements : var _ 8 . var_4 , var _ 8 . var_3 , var _ 8 . var_6 , var _ 8 . var_5 , var _ 8 . var_1 , var _ 8 . var_2 , result of the function var _ 8 . var_0 , [SEP]",
        "reference": "tt = dt . year , dt . month , dt . day , dt . hour , dt . minute , dt . second , dt . weekday ( ) , 0 , 0",
        "Output": "tt = minute1 . year , minute1 . month , minute1 . day , minute1 . weekday ( )",
        "Var_Maps": [
            {
                "weekday": "var_0",
                "minute": "var_1",
                "second": "var_2",
                "month": "var_3",
                "year": "var_4",
                "hour": "var_5",
                "day": "var_6",
                "tt": "var_7",
                "dt": "var_14"
            }
        ]
    },
    {
        "intent": "[CLS] integer 0 and integer 0 . try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 with an argument var_3 , substitute the result for var_1 . [SEP]",
        "reference": "stamp = time . mktime ( tt )",
        "Output": "stamp = time . mktime ( tt )",
        "Var_Maps": [
            {
                "mktime": "var_0",
                "stamp": "var_1",
                "time": "var_2",
                "tt": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 or var_1 exceptions are caught , [SEP]",
        "reference": "try : pass except ( Overflow Error , Value Error ) : pass",
        "Output": "try : pass except ( Overflow Error , Value Error ) : pass",
        "Var_Maps": [
            {
                "OverflowError": "var_0",
                "ValueError": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] create a tu ##ple out a tu ##ple with an element integer 203 ##7 and a list var_0 elements without the first element , substitute the result for var_0 . [SEP]",
        "reference": "tt = ( 2037 , ) + tt [ 1 : ]",
        "Output": "",
        "Var_Maps": [
            {
                "tt": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 with an argument var_3 , substitute the result for var_1 . [SEP]",
        "reference": "stamp = time . mktime ( tt )",
        "Output": "stamp = time . mktime ( tt )",
        "Var_Maps": [
            {
                "mktime": "var_0",
                "stamp": "var_1",
                "time": "var_2",
                "tt": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 with an argument var_1 , substitute the result for var_3 . [SEP]",
        "reference": "tt = time . localtime ( stamp )",
        "Output": "tt = time . localtime ( stamp )",
        "Var_Maps": [
            {
                "localtime": "var_0",
                "stamp": "var_1",
                "time": "var_2",
                "tt": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_1 . var_0 is greater than int ##ger 0 , return boo ##lean true , otherwise return boo ##lean false . [SEP]",
        "reference": "return tt . tm_isdst > 0",
        "Output": "return tt . tm_isdst > 0",
        "Var_Maps": [
            {
                "tm_isdst": "var_0",
                "tt": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_1 import var_0 into default name space . [SEP]",
        "reference": "from __future__ import absolute_import",
        "Output": "from __future__ import absolute_import",
        "Var_Maps": [
            {
                "absolute_import": "var_0",
                "__future__": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_0 . [SEP]",
        "reference": "import warnings",
        "Output": "import warnings",
        "Var_Maps": [
            {
                "warnings": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from django . utils . deprecation import Removed In Django19Warning",
        "Output": "from django . utils . deprecation import Removed In Django19Warning",
        "Var_Maps": [
            {
                "django.utils.deprecation": "var_0",
                "RemovedInDjango19Warning": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_3 . var_4 with 3 arguments : string str_0 , [SEP]",
        "reference": "warnings . warn ( ` django . utils . unittest will be removed in Django 1 . 9 . ` , Removed In Django19Warning , stacklevel = 2 )",
        "Output": "warnings . warn ( ` django . utils . unittest will be removed in Django 1 . 9 . ` , Removed In Django19Warning , stacklevel = 2 )",
        "Var_Maps": [
            {
                "django.utils.unittest will be removed in Django 1.9.": "var_0",
                "RemovedInDjango19Warning": "var_1",
                "stacklevel": "var_2",
                "warnings": "var_3",
                "warn": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] removed ##ind ##jan ##go ##19 ##war ##ning and stack ##lev ##el as integer 2 . try , [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] from var_0 import everything . [SEP]",
        "reference": "from unittest2 import *",
        "Output": "from unittest2 import *",
        "Var_Maps": [
            {
                "unittest2": "var_0",
                "*": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Import Error : pass",
        "Output": "try : pass except Import Error : pass",
        "Var_Maps": [
            {
                "ImportError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import import everything . [SEP]",
        "reference": "from unittest import *",
        "Output": "from unittest import *",
        "Var_Maps": [
            {
                "unittest": "var_0",
                "*": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] from var_1 import var_0 into default name space . [SEP]",
        "reference": "from __future__ import unicode_literals",
        "Output": "from __future__ import unicode_literals",
        "Var_Maps": [
            {
                "unicode_literals": "var_0",
                "__future__": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_0 . [SEP]",
        "reference": "import datetime",
        "Output": "import datetime",
        "Var_Maps": [
            {
                "datetime": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_0 . [SEP]",
        "reference": "import os",
        "Output": "import os",
        "Var_Maps": [
            {
                "os": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] import module var_0 . [SEP]",
        "reference": "import subprocess",
        "Output": "import subprocess",
        "Var_Maps": [
            {
                "subprocess": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with var_1 set to none as argument . [SEP]",
        "reference": "def get_version ( version = None ) : pass",
        "Output": "def get_version ( version = None ) : pass",
        "Var_Maps": [
            {
                "get_version": "var_0",
                "version": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the var_0 function with var_1 as argument , store the result in var_1 . [SEP]",
        "reference": "version = get_complete_version ( version )",
        "Output": "version = get_complete_version ( version )",
        "Var_Maps": [
            {
                "get_complete_version": "var_0",
                "version": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the var_0 wit var_1 as argument , store the result in var_2 . [SEP]",
        "reference": "major = get_major_version ( version )",
        "Output": "major = get_major_version ( version )",
        "Var_Maps": [
            {
                "get_major_version": "var_0",
                "version": "var_1",
                "major": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] var_1 v var_1 a var_1 r var_1 _ var_1 0 var_1 var_1 i var_1 s var_1 var_1 a var_1 n var_1 var_1 e var_1 m var_1 p var_1 t var_1 y var_1 var_1 s var_1 t var_1 r var_1 i var_1 n var_1 g var_1 . var_1 [SEP]",
        "reference": "sub = ` `",
        "Output": "sub = ` `",
        "Var_Maps": [
            {
                "sub": "var_0",
                "": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if fourth element of var_0 equals to string str_0 and fight element of var_0 equals to integer 0 , [SEP]",
        "reference": "if version [ 3 ] = = ` alpha ` and version [ 4 ] = = 0 : pass",
        "Output": "if version [ 3 ] = = ` alpha ` and version [ 3 ] = = 0 : pass",
        "Var_Maps": [
            {
                "alpha": "var_2",
                "version": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the function var_0 , store the result in var_1 . [SEP]",
        "reference": "git_changeset = get_git_changeset ( )",
        "Output": "git_changeset = get_git_changeset ( )",
        "Var_Maps": [
            {
                "get_git_changeset": "var_0",
                "git_changeset": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is true , [SEP]",
        "reference": "if git_changeset : pass",
        "Output": "if git_changeset : pass",
        "Var_Maps": [
            {
                "git_changeset": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] convert var_0 to string , app ##end it to the string str_0 , replace it for var_2 . [SEP]",
        "reference": "sub = ` . dev % s ` % git_changeset",
        "Output": "sub = ` . dev % s ` % git_changeset",
        "Var_Maps": [
            {
                ".dev": "str_0",
                "git_changeset": "var_0",
                ".dev%s": "var_1",
                "sub": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] otherwise if fourth element of var_0 does not equals to str_0 , [SEP]",
        "reference": "if True : pass elif version [ 3 ] ! = ` final ` : pass",
        "Output": "if ` True ` : pass elif version [ 3 ] ! = ` final ` : pass",
        "Var_Maps": [
            {
                "final": "var_1",
                "version": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] v var_4 r _ 0 is var_4 di var_6 ti ##on var_4 ry with 3 in ##iti var_4 l entries : str_0 for str_1 , str_2 for str_3 var_4 n ##d str_4 for str_5 . [SEP]",
        "reference": "mapping = { ` alpha ` : ` a ` , ` beta ` : ` b ` , ` rc ` : ` c ` }",
        "Output": "mapping = a ( mapping , ` beta ` , ` rc ` )",
        "Var_Maps": [
            {
                "a": "var_4",
                "alpha": "var_1",
                "b": "var_5",
                "beta": "var_2",
                "c": "var_6",
                "rc": "var_3",
                "mapping": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] use fourth element of var_1 as a key to get the value from var_0 dictionary , app ##end to it fourth element of var_1 converted to var_4 ing , var_3 st ##it ##ute it for var_3 . [SEP]",
        "reference": "sub = mapping [ version [ 3 ] ] + str ( version [ 4 ] )",
        "Output": "sub = mapping [ 3 ] * str ( version [ 3 ] )",
        "Var_Maps": [
            {
                "mapping": "var_0",
                "version": "var_2",
                "sub": "var_3",
                "str": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] sum var_0 and var_2 , return the result converted to var_1 ing . [SEP]",
        "reference": "return str ( major + sub )",
        "Output": "return str ( major + sub )",
        "Var_Maps": [
            {
                "major": "var_0",
                "str": "var_1",
                "sub": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with an argument var_1 default ##ing to none . [SEP]",
        "reference": "def get_major_version ( version = None ) : pass",
        "Output": "def get_major_version ( version = None ) : pass",
        "Var_Maps": [
            {
                "get_major_version": "var_0",
                "version": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] call the var_0 with an argument var_1 , store the result in var_1 . [SEP]",
        "reference": "version = get_complete_version ( version )",
        "Output": "version = get_complete_version ( version )",
        "Var_Maps": [
            {
                "get_complete_version": "var_0",
                "version": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] assign integer 2 to var_1 if third element of var_0 equals to zero , otherwise assign it integer 3 . [SEP]",
        "reference": "parts = 2 if version [ 2 ] = = 0 else 3",
        "Output": "parts = version [ 2 ] = = 3",
        "Var_Maps": [
            {
                "version": "var_0",
                "parts": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] convert var_6 into a var_4 ing for every var_6 in list of var_0 elements up to the var_2 ind ##e var_6 , var_3 the previous into a var_4 ing separated by var_4 _ 0 , assign the result to var_1 var_5 [SEP]",
        "reference": "major = ` . ` . join ( str ( x ) for x in version [ : parts ] )",
        "Output": "major = str ( str ( ` version ` , parts ( x ) ) for x in version [ 0 ] )",
        "Var_Maps": [
            {
                ".": "var_5",
                "version": "var_0",
                "major": "var_1",
                "parts": "var_2",
                "join": "var_3",
                "str": "var_4",
                "x": "var_7"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return major",
        "Output": "return major",
        "Var_Maps": [
            {
                "major": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 with in argument var_1 , default ##ing to none . [SEP]",
        "reference": "def get_complete_version ( version = None ) : pass",
        "Output": "def get_complete_version ( version = None ) : pass",
        "Var_Maps": [
            {
                "get_complete_version": "var_0",
                "version": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if version is None : pass",
        "Output": "if version is None : pass",
        "Var_Maps": [
            {
                "version": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] from var_2 import var_0 as var_1 into default name space . [SEP]",
        "reference": "from django import VERSION as version",
        "Output": "from django import VERSION as version",
        "Var_Maps": [
            {
                "VERSION": "var_0",
                "version": "var_1",
                "django": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] if var_1 gt ##h of var_0 does not equals to integer 5 , raise an exception . [SEP]",
        "reference": "assert len ( version ) = = 5",
        "Output": "assert len ( version ) = = 5",
        "Var_Maps": [
            {
                "version": "var_0",
                "len": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] if fourth element of var_0 does not equals to string str_0 or str_1 or str_2 or str_3 , raise an exception . [SEP]",
        "reference": "assert version [ 3 ] in ( ` alpha ` , ` beta ` , ` rc ` , ` final ` )",
        "Output": "assert version [ 3 ] not in ( ` final ` , ` beta ` )",
        "Var_Maps": [
            {
                "alpha": "var_1",
                "beta": "var_3",
                "rc": "var_4",
                "final": "var_2",
                "version": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 [SEP]",
        "reference": "return version",
        "Output": "return version",
        "Var_Maps": [
            {
                "version": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] define the function var_0 . [SEP]",
        "reference": "def get_git_changeset ( ) : pass",
        "Output": "def get_git_changeset ( ) : pass",
        "Var_Maps": [
            {
                "get_git_changeset": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 has an attribute str_0 , [SEP]",
        "reference": "if hasattr ( get_git_changeset , ` cache ` ) : pass",
        "Output": "if hasattr ( get_git_changeset , ` cache ` ) : pass",
        "Var_Maps": [
            {
                "cache": "var_2",
                "get_git_changeset": "var_0",
                "hasattr": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . var_1 . [SEP]",
        "reference": "return get_git_changeset . cache",
        "Output": "return get_git_changeset . cache",
        "Var_Maps": [
            {
                "get_git_changeset": "var_0",
                "cache": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] get the absolute var_5 of the var_1 , var_0 is name of the directory two level ##es above it . [SEP]",
        "reference": "repo_dir = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) )",
        "Output": "repo_dir = dirname . var_5 . var_2 ( __file__ )",
        "Var_Maps": [
            {
                "repo_dir": "var_0",
                "__file__": "var_1",
                "dirname": "var_3",
                "abspath": "var_4",
                "path": "var_7",
                "os": "var_10"
            }
        ]
    },
    {
        "intent": "[CLS] call the var_2 . var _ 9 function with , str_0 , var _ 7 set to var_2 . var_1 1 , [SEP]",
        "reference": "git_log = subprocess . Popen ( ` git log - - pretty = format : % ct - - quiet - 1 HEAD ` , stdout = subprocess . PIPE , stderr = subprocess . PIPE , shell = True , cwd = repo_dir , universal_newlines = True )",
        "Output": "subprocess . stderr ( ` git_log ` , stdout = subprocess . universal_newlines , stderr = subprocess . repo_dir , universal_newlines0 = git log - - pretty = format : % ct - - quiet - 1 HEAD , universal_newlines = ` False ` )",
        "Var_Maps": [
            {
                "git log --pretty=format:%ct --quiet -1 HEAD": "var_0",
                "universal_newlines": "var_1",
                "subprocess": "var_4",
                "repo_dir": "var_5",
                "git_log": "var_6",
                "stdout": "var_7",
                "stderr": "var_8",
                "Popen": "var_9",
                "shell": "var_10",
                "PIPE": "var_12",
                "cwd": "var_13"
            }
        ]
    },
    {
        "intent": "[CLS] st ##der ##r set to sub ##pro ##ces ##s . pipe , shell set to boo ##lean true , cw ##d set to rep ##o _ dir and universal _ new ##lines set to boo ##lean true , as arguments , substitute the result for var_2 . evaluate the method var_2 . var_0 , substitute first element of the result for var_1 . [SEP]",
        "reference": "timestamp = git_log . communicate ( ) [ 0 ]",
        "Output": "timestamp = git_log . communicate ( ) [ 0 ]",
        "Var_Maps": [
            {
                "communicate": "var_0",
                "timestamp": "var_1",
                "git_log": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] try [SEP]",
        "reference": "try : pass except : pass",
        "Output": "try : pass except : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the var_3 . var_3 . var_0 with var_1 converted to an var_5 e ##ger as argument , substitute result for var_1 . [SEP]",
        "reference": "timestamp = datetime . datetime . utcfromtimestamp ( int ( timestamp ) )",
        "Output": "timestamp = datetime . datetime . utcfromtimestamp ( int ( timestamp ) )",
        "Var_Maps": [
            {
                "utcfromtimestamp": "var_0",
                "timestamp": "var_2",
                "datetime": "var_4",
                "int": "var_5"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 exception is caught , [SEP]",
        "reference": "try : pass except Value Error : pass",
        "Output": "try : pass except Value Error : pass",
        "Var_Maps": [
            {
                "ValueError": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is none . [SEP]",
        "reference": "changeset = None",
        "Output": "changeset = None",
        "Var_Maps": [
            {
                "changeset": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] if not , [SEP]",
        "reference": "if True : pass else : pass",
        "Output": "if ` True ` : pass else : pass",
        "Var_Maps": [
            {}
        ]
    },
    {
        "intent": "[CLS] call the var_2 . var_3 with string str_0 as an argument , substitute the result for var_1 . [SEP]",
        "reference": "changeset = timestamp . strftime ( ` % Y % m % d % H % M % S ` )",
        "Output": "changeset = timestamp . strftime ( ` % Y % m % d % H % M % S ` )",
        "Var_Maps": [
            {
                "%Y%m%d%H%M%S": "var_0",
                "changeset": "var_1",
                "timestamp": "var_2",
                "strftime": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] substitute var_1 for var_0 . var_2 . [SEP]",
        "reference": "get_git_changeset . cache = changeset",
        "Output": "get_git_changeset . cache = changeset",
        "Var_Maps": [
            {
                "get_git_changeset": "var_0",
                "changeset": "var_1",
                "cache": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] return var_0 . [SEP]",
        "reference": "return changeset",
        "Output": "return changeset",
        "Var_Maps": [
            {
                "changeset": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] from var_0 import var_1 into default name space . [SEP]",
        "reference": "from xml . sax . saxutils import XMLGenerator",
        "Output": "from xml . sax . saxutils import XMLGenerator",
        "Var_Maps": [
            {
                "xml.sax.saxutils": "var_0",
                "XMLGenerator": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] derive the class var_0 form the var_1 base class . [SEP]",
        "reference": "class Simpler XMLGenerator ( XMLGenerator ) : pass",
        "Output": "class Simpler XMLGenerator ( XMLGenerator ) : pass",
        "Var_Maps": [
            {
                "SimplerXMLGenerator": "var_0",
                "XMLGenerator": "var_1"
            }
        ]
    },
    {
        "intent": "[CLS] define the method var_0 with 4 arguments : var_3 , var_4 , var_1 set to none and var_2 set to none . [SEP]",
        "reference": "def add Quick Element ( self , name , contents = None , attrs = None ) : pass",
        "Output": "def add Quick Element ( self , name , contents = None , attrs = None ) : pass",
        "Var_Maps": [
            {
                "addQuickElement": "var_0",
                "contents": "var_1",
                "attrs": "var_2",
                "self": "var_3",
                "name": "var_4"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is none , [SEP]",
        "reference": "if attrs is None : pass",
        "Output": "if attrs is None : pass",
        "Var_Maps": [
            {
                "attrs": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] var_0 is an empty dictionary . [SEP]",
        "reference": "attrs = { }",
        "Output": "attrs = { }",
        "Var_Maps": [
            {
                "attrs": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] cal the method var_2 . var_0 with 2 arguments : var_3 and var_1 . [SEP]",
        "reference": "self . start Element ( name , attrs )",
        "Output": "name , attrs = self . start Element ( )",
        "Var_Maps": [
            {
                "startElement": "var_0",
                "attrs": "var_1",
                "self": "var_2",
                "name": "var_3"
            }
        ]
    },
    {
        "intent": "[CLS] if var_0 is not none , [SEP]",
        "reference": "if contents is not None : pass",
        "Output": "if contents is not None : pass",
        "Var_Maps": [
            {
                "contents": "var_0"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_2 . var_0 with an argument var_1 . [SEP]",
        "reference": "self . characters ( contents )",
        "Output": "self . characters ( contents )",
        "Var_Maps": [
            {
                "characters": "var_0",
                "contents": "var_1",
                "self": "var_2"
            }
        ]
    },
    {
        "intent": "[CLS] call the method var_1 . var_0 with an argument var_2 . [SEP]",
        "reference": "self . end Element ( name )",
        "Output": "self . end Element ( name )",
        "Var_Maps": [
            {
                "endElement": "var_0",
                "self": "var_1",
                "name": "var_2"
            }
        ]
    }
]